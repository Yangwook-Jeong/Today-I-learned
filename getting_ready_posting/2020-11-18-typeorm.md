---
layout: post
title: TypeORM 마이그레이션과 코딩패턴
author: Yangeok
categories: Typescript
date: 2020-10-01 09:00
comments: true
tags: []
cover:
---

## 목차
- [목차](#목차)
- [이론](#이론)
  - [마이그레이션](#마이그레이션)
  - [N+1 문제](#n1-문제)
    - [eager/lazy loading](#eagerlazy-loading)
    - [dataloader](#dataloader)
- [실습](#실습)
  - [패턴](#패턴)
    - [Active record](#active-record)
      - [BaseEntity](#baseentity)
    - [Data mapper](#data-mapper)
  - [환경변수 세팅](#환경변수-세팅)

## 이론

아래 주제들은 typeorm 뿐만 아니라 sequelize를 관통하는 것들일 것 같다.

### 마이그레이션

라이브 환경에서 데이터베이스를 안정적으로 관리하기 위한 도구이다. orm에서 작성한 스키마를 데이터베이스에 동기화하는 방법으로 가장 쉬운 방법은 synchronize가 있다. 애플리케이션을 재시작할 때마다 기존 테이블에서 열을 추가, 삭제하는 동작을 할 수 있다.

synchronize는 최초에 데이터와 entity를 동기화할 때는 좋은 옵션이지만 프로덕션에는 안전하지 않다. 프로덕션에서 안전하게 데이터를 동기화하기 위한 좋은 대체 솔루션이 될 수 있다.

아래와 같이 `package.json`에 스크립트를 추가한다.

```json
"typeorm": "ts-node ./node_modules/typeorm/cli -f ./ormconfig.json"
```

그 다음 아래와 같이 스크립트를 날려주면 entity 파일에서 수정한 만큼의 쿼리를 sql로 만들어준다.

```sh
yarn typeorm migration:generate -n <migration-name>
```

마이그레이션 파일이 만들어졌으면 실행할 차례다.

```sh
yarn typeorm migration:run
```

반대로 마이그레이션을 되돌릴 수도 있다.

```sh
yarn typeorm migration:revert
```


### N+1 문제

orm을 사용할 떄 성능 문제가 있다면 들여다봐야 한다.

sequelize에서는 eager/lazy loading 관련 튜닝을 따로 해줘야하는 것 같다. typeorm에서는 eager/lazy relations라는 이름으로 기능을 실험적으로만 지원하고 있다. lazy loading을 사용하면 n+1 문제를 해결할 수 있다고 한다.

lazy loading을 sql의 join문으로도 구현할 수 있다. join문은 다음과 같이 사용할 수 있다.

```sql
SELECT fields
FROM table1_name t1
JOIN table2_name t2 
ON t1.id = t2.id;
```

참고로 그냥 join은 inner join의 alias이다. 

여담으로 jpa에는 n+1 자동 감지 도구인 db-util이 있다.

#### eager/lazy loading

이미지 로딩에서 처음 사용한 개념인줄 알았는데, orm에서 사용하는 것을 차용했나보다. 

- eager loading: 데이터 초기화가 현장에서 일어나는 패턴이다.
  - 초기 로딩 시간이 보다 길다.
  - 불필요한 데이터를 너무 많이 로드하면 성능이 영향을 끼칠 수도 있다.
- lazy loading: 가능한 한 객체의 초기화를 지연시키는데 사용하는 패턴이다.
  - 초기 로딩 시간이 보다 짧다.
  - 메모리 소비가 적다.
  - 지연된 초기화는 원치않는 순간에 성능에 영향을 줄 수도 있다.
  - 경우에 따라 특별히 초기화된 지연 초기화 객체를 처리해야하거나 예외가 발생할 수 있다.

jpa의 many-to-one, one-to-one 관계에서는 eager loading이 기본값이어서 select를 날리면 n+1을 트리거한다. 애초부터 쿼리를 날릴때 join을 붙여주면 lazy loading으로 바뀐다.

ror의 경우 ...

doctrine의 경우 ...

위처럼 lazy loading으로 join한 데이터를 가져올 수 있다.

eager loading의 문제는 다음과 같다.

#### dataloader

graphql에서 n+1 문제를 1+1로 변환해주는 라이브러리인 dataloader를 사용할 수 있다. javascriptdml event-loop를 사용해 

## 실습

### 패턴

#### Active record
`Entity`에 query method를 정의하고, query method를 사용해 객체를 crud한다. 
`BaseEntity`를 사용해 새로운 클래스에 상속받아서 사용할 수도 있다.

##### BaseEntity
모든 active record entity들은 `BaseEntity`를 상속해야 한다. `BaseEntity`가 갖고 있는 메서드와 `Entity` 내에 사용자가 정의한 static 메서드를 이용할 수 이싿. `BaseEntity`는 대부분의 standard repository가 가진 mehtod를 수행할 수 있다. 

참고로 이 패턴을 사용하면 `Repository`나 `EntityManager`를 사용할 필요가 없다.

비교적 간단해서 작은 서비스에서 유지보수하면서 사용하기 좋다.

```ts
// src/entity/User
import { BaseEntity, Entity, PrimaryGeneratedColumn, Column } from 'typeorm'

@Entity()
export class User extends BaseEntity {
  @PrimaryGeneratedColumn()
  id: number

  @Column()
  firstName: string

  @Column()
  lastName: string

  @Column()
  isActive: boolean

  static findByName(firstName: string, lastName: string) {
    return this.createQueryBuilder('user')
      .where('user.firstName = :firstName', { firstName })
      .andWhere('user.lastName = :lastName', { lastName })
      .getMany()
  }
}

// src/service/user
import { User } from 'src/entity/User'

const john = await User.findByName('John', 'Doe')
```

#### Data mapper
`Repository`를 이용해 객체를 crud한다. 위 패턴과 차이점은 모델에 접근하는 방식이 아닌 `Repository`에서 데이터에 접근한다는 점이다.

큰 서비스에서 유지보수하기에 용이하다.


```ts
// src/service/user
import { EntityRepository, Repository } from 'typeorm'
import { User } from 'src/entity/User'

@EntityRepository()
export class UserRepository extends Repository<User> {
  findByName(firstName: string, lastName: string) {
    return this.createQueryBuilder('user')
      .where('user.firstName = :firstName', {firstName})
      .andWhere('user.lastName = :lastName', {lastName})
      .getMany()
  }
}

const userRepository = connection.getCustomRepository(UserRepository)
const john = await userRepository.findByName('John', 'Doe')
```

### 환경변수 세팅