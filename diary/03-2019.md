# 오늘 배운 것을 정리하는 공간

## 03.03.2019

- 서버를 구분하려면 uuid가 필요하다.
- docker:

  - 네트워크 방식: `--net=NETWORK_TYPE`
    - bridge: 기본 설정이며 다른 방식으로 컨테이너를 생성하고 싶다면 `--net`플래그로 다른 옵션을 준다. docker0이라는 bridge가 도커 데몬을 실행하면 생성된다.
    - host: 컨테이너가 독립적인 네트워크 영역을 갖지 않고 host와 네트워크를 함꼐 사용하게 된다. 컨테이너의 ip와 인터페이스를 확인해보면 host의 네트워크 정보와 같다. bridge를 사용하지 않아서 docker0에 바인딩되지 않는다.
    - container: 다른 컨테이너의 네트워크 환경을 공유하게 된다. 사용법은 `--net=container:CONTAINER_ID`와 같다.
    - none: 격리된 네트워크 영역을 갖지만 인터페이스가 없는 상태로 컨테이너를 생성한다. 인터페이스를 직접 커스터마이징할 수 있도록 만든 것같다.
  - 컨테이너를 외부로 서비스하기 위해 동작하는 구조
    - 컨테이너를 생성하면 기본저긍로 외부와 통신이 불가능한 상태이다.
    - 외부로 노출할 포트를 지정한다
      - `-p 8080:80`와 같이 옵션을 지정했다면 외부에서 docker host의 8080포트로 요청이 들어왔을때 컨테이너의 80포트로 요청을 포워딩하겠다는 의미이다.
      - 컨테이너를 외부로 노출하도록 설정하면 docker host에는 docker-proxy라는 프로세스가 생성된다.
        - docker-proxy: docker host로 들어온 요청을 컨테이너로 넘기는 역할을 한다.
        - 컨테이너의 포트를 노출하도록 설정한 수만큼 프로세스가 생성된다.
    - link를 이용해서 컨테이너를 연동한다.
      - `--link CONTAINER_NAME` 옵션으로 ip를 이용하지 않고 컨테이너 이름을 이용해 통신을 주고 받을 수 있다.

- nginx: 로드밸런싱 역할을 한다.

## 04.03.2019

- 함수형 프로그래밍: 한개의 in이 있으면 한개의 out이 있다는 철학을 구현한다.
- 객체지향 프로그래밍: 외부에서 객체에 접근할때 객체 안쪽에 있는 변수를 숨길 수 있다.

- 비동기 발전과정
  <img src="https://cdn-images-1.medium.com/max/2000/1*ZcAVLAfcH5gZcVppRykWmg.png" width="500">

- typescript:

  - 언더스코어를 활용해서 `1000000000`을 `1_000_000_000`과 같이 표현해서 가독성을 높일 수 있다.
  - `never`타입으로 변수를 설정할 수 있다. 어떤 것으로도 설정될 수 없는 변수임을 의미한다.

- nginx:

  - 환경설정: 간단하게 서버블럭만 작성하면 서버를 실행할 수 있다.

    - user: `root`로는 설정하지 않아야 한다. 기본값은 `www-data`이다.
    - server: listen할 포트와 정적파일 위치를 설정한다.

    ```nginx
    server {
      listen 80;

      location / {
        root html;
        index.html;
      }
    }
    ```

- SNI(Server Name Indication): 여러개의 도메인 요청중에서 어디에 인증서 정보를 보내야 하는가를 알기 위해 사용한다.
- webpack:

  - entry: 의존성 그래프의 시작점을 의미한다. 의존하는 파일이 없고 entry가 A를 의존하고, A가 B를 의존하는 식으로 모듈이 연결된다. 설정파일에서 entry파일을 지정할 수 있다.

  ```js
  // webpack.config.js
  module.exports = {
    entry: {
      main: './src/main.js'
    }
  };
  ```

  - output: entry에 설정한 js파일을 시작으로 의존되어 있는 모듈을 하나로 묶어 번들링해 내보낸다. 결과물이 나오는 위치는 output키에 기록한다.

  ```js
  module.exports = {
    output: {
      filename: 'bundle.js',
      path: './dist'
    }
  };
  ```

  - loader: js뿐만 아니라 이미지, 폰트, 스타일까지 모듈로 관리한다. js외의 것은 웹팩이 이해하도록 변경하는 역할을 한다.

    - css-loader:

    ```js
    module.exports = {
      module: {
        rules: [
          {
            test: /\.css%/,
            use: ['style-loader', 'css-loader']
          }
        ]
      }
    };
    ```

  - plugin: loader는 번들되기 전 파일단위를 처리하는 반면, plugin은 번들된 결과물을 추가로 처리한다. 난독화 한다거나 특정 텍스트를 추출하는 용도로 사용한다.

## 07.03.2019

- EADDRINUSE: node.js에서 같은 포트번호를 다시 사용하려고 하면 발생하는 에러이다.

## 08.03.2019

- `netstat -nap`:
  - n: host명으로 표시하지 않는다.
  - a: 모든 소켓을 표시한다.
  - p: 프로세스 id와 프로그램명을 표시한다.

## 09.03.2019

- deploy:

  - canary: 구버전과 새로운 버전의 코드를 함께 올려둔채 트래픽을 전송하고 새버전의 앱으로 보내는 트래픽의 비율을 점직적으로 증가시킨다.
  - blue/green: 구버전과 새로운 버전의 코드를 함께 올려둔채 트래픽을 이동시키고 구버전의 코드를 제거한다.

- git hook: `.git/hooks`폴더에 스크립트를 작성하면 사용할 수 있다.

## 10.03.2019

- `ls -ahl`: 숨김폴더까지 볼 수 있게 해주는 옵션이다.

## 12.03.2019

- slack에 깃헙 저장소 연결하기:
  - 슬랙 채널 만들기
  - 앱추가하기
    - github,
    - github notification legacy
      - 세팅 들어가서 add configuration 클릭하기
      - 사용할 슬랙채널 골라서 integration 클릭하기
      - 슬랙으로 깃헙 저장소 권한 가져오기
      - 깃헙 저장소에서 webhooks 들어가기
      - payload url에 생성된 주소 입력하기
      - 슬랙 세팅 저장하기

## 13.03.2019

- apollo: 프론트, 백엔드에서 사용할 수 있는 상태관리 도구이다.
