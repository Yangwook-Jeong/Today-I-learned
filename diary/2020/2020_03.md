## 01.03.2020

- python - `*args`: list로 인자를 전달받았을 때, 파라미터로 사용할 수 있다. - `**kwargs`: dict로 인자를 전달받았을 때, 파라미터로 사용할 수 있다. - `requirements.txt`: 배포할 수 없는 것을 위한 파일 - `setup.py`: 재배포를 위한 파일

- git-editor - `git config --global core.editor "EDITOR_NAME"` - 혹은 `.gitconfig`에서 아래와 같이 추가한다.
  `sh [core] editor = EDITOR_NAME`

## 02.03.2020

- graphql
	- flow
		- 쿼리에 포함된 모든 필드에 대해 쿼리를 처리하는 리졸버 함수를 각각 호출한다.
		- 쿼리의 모양에 따라 데이터를 잘 포장해 응답으로 만든다.
	- query
		- named: static
			```graphql
			{
			  human(id: "1000") {
			    name
			    height
			  }
			}
			```
		- operation: dynamic
			```graphql
			query HeroNameAndFriends($episode: Episode) {
			  hero(episode: $episode) {
			    name
			    friends {
			      name
			    }
			  }
			}
			```
	- resolver
		- resolver 함수 내부에는 내부적으로 db query가 존재한다. 즉, query에 맞게 필요한만큼만 최적화해서 호출이 가능하단 뜻이다.
		- query로 특정 필드에 대한 요청이 왔을때 어떤 로직으로 처리할지 graphql에게 알려주는 역할을 한다.
		- `resolver(parent, args, ctx, info)`
			- `parent`: 부모 타입의 객체 (=`root`)
			- `args`: gql 쿼리 필드에 제공된 인수
			- `ctx`: 모든 `resolver` 함수에 전달되며, 현재 로그인한 사용자, 데이터베이스 연결과 같은 중요한 정보를 가진 값
			- `info`: 현재 쿼리, 스키마 정보와 관련된 필드별 정보를 보유하는 값

- type-graphql
	- resolver
		- `Root`
			- 기존 resolver 함수의 첫번째 인자인 `parent`와 같다.
			- `@Root()`는 바로 이어 나올 값이 `parent`라는 것을 decorator로 알려주는 역할을 한다.

## 03.03.2020

- javascript
	- prototype: 원본을 이용해 생성한 프로토타입이 사본이라면, 원본을 바꾸면 사본에는 영향을 주지만, 사본을 수정한 경우 원본에는 영향이 없다.
		- prototype: 원형 객체
		- constructor: instance가 초기화될때 실행하는 함수
		- instance: 지금 막 생성된 객체
		- `__proto__`: 모든 객체가 가지고 있으며, 상위 객체를 가리키고 있다.

- typescript
	- `implements`
		- 뒤에 interface를 선언하면 해당 class는 지정된 interface를 반드시 구현해야 한다.
		- 이는 Interface를 구현하는 class의 일관성을 유지할 수 있는 장점이 있다.
		- interface는 property와 method를 가질 수 있다는 점에서 class와 유사하지만, 직접 instance를 생성할 수는 없다. 단, interface에는 추상 method만 포함되어야 한다. 
		- interface를 구현하는 class는 interface에서 정의한 property와 추상 method를 모두 구현해야한다.
			```ts
			// 인터페이스의 정의  
			interface IPerson {  
				name: string; 
				sayHello(): void;  
			}  
	
			// 인터페이스를 구현하는 클래스는 인터페이스에서 정의한 프로퍼티와 추상 메소드를 반드시 구현하여야 한다. 
			// Person 클래스는 IPerson 인터페이스를 구현해야 한다.
			class Person implements IPerson {  
				// 인터페이스에서 정의한 프로퍼티의 구현  
				constructor(public name: string) {}  

				// 인터페이스에서 정의한 추상 메소드의 구현  
				sayHello() { 
					console.log(`Hello ${this.name}`); 
				}	 
			 }  

			function  greeter(person:  IPerson):  void  {  
				person.sayHello(); 
			}  
			
			const me = new Person('Lee');  
			greeter(me);  // Hello Lee
			```

- type-graphql
	- resolver
		- `@Resolver(typeFunc)`
		- `@FieldResolver(returnTypeFunc)`
			- resolver에서 무엇을 위한 것인지 알려주고, 이를 통해 parent를 entity로 사용하기 위해 entity를 명시하고 있다.
				```ts
				@Resolver(() => Entity) // of => Entity 또는 Entity 모두 같은 의미로 사용 가능하다. 
				```
		- `@Mutation(returnTypeFunc)`
			- `@Args/@ArgsType`
				```ts
				@ArgsType()
				export class FooArgs {
					@Field()
					bar: string;
				}
				```
			- `@Arg/@InputType`: `Partial<Foo>`를 사용한 것은 `input`의 `bar`가 `string`이며, `Foo`의 `bar`와  같은 타입이기 때문이다. 
				```ts
				@InputType()
				export class FooInput implements Partial<Foo> {
					@Field()
					bar: string;
				}
				```  
		- `@Query(returnTypeFunc)`
	- schema
		- schema를 빌드하는 방식
			```ts
			// 1st way
			import { buildSchema } from 'type-graphql'
			import { FirstResolver, SecondResolver } from '../resolvers'

			const schema = await buildSchema({
				resolvers: [FirstResolver, SecondResolver]
			})

			// 2nd way
			import { buildSchema } from 'type-graphql'
			
			const schema = await buildSchema({
				resolvers: [
					__dirname + '/modules/**/*.resolver.ts',
					__dirname + '/resolvers/**/*.ts'
				]
			})
			```
		- typeDefs와 resolver map을 만들어 schema를 만드는 방식
			```ts
			import { buildTypeDefsAndResolvers } from 'type-graphql'
			import { makeExecutableSchema } from 'graphql-tools'
	
			const { typeDefs, resolvers } = await buildTypeDefsAndResolvers({
				resolvers: [FirstResolver, SecondResolver]
			})

			const schema = makeExecutableSchema({ typeDefs, resolvers })
			``` 
	- middleware
		- `@UserMiddleware(MiddlewareFn)`: 권한을 사용한다면 resolver에 decorator로 넣고 middleware 함수를 인자로 넣어주면 된다.
			- `MiddlewareFn`은 인자로 `action`, `next`을 받는 구조이다.
				- `action`은 `{ root, args, context, info }`로 구성되어있다.

- git-stash
	- `pop` = `apply` + `drop`

- typeorm
	- relationship
		- `@ManyToMany(TypeFnOrTarget, inverseSide )`
		- `@JoinTable()`은 한 테이블에서만 사용해줘야 한다.

## 04.03.2020

- react-native
	- keyboard avoiding view
		- 화면 내 요소들이 가상키보드의 경로에서 벗어나게 해준다.
		- 키보드의 위치에 따라 높이, 위치, 바닥패딩을 조절해준다. 한 화면에 요소가 많을경우 유용하다. 

- react
	- `useEffect()`
		- 렌더링 될 때마다 특정 작업을 수행할 수 있도록 한다.
		- 화면에 가장 처음 렌더링 될 때만 실행하고 그 뒤로는 실행할 필요가 없는  경우에는 두번째 인자에 빈 배열을 넣어준다.
			```js
			useEffect(() => console.log('when only mounted'), [])
			```
		- 특정 값이 변경될 때만 호출하게 하고 싶은 경우 두번째 인자에 들어가는 배열에 값을 넣어준다.
			```js
			useEffect(() => console.log(name), [name])
			```
	- `useCallback()`
		- 이전에 실행한 값을 두번째 인자로 받아 배열의 값이 바뀔 때에만 안에 있는 함수를 실행한다.
		- 함수를 재사용하기 위해 사용한다.
	- `useMemo()`
		- 이전에 실행한 값을 두번째 인자로 받아 배열의 값이 바뀔 때에만 안에 있는 함수를 실행한다.
		- 숫자, 문자열, 객체처럼 일반 값을 재사용하기 위해 사용한다.
		
		```js
		useCallback(() => {
			console.log('hello')
		}, [])

		useMemo(() => {
			const fn = () => {
				console.log('hello')
			}
			return fn
		}, [])
		```

- big-o notation: 알고리즘의 성
	- O(1): constant time
		- 입력데이터의 크기에 상관없이 언제나 일정한 시간이 걸리는 알고리즘이다.
		- 인덱스가 주어진 배열
	- O(log n): logarithmic
		- 입력값 n이 주어졌을 떄, 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인으로 줄어든다.
		- 이진 탐색트리
	- O(n): linear time
		- 입력 데이터의 크기에 따라 처리시간이 걸리는 알고리즘이다.
	- O(n^2): quadratic time
		- 입력 데이터의 크기에 제곱비례에 처리시간이 걸리는 알고리즘으로 효율이 좋지 않다.
		- 이중 for문
	- O(2^n): exponential time
		- 문제 해결 단계의 수는 주어진 상수값 c의 n제곱으로 효율성이 더 좋지 않다.
		- 피보나치 수열
	
	<img src="https://img.velog.io/images/jellyloveschoco/post/10fe42fc-fdda-4dc0-9944-05f7b20b60b6/big0.jpeg?w=1024" width="500">

## 05.03.2020

- react
	- input
		- `value`: dom의 값보다 우선시 한다. 때문에 초기값이 변하지 않는다.
		- `defaultValue`: 후속 업데이트를 다루기 위해서는 defaultValue를 써야한다.

## 06.03.2020

- github-issue
	- 새로운 이슈를 열고 번호를 확인한다.
		- 인원할당, 라벨, 프로젝트 종류, 마일스톤을 기록할 수 있다.
	- 로컬 저장소에 새로운 브랜치를 딴다. 형식은 이슈번호-설명 따위로 한다.
	- 이슈에 적어둔 목표를 해결한다.
	- 작업을 테스트해 제대로 완료됐는지 확인한다.
	- 수정사항을 커밋하고 푸시한다. github이 커밋을 추적하도록 메시지 안에 이슈 번호를 적어야 한다.
	- 작업이 잘완료됐다면 메인브랜치에 병합한다.
	- 이슈에 모든 내용이 잘 기록됐는지 확인하고 이슈를 닫는다.

- development methodology
	- agile: 팀원들이 시간예측을 굉장히 잘한다는 가정하에 잘 돌아가는 방법론이다.
	- scrum-board
		- sprint-backlog
			- 스크럼에서 사용하는 제품 개발 요구사항 혹은 일감 목록을 말한다.
		- 백로그들을 게시한 판으로 업무 진행사항을 투명하게 관리하기 위해 사용한다.
		- 보통 한개의 스토리를 할일, 진행중, 완료로 구분해서 사용한다.
		- 일정한 길이의 스프린트로 반복한다.
		- po의 승인 하에, 각 스프린트 막바지에 배포한다.
		- 시간 추정이 꼭 필요하다.
		- 일반적으로 한 스프린트당 걸린 시간이 주요 지표이다.
		- 되도록이면 이번 스프린트에서는 변경을 지양하고, 다음 스프린트에 반영한다.
	- kanban
		- 반복주기가 따로 없고 연속적인 흐름이다.
		- 연속적으로 배포하거나 혹은 팀 재량껏 배포한다.
		- 시간 추정이 따로 없이 티켓마다 비슷한 작은 크기로 쪼개야 한다.
		- 한 티켓이 완료되는데까지 걸린 시간이 주요 지표이다.
		- 변경이 언제든 일어날 수 있다.
	- burn-down chart
		- 남은 업무 대비 시간을 표현한 차트이다.
		- 파란선은 계획에 따른 남은 건수, 빨간선은 실제로 남은 건수이다.
		- 가로축은 스프린트 1회분이다.
			<img src="https://upload.wikimedia.org/wikipedia/commons/8/8c/Burn_down_chart.png" width="500">

- react
	- `useQuery(query, options)` 결과값을 상태에 바로 밀어넣고 싶은 경우
		- `useEffect()`를 사용하면 too-many re-render 오류 발생
		- `options`에 `onCompleted`란 파라미터를 사용하면 해결할 수 있다.
			```js
			const { data, error, loading, refetch } = useQuery(VideoPostQuery, {
				variables: { postId },
				onCompleted:  data  => setCategoryIndex(categories.indexOf(data.videoPost.type)),
			});
			``` 

- javascript
	- 두 배열 차이 비교하기
		```js
		// prototype 사용
		Array.prototype.diff = function (a) {
			return this.filter(i => a.indexOf(i) < 0)
		}

		[1, 2, 3, 4, 5, 6].diff([3, 4, 5]) // [1, 2, 6]
		
		// 함수 선언
		const diff = (a, b) => b.filter(i => a.indexOf(i) <0)

		diff([1, 2, 3, 4, 5, 6], [3, 4, 5]) // [1, 2, 6]
		```

## 07.03.2020

- system availability methodology
	- backup & recovery
	- ha(**h**igh **a**vailability)
		- 특징
			- 서버 이중화, 고가용성. 절대 고장나지 않음을 의미한다. 
			- 1년에 계획된 것을 제외하고 5'15'' 이하로 장애시간을 허용한다는 의미에서 5 nines, 즉 99.999%의 가용성을 목표로 하는 시스템을 말한다.
		- 목적
			- failover 
				- 시스템 대체 작동. 클론된 서버가 장애 발생시 일을 대신 처리하도록 만드는 것을 의미한다.
				- 운영용 서버 2대를 active, stand by 형태로 구성한다.
			- load-balancing: 부하균형. 두 개 이상의 서버가 일을 분담처리해 서버에 가해지는 부하를 분산시키는 것을 의미한다.
	- dr(**d**isaster **r**ecovery)
		- 재해복구. 장애발생시 다운된 시스템을 정상으로 회복시켜 서비스를 재개한다.
		- 이 중 가장 포괄적인 대처 방법론이다.
		- 어떠한 상황에서도 os, app, data 모두를 회복시켜 서비스를 재개하는 것을 목표로 한다.

- git
	- `git push origin -d {BRANCH_NAME}`: remote 브랜치 삭제
	- `git fetch -p`: remote에 있는 정보를 local로 가져온다.
		- `-p`는 prune을 의미한다. 때문에 `git remote prune origin`을 써도 된다.

- graphql-client
	- apollo: 대중적인 fe 라이브러리를 지원하며, 모바일을 위한 초기버전도 지원한다. caching, optimistic ui, pub supporting같은 기능들을 지원한다.
	- relay: facebook에서 개발했으며, routing 본래 framework로 탄생했다. 성능상 장점을 취하기 위해서는 높은 러닝커브를 극복해야 한다.
	- urql: react에 초점을 두고 개발했지만, 간단함, 확장성을 목표로 한다.

- apollo-client
	- 저수준 네트워크 로직들을 추상화해 graphql 서버에 대한 인터페이스를 제공한다.
	- 필수 의존성들을 호출한다.
		```js
		import { ApolloProvider } from 'react-apollo'
		import { ApolloClient } from 'apollo-react'
		import { createHttpLink } from 'apollo-link-http'
		import { InMemoryCache } from 'apollo-cache-memory'
		```
	- graphql api를 사용해 `ApolloClient`에 연결하는 `httpLink`를 생성한다.
		```js
		const httpLink = createHttpLink({
			uri: 'http://localhost:4000'
		})
		```
	- `ApolloClient`에 `httpLink`를 인자로 전달해 인스턴스를 생성하고, `InMemoryCache` 인스턴스를 생성한다.
		```js
		const clinet = new ApolloClient({
			link: httpLink,
			cache: new InMemoryCache()
		})
		```
	- react app 최상위 컴포넌트를 렌더링한다. `App`은 고차 컴포넌트 `ApolloProvider`로 감싸지고, `client`를 props로 전달받는다.
		```js
		ReactDom.render(
			<ApolloProvider client={client}>
				<App/>
			</ApolloProvider>,
			document.getElementById('root')
		)
		serviceWorker.unregister()
		```

- http-status
	- 2xx
		- 201 created 
			- `POST`, `PUT`의 응답으로 요청을 정상적으로 처리했고, 새로운 리소스가 생겼다는 의미를 포함한다. 
			- header의 `Content-Location`을 사용해 만들어진 리소스 위치를 알려주면 더 좋다.
		- 202 accepted
			-  요청은 정상적이나, 서버가 아직 요청을 완료하지 못했다는 의미를 갖는다. 
			- 비동기 요청을 한 경우, 이 코드로 응답을 주고, `callback`, `polling`으로 요청이 완료된 순간 응답을 준다. 둘다 주는 것이 좋다.
		- 204 no content
			- 202와 비슷하지만, 컨텐츠를 제공하지 않는다는 의미이다.
			- 자원 삭제 요청을 보냈고, 요청이 유효해서 서버는 해당 자원을 삭제했다. 그래서 더 이상 응답할 컨텐츠가 없기때문에 204를 사용한다.
			- res body로 `null`, `{}`, `[]`, `false` 등으로 응답하는 것과는 다른 경우로 res body가 아예 존재하지 않는 경우이다.  
	- 4xx
		- 400 bad request
			- 요청이 유효하지 않아 더 이상 작업을 진행하지 않는 경우를 의미한다.
			- api는 요청이 오면 바로 작업하지 않고, 요청이 서버가 정의한 유효성이 맞는지 확인하는데, 이 유효성이 맞지 않으면 400으로 응답한다.
			- 400 코드만으로 응답하는 것은 부족하다. 파라미터의 위치, 사용자 입력값, 에러 이유를 명시하는 것이 좋다.
		- 401 unauthorized
			- 클라이언트가 인증이 되지 않아, 권한이 없어 작업을 진행할 수 없는 경우를 의미한다.
			- 상태코드만 보면 권한(authorized)에 대한 내용같지만, 사실 인증(authenticated)에 관한 이야기이다.
		- 403 forbidden
			- 클라이언트가  권한이 없어 작업을 진행할 수 없는 경우를 의미한다.
		- 404 not found
			- 요청한 자원 혹은 경로가 존재하지 않는다는 의미이다.
		- 405 method not allowed
			- 요청이 허용되지 않는 메서드인 경우를 의미한다.
			- api가 허용하는 메서드가 어떤 것들이 있는지 확인하는 `OPTIONS`와 관련있다. 405를 사전에 방지하기 위한 용도로 쓰인다.
			- 이때 응답 header의 `Allow`에 지원하는 메서드를 나열해 응답한다.
		- 409 conflict
			- 요청이 서버의 상태와 충돌한 경우를 말한다. 앞서 나열한 상태에 속하기 애매한 경우에 사용한다.
			- 오류의 원인을 알려줘야 한다.
			- 다음과 같은 경우가 있다고 가정한다면 로직상 모순이 발생해 409를 사용할 수 있다.
				```sh
				DELETE /users/1 HTTP/1.1
				X-TOKEN: password
				```
				- 자원 `/users/1`에 존재하는 메서드라서 `not 405`
				- `/users/:id`에서 id가 유효한 형식이라서 `not 400`
				- 1 사용자도 존재해서 `not 404`
				- 헤더의 인증이 정확해서 `not 401`
				- 삭제 권한이 있는 경우라서 `not 403`
		- 429 too many requests
			- 비정상적인 방법으로 자원을 요청하는 경우에 응답한다.
			- dos는 가용성에 대한 공격이고, brute-force는 기밀성에 대한 공격인데, 서버입장에서는 두 공격 모두 가용성에 피해를 입을 수 있다.
			- 서버가 감당하기 힘든 요청이 계속 들어오면 n시간동안 n회만 요청이 가능하도록 룰을 정하고, 이것을 초과하면 429로 응답해야 한다.
	- 5xx
		- api를 사용하는 클라이언트에 5xx 상태는 나타내지 말아야 한다.
		- api에서 완벽한 예외처리를 통해 서버 오류를 방지해야한다.

- docker-network: docker를 설치한 후 network interface를 보면 `docker0`이란 가상 interface가 생긴다. 이것은 가상 interface가 아니고, docker가 자체적으로 제공하는 network driver중 `bridge`에 해당한다.
	- bridge
		- container가 통신하기 위한 용도로 사용한다. container가 생성되면 자동으로 bridge를 활용하도록 설정되어 있다.
		- `docker0` interface는 `172.17.0.0/16` subnet을 갖기 떄문에 이 대역 안에서 ip를 할당받는다.
	- host
	- none

- ssh-key
  - private key는 로컬에, public key는 원격머신에 위치해야 한다.
  - private key가 노출되서 누군가가 사용하는 것을 방지하기 위해 private key를 passphrase로 암호화해서 디스크에 저장할 수 있다.
  - public key로 메시지를 암화화할 수 있는데, 그 암호화된 메시지는 그 쌍이 되는 private key로만 해석할 수 있다. 암호화에 사용한 public key로도 암호화된 메시지를 해석할 수 없다.
	- 다음과 같은 흐름을 갖는다.
  	- client가 server에 ssh 연결을 요청한다.
  	- server는 random challenge(data string)을 생성해 client에게 보낸다.
  	- client는 server로부터 받은 challenge를 자신이 가지고 있는 private key로 암호화해서 암호화된 메시지를 server로 보낸다.
  	- server는 client에서 받은 암호화된 메시지를 public key로 해석한 결과를 2에서 자신이 client에게 보낸 random challenge와 일치하는지 확인한다.

			<img src="https://2.bp.blogspot.com/-KFIKbVe38GY/VRugz3LpcHI/AAAAAAAAEUY/_zcGcOwpp90/s1600/DB30E7AC-42F8-4876-9BA4-04CB4623571F.png" width="500">

	- passphrase는 옵션으로 private key를 디스크에 저장할때 암호화할 때 사용한다. 장점은 다음과 같다.
  	- private ssh key는 network상에 절대로 노출되지 않는다. passphrase는 local machine상 private key를 해석하는데만 사용된다. 때문에 network 기반의 brute-force 공격이 불가능해진다.
  	- private key는 제한된 directory 내에서만 보관이 된다. ssh client는 제한된 directory에 보관되지 않는 private key는 인식하지 않는다. 또한 key 자체는 제한된 permission을 가져야 한다. owner만 `rw-`를 갖는게 가능하다. 즉 system의 다른 사용자가 볼 수 없다는 것을 의미한다.
  	- private ssh key의 passphrase를 탈취하려는 해커는 이미 system access를 할 수 있어야 한다. 이 경우 이전 ssh key 쌍을 새로 만들고 이미 탈취당한 쌍은 삭제할 시간을 벌 수 있다.

## 10.03.2020

- expo
	- react-native만으로 개발을 시작하면, xcode, android studio에 개발자 계정을 만들어 signing 설정하는 과정을 줄여준다.	
	- expo 안에 들어가는 앱은 순수 javacsript로 작서되고, 절대로 nataive ios, android 레이어까지 내려가지 않는 것이 그들의 철학이다.
	- native 언어로 된 라이브러리를 이용할 수 없는 한계가 있다.
	- 동작환경
		- 로컬환경에 두 개의 서버를 띄워 동작한다. 핵심은 expo client이며, 작성한 코드가 여기서 직접 구동되는게 아니라, 받아온 react-native 앱을 expo client 안에서 실행시킨다. 
			- expo client에 react-native가 번들링한 js 파일을 내려주기 위한 **초록색** 서버
			- expo cli와 expo client 둘 사이의 통신을 위한 **핑크색** 서버		

			<img src="https://lh3.googleusercontent.com/uI0fYPxqo0urSM60u_FbYdGwJmSspF5odKhn-RQAQufCtbJG5j9aFxuPqJ_6SXcFgCfBl2IfWVw" width="500">
			
	- expo-native 앱의 차이
		- native
			- native 언어로 작성된 코드를 컴파일한 후, 모바일 기기에 설치되어 os 레이어와 직접 상호작용하면서 동작한다.
		- expo
			- 작성한 javascript 코드는 expo client 안에서만 동작하고, javascript 엔진으로만 동작하기때문에 native 언어로 된 라이브러리를 소화할 수 없다.
			- expo 앱은 native 앱이라서 os 레이어와 상호작용이 가능하다.
			- expo 안에 있는 앱이 요구하는 native 모듈 기능을 expo가 대신 처리한다.
			- 코드를 작성할때 expo 안에 react 컴포넌트로 만들어둔 모듈을 이용해 단순한 웹뷰 수준을 벗어나 native한 기능을 구현할 수 있다.
			- 하지만 구현 가능한 기능의 범위가 expo에서 제공하는 기능을 벗어날 수 없기때문에, bluetooth 컨트롤이나, native 언어로 된 모듈을 이용할 때 eject를 사용한다.
	- eject
		- 순수 javascript로 작성된 앱을 expo client에서 꺼내서, react-native로만 개발 환경을 변경한다.
		- expo id, ios bundle identifier, android package name가 필요하다.
		- notification pipeline을 직접 관리해야한다.
		- eject를 하면 `ios`, `android` 폴더가 생성되는데, 각각 xcode, android studio 프로젝트를 가지고 있다. 
	- uni-modules
		- native 모듈이 갖는 문제점 중 함께 따르는 표준이 없다는 것과 그로 인해 폴더구조, 중복된 라이브러리를 여러 곳에서 다른 방식으로 사용하는 등의 문제점을 해결하려는 대안이다.
		- 오픈소스 커뮤니티들이 표준을 제 멋대로 만들다보니, 호환성과 효율성이 떨어진 것을 유니모듈이란 컨벤션으로 호환성을 높여보자는 목적이다.

- format
	- cpp
		- `.h`: 선언을 구현한 헤더파일
		- `.cpp`/`.cxx`: 정의를 구현한 소스파일
		- `.hpp`/`.hxx`: 템플릿을 구현한 소스파일
	- objective-c
		- `.m`: 정의를 구현한 소스파일
	- commen
		- `.mm`: cpp, objective-c에서 혼용가능한 파일

## 11.03.2020

- github-project
	- 리스트방식의 이슈를 칸반보드 형태로 조직화해 워크플로우를 한 눈에 볼 수 있다.
	- 직접 이슈 카드를 생성할 수 있고, convert to issue를 통해 이슈로 변환할 수 있다.
	- 템플릿
		- none: 완전히 비어있는 스크래치에서 시작한다. 컬럼과 자동화 설정을 스스로 할 수 있다.
		- basic kanban: 기본형 칸반보드 형태로 `todo`, `in progress`, `done`을 갖추고 있다.
		- automated kanban: 빌트인 트리거로 자동으로 이슈와 pr을 `todo`, `in progress`, `done`으로 옮겨주는 기능을 갖추고 있다.
		- automated kanban with reviews: pr 리뷰 기능도 갖추고 있는 자동화된 칸반보드이다.
		- bug triage: `needs triage`, `high priority`, `low priority`, `closed`로 버그를 분류할 수 있도록 컬럼을 제공해준다.

- typescript 
  - decorator
    - class
      - 클래스 정의를 관찰, 수정하는데 사용할 수 있는 클래스 생성자에 적용된다.
    - method
      - 메서드의 프로퍼티에 적용된다.
      - 프로퍼티 descriptor 객체를 제어할 수 있다.
    - accessor
      - 프로퍼티 descriptor 객체를 제어할 수 있다.
      - 단일 멤버에 대한 `get`, `set`을 모두 데코레이팅하는 것을 typescript에서는 허용하지 않는다.
    - property
    - parameter

- javascript
  - Object
    - `seal()`
      - 객체를 밀봉하면 그 객체에 새로운 속성을 추가할 수 없고, 현재 있는 모든 속성을 설정 불가능으로 만들어준다.
      - 하지만 쓰기 가능한 속성의 값은 밀봉 후에도 변경할 수 있다.
      - 즉 데이터 속성과 접근자 속성의 수정은 불가능하다.
    - `freeze()`
      - 객체를 동결하면 더 이상 변경할 수 없다.
  - descriptor
    - 설명자라고 부르며, decorator를 이해하기 전 필요한 선행지식이다.
    - 객체의 프로퍼티로 프로퍼티가 쓰기 가능한지, 열거 가능한지 여부를 나타낸다.
    - `Object.getOwnPropertyDescriptor(obj, propName)`을 사용하면 descriptor를 구할 수 있다.
      - `propName`은 `obj`의 속성이며, 프로토타입 체인에 속하지 않아야 한다.
    - 프로퍼티의 현재 값, 권한 등을 가지는 객체를 돌려준다.
			```js
			const obj = { a: 1, b: 2 }

			console.log(Object.getOwnPropertyDescriptor(obj, 'a'))
			// { 
			//	value: 1,
			//	writable: true,
			//	enumerable: true,
			//	configurable: true
			// }			
			```
		- 객체에 새로운 속성을 부여하기 위해 `obj.propName = value`같은 방식을 사용하기도 하지만 `Object.defineProperty()`를 사용하기도 한다. 이때, 메서드의 결과값은 1번째 인자의 객체이다.
  		- writable: 객체의 프로퍼티가 쓰기 가능한지의 여부이며, `false`일 경우 값 쓰기가 안된다.
				```js
				const obj = { num: 100 }
				Object.defineProperty(obj, 'num', { writable: false })

				obj.num = 0
				console.log(obj) // { num: 100}
				```
  		- enumerable: 객체의 프로퍼티가 열거 가능한지의 여부이며, `false`일 경우 `Object.keys()`따위의 메서드로 해당하는 프로퍼티를 확인할 수 없다.
				```js
				const obj = { num: 10 }

				Object.defineProperty(obj, 'num', { enumerable: false })

				Object.keys(obj) // []
				Object.values(obj) // []
				Object.entries(obj) // []
				```
  		- configurable: 객체의 프로퍼티가 `defineProperty()`를 통해 설정될 수 있는지의 여부이며, `false`일 경우 해당 프로퍼티를 수정할 수 없다.
				```js
				const obj = { num: 5 }

				Object.defineProperty(obj, 'num', { writable: false, configurable: false })
				Object.defineProperty(obj, 'num', { writable: true }) // Uncaught TypeError
				```

## 12.03.2020

- react
	- `useEffect(cb, deps)`
		- `deps`는 배열로 함수 내에 사용될 인자를 적어줘야 한다. `deps` 값이 바뀌면, 리렌더링 전에 unmount가 먼저 실행되고, 그 다음 리렌더 된 다음 mount가 실행된다.
		- mount: 새로운 화면이 열리거나 값이 바뀔때마다 리렌더된다.
		- unmount: 해당 컴포넌트가 사라지거나 값이 바뀔때 호출된다.
