## 02.05.2020

- cidr: Classless Inter-Domain Routing
  - subnetmask로도 ip 할당 범위를 지정할 수 있지만 그것보다 더 가독성이 좋은 방식이다.
  - 여러 ip가 모인 그룹이라고 할 수 있다. 
  - cidr 블락을 여러개의 네트워크로 나누는 것을 subnetting이라고 한다.
  - 각각의 class를 2진수로 바꾸면 8비트 값이 되고, 총 32비트각 된다.
  - cidr값은 32부터 0까지 사용할 수 있다.
  - 유효한 클래스 범위는 0부터 255까지이다.
  - 예를 들어, `171.16.0.0/24`라는 ip가 있다면 `171.16.0`까지는 network prefix가 되고, `0`은 host identifier가 된다. 허용되는 ip의 범위는 `171.16.0.0`부터 `171.16.0.254`까지가 되겠다.

- dev platform for mobile/web app 
  - 비슷한 점
    - 스케일링이 되고 안전하게 모바일/웹 애플리케이션을 빌드할 수 있게 디자인된 플랫폼이다.
    - 유저 인증을 간편하게 도와주고, 데이터/사용자 메타데이터를 데이터에 선택적 접근을 허가하고, 머신러닝을 통합시켜준다.
  - 기능
    - 리얼타임 앱
      - 사용자에게 동적으로 데이터를 업데이트하는 것이 필요하다.
      - amplify는 appSync, dynamoDB를 제어할 수 있다. 
        - appSync
          - 리얼타임과 더불어 애플리케이션을 손쉽게 스케일업할 수 있도록 도와준다.
          - 디바이스가 오프라인일때 로컬데이터 접근을 제공한다.
          - 디바이스가 다시 온라인이 될때 시스템 충돌을 쉽게 제어하고 동기화시켜준다.
        - dynamoDB는 빠르고 예측가능한 퍼포먼스를 가지고 있으며 스케일링이 손쉽다.
    - 인증
      - cognito와 firebase authentication는 oAuth2.0, Saml2.0, openId 연결 및 sns 로그인을 지원한다.
    - 머신러닝
  - firebase
    - 장점
      - 러닝커브각 낮다.
      - 인증이나 로그인 기능을 추가하는데 걸리는 시간이 짧다.
      - amplify보다 기능이 더 많다.
      - 소/중 사이즈의 프로젝트에 적합한 선택이다.
    - 단점
      - 1m/s 이상의 트랜젝션이 일어나는 빅데이터 프로젝트에는 적합한 선택이 아니다.
  - amplify
    - 장점
      - 다양한 클라우드 기능을 연결해 활용해 애플리케이션의 기능을 개선할 수 있다.
      - graphQl로 데이터 프로세싱을 쉽게 제어할 수 있다.
      - 가격을 저렴하게 조정 가능하다.
    - 단점
      - 러닝커브가 높다.

- push notification
  - 푸시메시지를 송수신하기 위해 사용자기기의 푸시토큰이 필요하다.
  - 보통 신규가입할 때 토큰을 db에 저장한다.
  - 토큰은 아래와 같은 경우에 변경될 수 있으므로 세밀하기 고려해야 한다.
    - firebase의 앱 인스턴스 id가 삭제될때
    - 앱이 새로운 기기에 설치될 때
    - 사용자가 앱을 지우고 다시 설치할 때
    - 사용자가 앱 데이터를 지울 때

- network
  - public/private subnet이 있는 vpc(nat)
    - backend server에 대한 공개적인 접근을 차단하면서 public web app을 실행하려는 시나리오이다.
    - 일반적으로 web server는 public subnet에 두고 db는 private subnet에 두는 다중 계층이 있다.
    - web server가 db와 통신할 수 있도록 보안/라우팅 설정을 할 수 있다.
    - public subnet의 인스턴스는 바로 outbound 트래픽을 전송할 수 있지만, private subnet의 인스턴스는 그렇게 할 수 없고 public에 있는 nat gw를 사용해 접근할 수 있다.
    - nat gw를 이용해 db를 인터넷에 연결할 수 있지만, 인터넷에서 db로 연결을 설정할 수는 없다.
    - vpc 마법사로 nat 인스턴스로 vpc를 구성할 수도 있지만 nat gw를 사용하는 것이 좋다.
    - 구성
      - vpc는 65,536개의 private ip 주소를 제공한다.
      - public subnet은 256개의 private ip 주소를 제공한다. igw로 이어지는 경로가 있는 routing table과 연결된 subnet이다.
      - private subnet은 256개의 private ip 주소를 제공한다.
      - igw는 vpc를 인터넷이나 다른 서비스에 연결한다.
      - subnet 범위에서 private ip 주소가 있는 인스턴스는 인스턴스끼리 서로 통신이 가능하고, vpc의 다른 인스턴스와 통신할 수 있다.
      - 자체적으로 elastic ip 주소를 가진 nat gw를 통해 private subnet의 인스턴스가 인터넷에 요청을 보낼 수가 있다. 예를 들어 소프트웨어 업데이트를 하는 경우가 있을 수 있다.
      - public subnet과 연결된 routing table은 subnet의 인스턴스가 vpc의 다른 인스턴스와 통신할 수 있게 해주며, nat gw를 통해 인터넷과 통신할 수 있게 해준다.
      <img src="https://docs.aws.amazon.com/ko_kr/vpc/latest/userguide/images/nat-gateway-diagram.png" width="500">
    - 라우팅
      - private subnet에 사용되는 기본 routing table을 업데이트하고 public subnet에 연결한다.
      - db는 private subnet에 들어가있으므로 elastic ip가 없어서 직접 인터넷에서 트래픽을 수신할 수가 없어서, public subnet의 nat 디바이스를 통해 인터넷과 통신할 수 있다.
  - 단일 public subnet이 있는 vpc
  - public/private subnet과 site-to-site vpn 접근을 포함하는 vpc
  - private subnet만 있고 site-to-site vpn 접근 권한이 있는 vpc

- github actions
  - workflow를 구축하기 위한 최소 단위의 블럭을 말한다.
  - artifact
    - build와 test를 수행할 때 만들어지는 파일을 말한다.
    - binary, package, test 결과, 스크린샷, 로그 파일 등이 역기 포함된다.
  - event
    - workflow 실행을 유발하는 특정 활동을 말한다.
    - dispatch webhook을 사용해 외부이벤트가 발생할 때 실행되도록 구성할 수도 있다.
  - job
    - 동일한 runner에 의해 수행되는 steps들의 집합을 말한다.
    - build job이 실패하면 test job이 실행되지 않는다.
  - step
    - commands, action을 수행하는 독립적인 작업에 해당한다.
    - 하나의 job은 1개 이상의 step들로 구성된다.
  - workflow
    - 일련의 자동화된 프로세스로 build, test, package, release, deploy 등을 설정할 수 있다.
    - 1개 이상의 job들로 구성되며, 스케쥴링되어 실행되거나 특정 이벤트에 의해 실행되게 할 수 있다.
  - workflow file
    - workflow 설정을 정의하는 yaml파일이다.
    - `./.github/workflows`에 있어야 한다.

## 03.05.2020

- fp
  - functor
    - 보통 값을 품고 있는 어떤 박스 형태로 설명할 수 있다. 
    - 값을 안전하게 사용할 수 있도록 도와주는 로직을 가지고 있을 수 있다.
    - 여러 개의 값을 처리할 수 있는 로직을 가지고 있을 수 있다.
    - 아직 값이 결정되지 않았지만 나중에 값이 결정되고나면 값을 사용할 수 있는 로직을 가지고 있을 수 있다.
    - 값을 사용할 때 도움을 주는 여러가지 로직을 담고 있을 수 있다.
    - 조건문에 따라 값을 안전하게 반환하는 어떤 함수도 일종의 박스인 functor라고 할 수 있다.
    - category를 변경하는 행위를 mapping이라고 하며, 카테고리에 함수를 적용해 다른 카테고리로 변경하는 행위라고 할 수도 있다.
    - 예시
      ```ts
      interface Functor {
        map(f: (x: T) => U): Functor<U>
      }
      ```
      - `T` 타입의 값을 가진 functor이다.
      - 콜백을 한 번 돌리면 `U` 타입의 값을 가진 새로운 functor를 얻는다.
      - `map` 메서드는 인자로 받은 함수를 functor 내부의 값에 적용하고, 변경된 값을 감싸고 있는 새로운 functor를 반환한다.
      - `map`에 인자로 넘기는 이 함수가 functor 내부의 값을 변경하는 역할을 실질적으로 하며 transform 함수라고 부른다.
      - 변경된 값을 감싸고 있는 functor가 반환되는 이유는 본질적으로 구조체일 뿐, 카테고리를 부수고 내부의 대상을 꺼내는 역할을 하는게 아니기때문이다.
      - functor는 카테고리를 표현하는 수단일 뿐이라서 기존의 카테고리의 대상을 변경해서는 안된다. 
    - 종류
      - `Just`: 내부에 자신의 값을 가지고 있다.
      - `Nothing`: 이름 그대로 내부에 어떠한 값도 가지고 있지 않다.
      - `Maybe`: 값이 있다면 인자로 받은 함수를 값에 적용하고, 값이 없다면 없음을 의미하는 `Nothing` functor를 반환한다.
  - category
    - functor는 카테고리 이론에 등장하는 개념이며, 동일한 구조를 가지고 있는 카테고리들의 관계를 정의할 수 있는 구조체라고 할 수 있다.
      