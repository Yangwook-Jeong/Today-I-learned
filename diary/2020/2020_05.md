## 02.05.2020

- cidr: Classless Inter-Domain Routing
  - subnetmask로도 ip 할당 범위를 지정할 수 있지만 그것보다 더 가독성이 좋은 방식이다.
  - 여러 ip가 모인 그룹이라고 할 수 있다. 
  - cidr 블락을 여러개의 네트워크로 나누는 것을 subnetting이라고 한다.
  - 각각의 class를 2진수로 바꾸면 8비트 값이 되고, 총 32비트각 된다.
  - cidr값은 32부터 0까지 사용할 수 있다.
  - 유효한 클래스 범위는 0부터 255까지이다.
  - 예를 들어, `171.16.0.0/24`라는 ip가 있다면 `171.16.0`까지는 network prefix가 되고, `0`은 host identifier가 된다. 허용되는 ip의 범위는 `171.16.0.0`부터 `171.16.0.254`까지가 되겠다.

- dev platform for mobile/web app 
  - 비슷한 점
    - 스케일링이 되고 안전하게 모바일/웹 애플리케이션을 빌드할 수 있게 디자인된 플랫폼이다.
    - 유저 인증을 간편하게 도와주고, 데이터/사용자 메타데이터를 데이터에 선택적 접근을 허가하고, 머신러닝을 통합시켜준다.
  - 기능
    - 리얼타임 앱
      - 사용자에게 동적으로 데이터를 업데이트하는 것이 필요하다.
      - amplify는 appSync, dynamoDB를 제어할 수 있다. 
        - appSync
          - 리얼타임과 더불어 애플리케이션을 손쉽게 스케일업할 수 있도록 도와준다.
          - 디바이스가 오프라인일때 로컬데이터 접근을 제공한다.
          - 디바이스가 다시 온라인이 될때 시스템 충돌을 쉽게 제어하고 동기화시켜준다.
        - dynamoDB는 빠르고 예측가능한 퍼포먼스를 가지고 있으며 스케일링이 손쉽다.
    - 인증
      - cognito와 firebase authentication는 oAuth2.0, Saml2.0, openId 연결 및 sns 로그인을 지원한다.
    - 머신러닝
  - firebase
    - 장점
      - 러닝커브각 낮다.
      - 인증이나 로그인 기능을 추가하는데 걸리는 시간이 짧다.
      - amplify보다 기능이 더 많다.
      - 소/중 사이즈의 프로젝트에 적합한 선택이다.
    - 단점
      - 1m/s 이상의 트랜젝션이 일어나는 빅데이터 프로젝트에는 적합한 선택이 아니다.
  - amplify
    - 장점
      - 다양한 클라우드 기능을 연결해 활용해 애플리케이션의 기능을 개선할 수 있다.
      - graphQl로 데이터 프로세싱을 쉽게 제어할 수 있다.
      - 가격을 저렴하게 조정 가능하다.
    - 단점
      - 러닝커브가 높다.

- push notification
  - 푸시메시지를 송수신하기 위해 사용자기기의 푸시토큰이 필요하다.
  - 보통 신규가입할 때 토큰을 db에 저장한다.
  - 토큰은 아래와 같은 경우에 변경될 수 있으므로 세밀하기 고려해야 한다.
    - firebase의 앱 인스턴스 id가 삭제될때
    - 앱이 새로운 기기에 설치될 때
    - 사용자가 앱을 지우고 다시 설치할 때
    - 사용자가 앱 데이터를 지울 때

- network
  - public/private subnet이 있는 vpc(nat)
    - backend server에 대한 공개적인 접근을 차단하면서 public web app을 실행하려는 시나리오이다.
    - 일반적으로 web server는 public subnet에 두고 db는 private subnet에 두는 다중 계층이 있다.
    - web server가 db와 통신할 수 있도록 보안/라우팅 설정을 할 수 있다.
    - public subnet의 인스턴스는 바로 outbound 트래픽을 전송할 수 있지만, private subnet의 인스턴스는 그렇게 할 수 없고 public에 있는 nat gw를 사용해 접근할 수 있다.
    - nat gw를 이용해 db를 인터넷에 연결할 수 있지만, 인터넷에서 db로 연결을 설정할 수는 없다.
    - vpc 마법사로 nat 인스턴스로 vpc를 구성할 수도 있지만 nat gw를 사용하는 것이 좋다.
    - 구성
      - vpc는 65,536개의 private ip 주소를 제공한다.
      - public subnet은 256개의 private ip 주소를 제공한다. igw로 이어지는 경로가 있는 routing table과 연결된 subnet이다.
      - private subnet은 256개의 private ip 주소를 제공한다.
      - igw는 vpc를 인터넷이나 다른 서비스에 연결한다.
      - subnet 범위에서 private ip 주소가 있는 인스턴스는 인스턴스끼리 서로 통신이 가능하고, vpc의 다른 인스턴스와 통신할 수 있다.
      - 자체적으로 elastic ip 주소를 가진 nat gw를 통해 private subnet의 인스턴스가 인터넷에 요청을 보낼 수가 있다. 예를 들어 소프트웨어 업데이트를 하는 경우가 있을 수 있다.
      - public subnet과 연결된 routing table은 subnet의 인스턴스가 vpc의 다른 인스턴스와 통신할 수 있게 해주며, nat gw를 통해 인터넷과 통신할 수 있게 해준다.
      <img src="https://docs.aws.amazon.com/ko_kr/vpc/latest/userguide/images/nat-gateway-diagram.png" width="500">
    - 라우팅
      - private subnet에 사용되는 기본 routing table을 업데이트하고 public subnet에 연결한다.
      - db는 private subnet에 들어가있으므로 elastic ip가 없어서 직접 인터넷에서 트래픽을 수신할 수가 없어서, public subnet의 nat 디바이스를 통해 인터넷과 통신할 수 있다.
  - 단일 public subnet이 있는 vpc
  - public/private subnet과 site-to-site vpn 접근을 포함하는 vpc
  - private subnet만 있고 site-to-site vpn 접근 권한이 있는 vpc

- github actions
  - workflow를 구축하기 위한 최소 단위의 블럭을 말한다.
  - artifact
    - build와 test를 수행할 때 만들어지는 파일을 말한다.
    - binary, package, test 결과, 스크린샷, 로그 파일 등이 역기 포함된다.
  - event
    - workflow 실행을 유발하는 특정 활동을 말한다.
    - dispatch webhook을 사용해 외부이벤트가 발생할 때 실행되도록 구성할 수도 있다.
  - job
    - 동일한 runner에 의해 수행되는 steps들의 집합을 말한다.
    - build job이 실패하면 test job이 실행되지 않는다.
  - step
    - commands, action을 수행하는 독립적인 작업에 해당한다.
    - 하나의 job은 1개 이상의 step들로 구성된다.
  - workflow
    - 일련의 자동화된 프로세스로 build, test, package, release, deploy 등을 설정할 수 있다.
    - 1개 이상의 job들로 구성되며, 스케쥴링되어 실행되거나 특정 이벤트에 의해 실행되게 할 수 있다.
  - workflow file
    - workflow 설정을 정의하는 yaml파일이다.
    - `./.github/workflows`에 있어야 한다.

## 03.05.2020

- fp
  - functor
    - 보통 값을 품고 있는 어떤 박스 형태로 설명할 수 있다. 
    - 값을 안전하게 사용할 수 있도록 도와주는 로직을 가지고 있을 수 있다.
    - 여러 개의 값을 처리할 수 있는 로직을 가지고 있을 수 있다.
    - 아직 값이 결정되지 않았지만 나중에 값이 결정되고나면 값을 사용할 수 있는 로직을 가지고 있을 수 있다.
    - 값을 사용할 때 도움을 주는 여러가지 로직을 담고 있을 수 있다.
    - 조건문에 따라 값을 안전하게 반환하는 어떤 함수도 일종의 박스인 functor라고 할 수 있다.
    - category를 변경하는 행위를 mapping이라고 하며, 카테고리에 함수를 적용해 다른 카테고리로 변경하는 행위라고 할 수도 있다.
    - applicative functor나 monad는 functor로도 해결하지 못하는 예외 상황들까지 커버할 수 있는 더 추상적이고 강력하게 만든 functor락고 할 수 있다.
    - 예시
      ```ts
      interface Functor {
        map(f: (x: T) => U): Functor<U>
      }
      ```
      - `T` 타입의 값을 가진 functor이다.
      - 콜백을 한 번 돌리면 `U` 타입의 값을 가진 새로운 functor를 얻는다.
      - `map` 메서드는 인자로 받은 함수를 functor 내부의 값에 적용하고, 변경된 값을 감싸고 있는 새로운 functor를 반환한다.
      - `map`에 인자로 넘기는 이 함수가 functor 내부의 값을 변경하는 역할을 실질적으로 하며 transform 함수라고 부른다.
      - 변경된 값을 감싸고 있는 functor가 반환되는 이유는 본질적으로 구조체일 뿐, 카테고리를 부수고 내부의 대상을 꺼내는 역할을 하는게 아니기때문이다.
      - functor는 카테고리를 표현하는 수단일 뿐이라서 기존의 카테고리의 대상을 변경해서는 안된다. 
    - 종류
      - `Just`: 내부에 자신의 값을 가지고 있다.
      - `Nothing`: 이름 그대로 내부에 어떠한 값도 가지고 있지 않다.
      - `Maybe`: 값이 있다면 인자로 받은 함수를 값에 적용하고, 값이 없다면 없음을 의미하는 `Nothing` functor를 반환한다.
  - category
    - functor는 카테고리 이론에 등장하는 개념이며, 동일한 구조를 가지고 있는 카테고리들의 관계를 정의할 수 있는 구조체라고 할 수 있다.
      
- fp
  - functor를 사용해 함수를 합성하기 시작했다면 합성이 끝날 때까지 계속 functor를 사용해야 한다. 
  - 애초에 functor를 사용하는 이유는 함수를 합성하는동안 타입 안정성을 유지하고 사이드이펙트를 관리하기 위해서이다. 
  - 이 과정에서 functor가 아닌 값이 하나라도 끼어들면 합성한 연산 전체의 안정성을 보장할 수가 없다.
  - 그래서 불변성을 지키면서 배열 내부의 값을 변경하기 위해 무조건 `map` 메서드를 사용해야 한다.
  - `Just`: 원래 가지고 있던 `T` 타입의 값을 `U` 타입의 값으로 변경하고, 이 값을 다시 새로운 `Just` functor에 감싸서 반환하는 것을 의미한다.
    ```ts
    class Just implements Functor {
      value: T
      constructor (value: T) {
        this.value = value
      }
      map (f: (x: T) => U) {
        return new Just<U>(f(this.value))
      }
    }

    const res = new Just(3)
      .map(v => v + 1000)
      .map(v => v.toString)
      .map(v => v.length) // Just { value: 4 }
    ```
  - `Nothing`
    ```ts
    class Nothing implements Functor<null> {
      map () {
        return new Nothing()
      }
    }

    const res = new Nothing().map().map() // Nothing {}
    ```
  - `Maybe`: 중간에 `null`, `undefined`가 반환되어 함수의 합성이 깨지는 걱정 없이 안심하고 합성할 수 있게 도와준다.
    ```ts
    class Maybe implements Functor {
      value: Just | Nothing
      constructor (value?: T) {
        if (value) {
          this.value = new Just(value)
        } else {
          this.value = new Nothing()
        }
      }
      map (f: (x: T | null) => U) {
        if (this.value instanceof Just) {
          return this.value.map<U>(f)
        } else {
          return new Nothing()
        }
      }
    }

    const getFirstLetter = s => s[0]
    const getStringLength = s => s.length

    const foo = new Maybe('hi')
      .map(getFirstLetter)
      .map(getStringLength) // Just { value: 1 }

    const bar = new Maybe('')
      .map(getFirstLetter)
      .map(getStringLength) // Nothing {}
    ```

## 04.05.2020

- collaboration
  - code convention
    - `husky`, `prettier`를 통해 `pre-commit` 시점에 eslint에 정의한 포맷으로 리포맷 하는 것을 추천한다.
    - 컨벤션을 강제하면 최종적으로 원격저장소에서 깔끔한 코드베이스를 유지할 수 있다.
    - ide에 따라 `onSave`에 따라 코드포맷을 재정의할 수도 있지만 다른 개발자가 같은 설정을 해주지 않는다면 흐지부지 끝날 수도 있다.
    - husky가 기존 git hook을 덮어쓰기때문에 설정 전에 저장소를 초기화해야한다.
    - husky가 pre-commit 시점에 해당 확장자를 가진 파일들을 재정의하는 `lint-staged`를 실행한다.
      ```json
      "husky": {
        "hooks": {
          "pre-commit": "lint-staged"
        }
      },

      // example 1
      "lint-staged": {
        "*.{js, ts, json}": [
          "prettier --ignore-path ./.prettierignore --write"
        ]
      }

      // example 2
      "lint-staged": {
        "*.{js, ts}": [
          "npm run lint:eslint:fix",
          "git add --force" 
        ],
        "*.json": [
          "prettier --write",
          "git add --force"
        ]
      }
      ```
  - commit message convention
    - `config-conventional`을 통해 커밋로그를 강제할 수가 있다.
      ```sh
      yarn add -D @commitlint/cli @commitlint/config-conventional
      ```
    - 아래와 같은 형태로 커밋을 해야한다.
      ```sh
      <type>[optional scope]: <description>
      # Examples
      feat: add hat wobble
      ^--^  ^------------^
      |     |
      |     +-> Summary in present tense.
      |
      +-------> Type: chore, docs, feat, fix, refactor, style, or test.
      ```
    - 아래와 같이 타입을 사용하면 추후에 릴리즈할 때 자동으로 해당하는 버전이 올라간다.
      - feat(minor): 이용자 단에 새로운 기능 추가 및 하위호환 api 변경
      - fix(patch): 버그 수정 및 api 변경사항 없이 내부 수정
      - breaking(major): api의 큰 변경
      - docs: 문서 추가 및 수정
      - style: 세미콜론 추가 등 포맷 수정
      - refactor: 리팩토링 코드, 변수명 변경
      - test: 테스트 코드 추가 및 수정
      - chore: 그 외 자잘한 수정 사항들
    - 조금 더 자세히 관리하고싶다면 `.commitlintrc.json`으로 관리할 수 있다.
    - husky를 통해 commit-msg 시점에 린트 검사가 가능하다.
  - changelog automation
    - 정규화된 커밋메시지를 토대로 `standard-version`으로 버저닝과 `CHANGELOG.md`를 자동으로 생성할 수 있다.
    - 기본적인 원리는 커밋로그를 뒤져 `package.json`에 새로운 버전을 명시하고 `CHANGELOG.md`에 해당 내용을 추가하는 방식이다.
    - 아래처럼 스크립트를 추가한다.
      ```json
      {
        "scripts": {
          "release": "standard-version"
        }
      }
      ```
  - break point instead of console.log
    - 이를 통해 콜스택과 같은 상세정보를 확인할 수 있기에 순전히 디버깅용으로 `console.log`를 사용하던 사람들에게는 큰 도움이 된다.
    - 코드를 실행할 때 `--inspect` 옵션을 사용해 실행하면 처음부터 디버깅할 때 유용하다.
  - test
    - e2e, 스트레스 테스트는 선택사항이라 하더라도 유닛테스트만은 진행하는 것을 추천한다.
    - tdd와 같은 방법론으로 테스트 케이스 작성을 강제하는 것도 좋다.
    - `jest`를 사용한다면 `converageThreshold`와 같은 옵션으로 커버리지 퍼센티지를 강제해 푸시를 막을 수도 있다.
  - review
    - 코드를 작성한이를 추궁하고 책임을 묻는 시간으로서가 아닌 내용을 점검하고 피드백을 주고받아 잠재적 결함을 찾는 시간이다.
    - 시간이 아깝다고 생각하지 않고 초반에 코드 품질이 좋아지면 장기적으로 생산성이 향상되고 배포속도가 빨라진다.

## 05.05.2020

- fp
  - Either
    - 에러 처리시에 참조할 값을 들고 있는 functor이다.
    - `Left`일 때는 에러 처리에 필요한 값을 가지고, `Right`일 때는 Maybe의 `Just`와 마찬가지로 정상적인 처리를 한다.
    ```ts
    class Either<T> implements Functor<T> {
      value: T
      constructor(value: T) {
        this.value = value
      }
      static Left<T>(value: T) {
        return new Left(value)
      }
      static Right<T>(value: T) {
        return new Right(value)
      }
    }
    ```
    - Left
      ```ts
      class Left<T> extends Either<T> {
        get isRight() {
          return false
        }
        get isLeft() {
          return true
        }
        map(): any {
          return this
        }
      }
      ```
    - Right
      ```ts
      class Right<T> extends Either<T> {
        get isRight() {
          return true
        }
        get isLeft() {
          return false
        }
        map<U>(f: (x: T) => U) {
          return new Right<U>(f(this.value))
        }
      }
      ```
  - IO
  - Future
  - monad chaining
  - applicative functor
  - traversable