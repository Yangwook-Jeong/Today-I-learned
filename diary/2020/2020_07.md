## 01.07.2020

- iot
	- class
		- a: 지연과 제약 없이 에너지를 효율적으로 사용하는 클래스이다. 
		- b: 다운링크 중에 생기는 지연을 제어하는 에너지를 효율적으로 사용하는 클래스이다. 네트워크 비콘과 직렬통신을 한다.
		- c: 지속적으로 리스닝할 여유가 있는 디바이스이다. 다운링크 통신에 지연이 없다. 위 a, b 클래스와는 다르게 전원을 외부에서 공급받는다.
	- network
		- home: 디바이스가 로컬 릴레이로 집집마다 필요하고 집에서 바로 서버로 데이터가 업링크된다. wifi, bluetooth에 사용하기 좋다. 
		- meshed: 디바이스가 릴레이로 확장해 사용한다. 전력소모가 많고 배터리타임이 짧다. zigbee, z-wave에 사용하기 좋다.
		- star: 디바이스가 1개 혹은 그 이상의 기지국과  장거리 통신을 할 수 있다. 전력소모가 적고 배터리타임이 길다. lora, unb에 사용하기 좋다.
	- architecture: 
		- base station (gateway): 크고 작은 게이트웨이들은 먼저 일반적인 api를 사용하는 lpwan에 먼저 통합되어있다. 적절한 위치에 적절한 활용을 하기 위해 데이터를 보낸다. 게이트웨이 앞뒤로 데이터 통신하는 것을 도와준다. 
			- macro-gateway: 퍼블릭 네트워크에서 보통 넓은 커버리지를 갖기 위해 쓰인다.
			- pico-gateway: 밀집한 지역에서 네트워크를 넓히기 위해 쓰인다. qos를 개선할 수 있고 닿기 힘든 지역이나 고립된 지역에 사용하기 좋다.
		- core network server (lrc): 맥계층을 가상화해서 컨트롤한다. 
		- sensor: iot 디바이스의 프론트-엔드 형태이다. 시스템 상에서 thing이라고 불린다. 주된 용도는 주위에서 데이터를 얻고 액추에이터로 데이터를 전송한다. 유니크한 ip를 가지고 있기때문에 대형 네트워크 안에서도 디바이스 별 정보를 정확히 알 수 있다. 
		- processor: 주된 기능은 센서에서 가져온 데이터를 처리하는 역할이며 로-데이터에서 유의미한 데이터를 추출한다. 리얼-타임 기반으로 작동하며 애플리케이션에 의해 움직인다. 데이터를 안전하게 만들 책임이 있다. 
		- application: iot 시스템의 또 다른 엔드이다. 

## 02.07.2020

- technical-debt-analysis-point
	- 너무 많은 인자로 정의된 메서드나 함수가 있다.
	- 이해하기 힘든 불리언 로직이 있다.
	- 한 파일에 과도란 라인의 코드가 있다.
	- 형식이 다를 수 있으나 구문적으로 동일한 중복코드가 있다.
	- 많은 수의 함수나 메서드로 정의된 클래스가 있다.
	- 단일 함수나 메서드 내에 코드가 지나치게 많다.
	- 제어문이 중첩된 구조로 있다.
	- 많은 수의 return 문을 사용하는 함수나 메서드가 있다.
	- 동일한 변수를 다루지만 동일한 구조를 공유하는 중복코드가 있다.
	- 이해하기 어려울 수 있는 함수나 메서드가 있다.

- refactoring
	- 미사용 코드를 삭제한다.
	- 외부 라이브러리에 결합도가 높은 코드들을 정리한다.
	- 단방향 데이터 흐름을 만든다. 
	- 역할이 2개 이상 정의된 파일들을 정리한다.
	- 라인의 길이가 긴 메서드를 정리한다. 긴 메서드는 일반적으로 행위가 두 개 이상이 정의되었을 가능성이 높다. 메서드 추출, 내용 직접 삽입, 알고리즘 전환 등을 사용해 해결한다.

- rest-api
	- rule
		- url 마지막에 `/`를 포함하지 않는다.
		- `_` 대신 `-`를 사용한다. `-`의 사용도 최소한으로 설계한다. 정확한 의미나 표현을 위해 단어의 결합이 불가피한 경우 사용한다.
		- 소문자를 사용한다.
		- 동사형의 사용은 반드시 피한다.
		- 함수처럼 컨트롤 리소스를 나타내는 url은 동작을 포함하는 이름을 짓는다.
	- header
		- `content-location`: post 요청은 반환되는 응답 결과가 항상 동일하지 않다. 따라서 새로 생성된 리소스를 식별할 수 있도록 이 헤더를 이용한다.
		- `content-type`: `application/json`을 우선으로 제공한다. 
		- `retry-after`: 비정상적인 방법으로 api를 이용할 경우 429 코드와 함께 일정 시간 뒤에 요청할 것을 나타낸다.
		- `link`: 페이징 처리를 위해 사용한다.
	- method
		- options: 현재 엔드포인트가 제공가능한 api 메서드를 응답한다.
		- head: 요청에 대한 헤더 정보만 응답한다. 바디가 없다.
		- patch: put 대신 사용한다. 자원의 일부를 수정할 때는 patch가 목적에 맞는 메서드이다.
		- put: 요청을 일부분만 보낸 경우 나머지는 default로 수정되는게 원칙이다.

- javascript
	- object
		- mapValues
			```js
			const mapValues = (f, obj) => Object
				.entries(obj)
				.map(([k, v]) => ({ [k]: f(v) }))
				.reduce((acc, obj) => Object.assign(acc, obj))

			const obj = {a: 1, b: 2, c: 3}
			mapValues(n => n + 10, obj)
			// {a: 11, b: 12, c: 13}
			```
		- mapKeys
			```js
			const mapKeys = (f, obj) => Object
				.entries(obj)
				.map(([k, v]) => ({ [f(k)]: v }))
				.reduce((acc, obj) => Object.assign(acc, obj))

			const obj = {a: 1, b: 2, c: 3}
			mapKeys(n => n.repeat(2), obj)
			// {aa: 1, bb: 2, cc: 3}
			```
		- filterObject
			```js
			const filterObject = (f, obj) => Object
				.entries(obj)
				.filter(([_, v]) => f(v))
				.map(([k, v]) => ({ [k]: v }))
				.reduce((acc, obj) => Object.assign(acc, obj))

			const obj = {a: {age: 10}, b: {age: 15}, c: {age: 20}}
			filterObject(({ age }) => age < 20, obj)
			// {a: {age: 10}, b: {age: 15}}
			```
		- pick
			```js
			const pick = (keys, obj) => keys
				.map(key => ({ [key]: obj[key] }))
				.reduce((acc, obj) => Object.assign(acc, obj))

			const obj = {a: 1, b: 2, c: 3}
			pick(['a', 'b'], obj)
			// {a: 1, b: 2}
			```
		- fromEntries
			```js
			const fromEntries = arr => arr
				.map(([k, v]) => ({ [k]: v }))
				.reduce((acc, obj) => Object.assign(acc, obj))
			
			const fromEntries = arr => arr
				.reduce((obj, [k, v]) => Object.assign(obj, {[k]: v}), {})

			const arr = [['a', 1], ['b', 2], ['c', 3]]
			fromEntries(arr)
			// {a: 1, b: 2, c: 3}
			```
		- clone: `JSON.parse()`, `JSON.stringify()`를 사용하면 깊은복사를 할 수 있다.
			```js
			const clone = obj => JSON.parse(JSON.stiringify(obj))

			const a = {}
			const b = a
			const c = clone(a)

			console.log(a === b) // true
			console.log(a === c) // false
			```

## 03.07.2020

- javascript
  - array
    - range
      ```js
			const range = length => Array.from({length}, (_, i) => i)

			range(5) // [1, 2, 3, 4, 5]
			```
    - takeWhile
      ```js
			const takeWhile = (f, arr) => {
				const newArr = []
				arr.some((val, ...args) => {
					const result = !f(val, ...args)
					result || newArr.push(val)
					return result
				})
				return newArr
			}

			takeWhile(a => a, [1, 2, 3, 0, 4, 5])
			// [1, 2, 3]
			```
    - takeUntil
			```js
			const takeUntil = (f, arr) => {
				const newArr = []
				arr.some((val, ...args) => {
					newArr.push(val)
					return f(val, ...args)
				})
				return newArr
			}

			takeUntil(a => a, [0, false, undefined, null, 1, 2, 3])
			// [0, false, undefined, null, 1]
			```

- grasp
  - information expert
    - 책임을 수행할 수 있는 데이터를 가지고 있는 객체에 책임을 부여해야 한다.
    - 객체는 데이터와 처리로직이 함께 묶여있어야 한다.
    - 정보은닉을 통해 자신ㄴ의 데이터를 감추고 오직 메서드로만 데이터를 처리하고 외부에는 기능만 제공한다.
  - creator
    - 객체의 생성은 생성되는 객체의 컨텍스트를 알고 있는 다른 객체가 있다면 그 객체에 부여한다.
    - A객체와 B객체의 관계가 다음 중 하나라면 A의 생성을 B의 책임으로 부여해야 한다.
      - B가 A를 포함하고 있다.
      - B가 A의 정보를 기록하고 있다.
      - A가 B의 일부이다.
      - B가 A를 긴밀하게 사용하고 있다.
      - B가 A의 생성에 필요한 정보를 가지고 있다.
  - controller
    - 시스템 이벤트(사용자의 요청)을 처리할 객체를 만들어야 한다.
    - 어떤 서브시스템에 있는 각 객체의 기능을 직접 사용한다면 아래와 같은 결과를 낳는다.
      - 서브시스템과 외부간의 커플링이 증가한다.
      - 서브시스템의 어떤 객체를 수정할 경우 외부에 주는 충격이 커진다.
      - 서브시스템을 사용하는 입장에서는 controller 객체만 알고있으면 되므로 사용이 쉽다.
  - low coupling
    - 객체간 서브시스템간의 상호의존도를 낮게 책임을 부여한다.
    - 객체, 서브시스템의 재사용성으 높이고 시스템 관리에 편하게 한다.
    - 객체간의 통신을 통해 비즈니스를 완성시킨다.
  - high cohesion
    - 객체간에 밀접하게 연관된 책임들만 가지도록 구성한다.
    - 한 객체, 한 시스템이 자기 자신이 부여받은 책임만을 수행하도록 짜임새있게 구성한다면 책임을 충족하기 위해 다른 객체나 시스템을 참조하는 일이 적어져 자연스럽게 low coupling이 된다.
  - polymorphism
    - 객체의 종류에 따라 행동양식이 바뀐경우 hoc 형태로 사용한다.
    - 객체의 종류에 따라 행동이 바뀐다면 객체의 종류를 체크하는 조건문을 사용하지 않아야한다.
  - pure fabrication
    - 도메인에 관련된 문제를 대표하는 것이 아니라면 기능적인 책임을 별도로 한 곳에서 관리하는 객체를 만들어야 한다.
  - indirection
    - 두 객체 사잉의 직접적인 커플링을 피하고 싶으면 그 사이 다른 매개체를 통해 전달해야 한다.
    - 매개체는 인터페이스인 경우가 많다.
  - protected variation
    - 변경될 여지가 있는 곳에 안정된 인터페이스를 정의해서 사용해야 한다.

## 04.07.2020

- ddd
	- feature
  	- 도메인 그 자체와 도메인 로지겡 초점을 맞춘다. 일반적인 데이터중심의 접근법에서 탈피해 순수한 도메인의 모델과 로직에 집중한다.
  	- 보편적인 언어의 사용이다. 도메인 전문가와 소프트웨어 개발자간의 커뮤니케이션 문제를 없애고 상호가 이해할 수 있고 모든 문서와 코드에 이르기까지 동일한 표현과 단어로 단일화한 언어체계를 구축해나가는 과정을 말한다. 분석작업과 설계, 그리고 구현에 이르기까지 통일된 방식으로 커뮤니케이션이 가능하다.
  	- 소프트웨어 엔티티와 도메인 컨셉을 가능한 가장 가까이 일치시키는 것이다. 분석모델과 설계가 다르지 않고 도메인모델부터 코드까지 항상 함께 움직이는 구조를 지향한다.
		- 현실적으로 의존성을 최소화하고 이를 위해 좋은 도구를 사용하더라도 소프트웨어가 커질수록 그 구현이 복잡해지는 sp가 가진 한계를 극복할 수 있다.

- fp
  - 자바스크립트는 너무나 자유롭게 객체의 속성을 관리할 수 있다. 자유에는 책임이 수반되므로 관리가 어려워지지 않게 데이터를 보호하는 훈련이 필요하다.
  - 객체의 불변상태를 한 곳에서 관리하는 렌즈라는 기법을 사용해야한다.
  - 함수형을 표기할때는 `functionName :: inputs => output`과 같은 하스켈 표기법을 자주 사용한다.
  - 파이프라인 배열로 하는 느슨한 결합은 유연성이 있지만 인수의 개수와 형식이 호환되지 않으면 연결할 수 없으므로 주의가 필요하다.
  - `f(a, b, c)`란 함수가 있을 경우 커링한다면 `f(a) -> f(b, c)`가 될 수 있겠다.
  - identitys는 주어진 인수와 같은 값을 반환하는 `identity :: (a) => a`와 같은 함수이다. 주로 함수의 수학적 속성을 살펴보는 용도로 쓰인다.
  - tab은 코드 추가없이 void를 연결해 합성할때 유용한 `tap :: (a -> *) -> a -> a`와 같은 함수이다. 자신을 함수에 넘기고 자신을 돌려받는다.
  - alternation은 함수 호출시 기본응답을 제공하는 단순 조건 로직을 수행한다. 함수 2개를 인수로 받아 값이 있으면 첫번째 함수의 결과를 그렇지 않으면 두번째 함수를 반환한다.
  - sequence는 2개 또는 더 많은 함수를 인수로 받아 동일한 값에 대해 각 함수를 차례로 실행하는 또 다른 함수를 반환한다.
  - fork/join은 하나의 자원을 두가지 방법으로 처리한 후 그 결과를 다시 조합한다. 하나의 join 함수와 주어진 입력을 처리할때 종단함수 traverse 함수 2개를 받는다. 분기된 각 함수의 결과는 제일 마지막에 인수 2개를 받는 join 함수에 전달된다.
  - 함수형 패러다임은 다른 패러다임보다 에러처리를 깔끔하게 한다는 의견들이 있다. 프로그램 실행중 예외가 발생하거나 네트워크가 끊기는 사고로 데이터가 `null`, `undefined`가 되는 경우 모나드를 사용할 수 있다.
  - 명령형의 대부분은 `try-catch`로 에러를 처리하지만 함수형에서는 어렵다. 명령형에서 예외를 던지는 함수의 특징은 아래와 같다.
    - 예외를 던지는 행위 자체가 함수호출에서 빠져나갈 구멍을 찾는 것이므로 예측가능한 값을 지향하는 참조 투명성에 위배된다. 
    - 예기치 않게 스택이 풀리면 함수 호출 범위를 벗어나 전체 시스템에 영향을 미치는 사이드-이펙트를 일으킨다.
    - 에러를 조치하는 코드가 당초 함수를 호출한 지점과 동떨어져 있어서 비지역성 원리에 위배된다. 에러가 나면 함수는 지역 스택과 환경에서 벗어난다.
    - 함수의 단일 반환값에 신경써야할 에너지를 `catch`블록을 선언해 예외를 붙잡아 처리하는데 낭비한다.
    - 에러조건을 처리하는 블록들이 중첩된다.
  - 함수가 `null`을 반환하면 이 함수를 부른 호출자는 null 체크를 해야하는 부담이 생긴다. 따라서 모나드를 응용한 함수자로 하는 함수형 에러처리를 할 수 있다.
    - null 체크를 Maybe 모나드로 일원화해 Just, Noting 두 하위형으로 구성된 형식으로 할 수 있다.
      - `Just(value)`은 존재하는 값을 감싼 컨테이너를 나타낸다.
      - `Nothing()`은 값이 없는 컨테이너나 추가정보 없이 실패한 컨테이너를 나타낸다.
  - 모든 함수마다 모나드를 붙이긴 어렵기떄문에 lift라는 함수 승급 기법을 사용한다.
		```js
		const lift = curry((f, value) => Maybe.fromNullable(value)).map(f)
		const safeFindObject = compose(lift(console.log), findObject)
		```
		- Either로 실패를 복구할 수 있다. 절대 동시에 발생하지 않는 두 값을 논리적으로 구분한 모델이다.
  		- `Left(a)`는 에러메시지나 예외객체를 담는다.
  		- `Right(b)`는 성공한 값을 담는다.
  - 명령형 코드는 테스트가 어렵다. 함수들을 분해하기 어렵고 평가순서를 미리 정해두어야 하기때문이다. 함수형 코드는 느슨하게 입력값을 결합하는 함수를 독립적으로 작성한다. 이런 함수는 사이드-이페트가 없고 참조 투명하므로 임의로 순서를 몇 번이고 실행하더라도 결과가 동일하고 예측가능하다.

- array
  - 아이템들의 컬렉션이며 순서가 있다.
  - 배열이 생성될때 항상 크기가 주어진다. 즉 배열이 담을 수 있는 아이템들만큼의 메모리가 할당된다.
  - 배열의 모든 아이템들이 똑같은 사이즐르 가진다.
  - 배열에 어떠한 아이템의 메모리 위치도 쉽게 계산할 수 있으므로 아이템에 인덱스를 할당할 수 있고 인덱스를 활용해 직접적으로 아이템에 접근할 수 있다.
- list
  - 메모리 주소가 연속적일 수도 있고 아닐 수도 있다.
  - 하나의 아이템이 다음 아이템을 포인팅하는 linked list가 있다. 하지만 각 아이템은 메모리 상에 모두 흩어져있을 수도 있다.
  - 이 경우는 1번째 아이템의 주소를 알더라도 다음 아이템의 메모리 주소를 간단히 계산할 수 없다는 것을 의미한다. 
  - 따라서 인덱스를 사용할 수 없다는 의미이다.

## 05.07.2020

- fp
  - 자바스크립트는 조급한 평가를 하기때문에 함수형 언어의 느긋한 평가를 흉내내서 최적화할 수 있다. 
  - 리액티브 프로그래밍과 유사한 점이 많아 함수형 프라미스를 같이 사용할 수 있다.

- css-flex
  - 속성
    - `flex-direction`: 아이템이 배치되는 축의 방향을 결정한다.
      - row
      - column
      - row-reverse
      - column-reverse
    - `flex-wrap`: 컨테이너가 더 이상 아이템을 담을 여유공간이 없을때 줄바꿈을 어떻게할지 결정하는 속성이다.
      - nowrap: 기본값으로 줄바꿈이 되지 않고 그냥 삐져나온다.
      - wrap: 줄바꿈을 한다.
      - wrap-reverse: 줄바꿈을 역으로 한다.
    - `flex-flow`: `flex-direction`, `flex-wrap`을 동시에 지정할 수 있다.
    - `flex-basis`: flex 아이템의 기본 크기를 설정한다. flex-direction이 row일 때는 너비, column일 때는 높이를 지정할 수 있다.
    - `flex-grow`: 아이템이 `flex-basis`의 값보다 커질 수 있는지 결정하는 속성이다. 기본값은 0으로 0보다 큰 값을 세팅하면 해당 아이템이 유연한 박스로 변하고 원래의 크기보다 커지며 빈공간을 메우게 된다. `flex-basis`인 공간을 제외한 나머지 공간들의 비율을 지정할 수 있다.
			![](https://media.vlpt.us/images/dbgnlcks34/post/aab5c525-5ed2-4411-8f69-4ab139a9fefc/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-06-27%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.39.34.png)
    - `flex-shrink`: `flex-grow`와 쌍을 이루는 속성으로 아이템이 `flex-basis`보다 작아질 수 있는지를 결정한다. 기본값이 1로 0으로 지정하면 같이 설정한 width에 따라 화면 폭이 바뀌어도 아이템이 찌그러지지 않는다.
  - 정렬
    - `justify-content` (메인축)
      - flex-start: 기본값으로 아이템을 시작점으로 정렬한다. `flex-direction`이 row이면 왼쪽, column이면 위쪽이다.
      - flex-end: 아이템을 끝점으로 정렬한다. `flex-direction`이 row이면 오른쪽, column이면 아래이다.
      - center
      - space-between: 아이템들 사이에 균일한 간격을 만들어준다.
      - space-around: 아이템들의 둘레에 균일한 간격을 만들어준다.
      - space-evenly: 아이템들의 사이와 양 끝에 균일한 간격을 만들어준다.
    - `align-items` (수직축)
      - stretch: 기본값으로 아이템들이 수직축 방향으로 끝까지 늘어난다.
      - flex-start: 아이템들을 시작점으로 정렬한다. `flex-direction`이 row이면 위쪽으로 column이면 왼쪽으로 정렬한다.
      - flex-end: 아이템들을 끝으로 정렬한다.
      - center
      - baseline: 아이템들을 텍스트 베이스라인 기준으로 정렬한다.
    - `align-content` `flex-wrap`이 기본값인 상태에서 아이템들의 행이 2줄 이상 된 경우 수직축 방향 정렬을 결정하는 속성이다. (여러행)
      - stretch: 기본값으로 줄바꿈이 된 그 상태이다.
      - flex-start
      - flex-end
      - center
      - space-between
      - space-around
      - space-evenly

## 06.07.2020

- javascript
	- array
		- all: 함수의 모든 요소가 true이면 true를, 그렇지 않으면 false를 반환한다. `every()`를 이용한다.
			```js
			const all = (arr, fn) => arr.every(fn)

			all([1, 2, 3]) // true
			all([4, 2, 3], x => x > 1) // true
			```
		- allEqual: 배열의 모든 요소가 같은지 확인한다. `every()`를 이용해 배열의 모든 요소가 첫번째 요소와 같은지 확인한다.
			```js
			const allEqual = arr => arr.every(val => val === arr[0])

			allEqual([1, 2, 3, 4, 5]) // false
			allEqual([1, 1, 1, 1]) // true
			```
		- any: 하나의 요소가 true이면 true를 반환하고 그렇지 않으면 false를 반환한다. `some()`을 사용한다.
			```js
			const any = (arr, fn) => arr.some(fn)

			any([0, 1, 2, 0], x => x >= 2) // true
			any([0, 0, 1, 0]) // true
			```
		- arrayToCSV: 2차원 배열을 csv 포맷으로 변환한다. `map()`, `join()`을 사용해 개별 1차원 배열로 결합한다. 다시 `join()`을 사용해 모든 행을 csv 포맷의 개행문자로 분리한다. 
			```js
			const arrayToCSV = (arr, delimiter = ',') => arr
				.map(v => v.map(x => `'${x}'`).join(delimiter))
				.join('\n')

			arrayToCSV([['a', 'b'], ['c', 'd']]) // "'a','b'\n'c','d'"
			arrayToCSV([['a', 'b'], ['c', 'd'], ';']) // "'a';'b'\n'c';'d'"
			```
		- bifurcate: 값을 두 그룹으로 나눈다. 필터의 요소가 truthy면 요소가 첫번쨰 그룹에 속하고 아니면 두번째 그룹에 속하게 된다. `reduce()`, `push()`를 사용하 필터기반으로 그룹에 요소를 추가한다.
			```js
			const bifurcate = (arr, filter) => arr
				.reduce((acc, val, i) => (acc[filter[i] ? 0 : 1].push(val), acc), [[], []])
			
			bifurcate(['beep', 'boop', 'foo', 'bar'], [true, true, false, true])
			// [['beep', 'boop', 'bar'], ['foo']]
			```
		- bifurcateBy: 속한 그룹을 지정하는 조건부 함수에 따라 값을 두 그룹으로 나눈다. 콜백함수가 truthy 값을 리턴하면 요소는 첫번째 그룹에 속하며 그렇지 아니면 두번째 그룹에 속한다. `reduce()`, `push()`를 사용한다.
			```js
			const bifurcateBy = (arr, fn) => arr
				.reduce((acc, val, i) => (acc[fn(val, i) ? 0 : 1].push(val), acc), [[], []])

			bifurcateBy(['beep', 'boop', 'foo', 'bar'], x => x[0] === 'b')
			// [['beep', 'boop', 'bar'], ['foo']]
			```
		- chunck: 배열을 지정된 크기의 더 작은 배열로 채운다. `from()`을 사용해 생성될 청크의 수에 맞는 새 배열을 만든다. `slice()`를 사용해 새 배열의 각 요소를 청크의 크기만큼의 길이로 매핑한다. 원래 배열을 균등하게 분할할 수 없는 경우 최종 청크에는 나머지 요소가 포함된다.
			```js
			const chunk = (arr, size) => Array
				.from({ length: Math.ceil(arr.length / size) }, (v, i) =>
					arr.slice(i * size, i * size + size)
				)

			chunck([1, 2, 3, 4, 5], 2) // [[1, 2], [3, 4], [5]]
			chunck([1, 2, 3, 4, 5], 3) // [[1, 2, 3], [4, 5]]
			```
		- compact: 배열에서 거짓인 값을 제거한다. `filter()`로 falsy한 값을 필터링한다.
			```js
			const compact = arr => arr.filter(Boolean)
			
			compact([0, 1, false, 2, '', 3, 'a', 'e' * 23, NaN, 's', 34])
			// [1, 2, 3, 'a', 's', 34]
			```
		- countOccurrences: 배열에 있는 값의 발생을 계산한다. `reduce()`로 배열 내부의 특정 값을 만날때마다 카운터를 증가시킨다.
			```js
			const countOccurrences = (arr, val) => arr
				.reduce((a, v) => v === val ? a + 1 : a, 0)

			countOccurrences([1, 1, 2, 1, 2, 3], 1) // 3
			countOccurrences([1, 1, 2, 1, 2, 3], 2) // 2
			countOccurrences([1, 1, 2, 1, 2, 3], 3) // 1
			```
		- deepFlatten: 재귀적으로 배열 끝까지 평평하게 만든다 `concat()`에 빈 배열과 스프레드 연산자를 사용한다.
  		```js
			const deepFlatten = arr => []
				.concat(...arr.map(v => (Array.isArray(v) ? deepFlatten(v) : v))
				)

			deepFlatten([1, [2], [[3], 4], 5]) // [1, 2, 3, 4, 5]
			```
		- difference: 2개의 배열의 차이를 반환한다. a에 `filter()`를 사용해 b에 포함되지 않은 값을 반환한다.
  		```js
			const difference = (a, b) => {
				const s = new Set(b)
				return a.filter(x => !s.has(x))
			}

			difference([1, 2, 3], [1, 2, 4]) // [3]
			``` 
		- drop: 왼쪽부터 n만큼 제거된 새 배열을 반환한다. `slice()`를 사용해 지정된 수만큼 slice한다.
  		```js
			const drop = (arr, n = 1) => arr.slice(n)

			drop([1, 2, 3]) // [2, 3]
			drop([1, 2, 3] 2) // [3]
			drop([1, 2, 3] 5) // []
			```
		- dropRight: 오른쪽에서 n개만큼 제거된 새 배열을 반환한다. `slice()`를 사용해 지정된 수만큼 slice한다.
  		```js
			const dropRight = (arr, n = 1) => arr.slice(0, -n)

			dropRight([1, 2, 3]) // [1, 2]
			dropRight([1, 2, 3], 2) // [1]
			dropRight([1, 2, 3], 5) // []
			```
		- dropRightWhile: 전달된 함수가 `true`를 반환할 때까지 배열의 끝에서부터 제거하고 배열의 나머지를 반환한다. `slice()`를 사용한다.
			```js
			const dropRightWhile = (arr, fn) => {
				while (arr.length > 0 && !fn(arr[arr.length - 1])) {
					arr = arr.slice(0, -1)
				}
				return arr
			}

			dropRightWhile([1, 2, 3, 4], n => n < 3) // [1, 2]
			```
		- dropWhile: 전달된 함수가 `true`를 반환할 때까지 배열의 처음부터 제거하고 배열의 나머지를 반환한다. `slice()`를 사용한다.
			```js
			const dropWhile = (arr, fn) => {
				while (arr.length > 0 && !fn(arr[0])) {
					arr = arr.slice(1)
				}
				return arr
			}

			dropWhile([1, 2, 3, 4], n => n >= 3) // [3, 4]
			```
		- everyNth: 배열의 모든 n의 배수번째 값을 반환한다. `filter()`를 사용해 새로운 배열을 만든다.
			```js
			const everyNth = (arr, nth) => arr
				.filter((e, i) => i % nth === nth - 1)

			everyNth([1, 2, 3, 4, 5, 6], 2) // [2, 4, 6]
			everyNth([1, 2, 3, 4, 5, 6], 3) // [3, 6]
			```
		- filterFalsy: 배열의 거짓된 값을 필터링한다. `filter()`를 이용해 truthy 값만 가져온다.
			```js
			const filterFalsy = arr => arr.filter(Boolean)

			filterFalsy(['', true, {}, false, 'sample', 1, 0])
			// [true, {}, 'sample', 1]
			```
		- filterNonUnique: 배열의 고유하지 않은 값을 필터링한다.
			```js
			const filterNonUnique = arr => arr
				.filter(i => arr.indexOf(i) === arr.lastIndex(i))

			filterNonUnique([1, 2, 2, 3, 4, 4, 5]) // [1, 3, 5]
			```
		- flatten: 지정된 깊이만큼 배열을 병합한다. `reduce()`, `concat()`을 사용해 값과 배열을 병합한다. 
			```js
			const flatten = (arr, length = 1) => arr
				.reduce((a, v) => a.concat(
					depth > 1 && Array.isArray(v)
						? flatten(v, depth - 1)
						: v
				), [])

			flatten([1, [2], 3, 4]) // [1, 2, 3, 4]
			flatten([1, [2, [3, [4, 5], 6], 7], 8], 2) // [1, 2, 3, [4, 5], 6, 7, 8]
			```
		- head: 첫번째 값을 반환한다.
			```js
			const head = arr => arr[0]

			head([1, 2, 3]) // 1
			head([[1, 2, 3], 4, 5]) // [1, 2, 3]
			head([{'a': 1, 'b': 2, 'c': 3}, 4, 5]) // {a: 1, b: 2, c: 3}
			```
		- last: 마지막 값을 반환한다.
			```js
			const last = arr => arr[arr.length - 1]

			last([1, 2, 3]) // 3
			last([1, 2, [3, 4, 5]]) // [3, 4, 5]
			last([1, 2, {'a': 3, 'b': 4, 'c': 5}]) // {a: 3, b: 4, c: 5}
			```
		- indexOfAll: 배열의 값 중 `val`과 일치하는 모든 값의 인덱스를 반환한다. `val`의 값이 없으면 `[]`을 반환한다. `reduce()`를 사용해 `val`과 일치하는 값을 저장, 루프를 통해 배열의 인덱스를 준다.
			```js
			const indexOfAll = (arr, val) => arr
				.reduce((acc, el, i) => el === val ? [...acc, i] : acc), [])
			
			indexOfAll([1, 2, 3, 1, 2, 3], 1) // [0, 3]
			indexOfAll([1, 2, 3], 4) // []
			```
	- utility
  	- castArray: 인자로 받은 값을 배열로 변경한다. `isArray()`를 사용해 인자로 받은 `val`을 배열에 넣는다.
			```js
			const castArray = val => Array.isArray(val) ? val : [val]

			castArray('foo') // ['foo']
			castArray([1, 2, 3, 4]) // [1, 2, 3, 4]
			```
  	- cloneRegExp: 정규식을 복제한다. `new RegExp()`를 사용해 `source()`, `flags()`로 지정된 정규표현을 복제한다.
			```js
			const cloneRegExp = regExp => new RegExp(regExp.source, regExp.flags)

			const regExp = /lorem ipsum/gi
			const regExp2 = cloneRegExp(regExp)
			// /lorem ipsum/gi
			```
  	- coalesce: `find()`로 전달받은 인자중 `null`, `undefined`가 아닌 첫번째 값을 반환한다.
			```js
			const coalesce = (...args) => args
				.find(_ => ![undefined, null].includes(_))

			coalesce(null, undefined, 'Waldo', '', NaN) // 'Waldo'
			```
  	- coalesceFactory: 전달받은 인자를 순회에 `args`로 제공한 값과 일치하는 값을 반환한다. `find()`로 전달받은 인자중 `true`와 일치하는 첫번째 값을 반환한다.
    	```js
			const coalesceFactory = valid => (...args) => args
				.find(valid)
			const customCoalesce = coalesceFactory(_ => ![null, undefined, '', NaN].includes(_))

			customCoalesce(undefined, null, NaN, '', 'Waldo') // 'Waldo'
			```
  	- extendHex: 3자리 컬러코드를 6자리 컬러코드로 확장한다. `map()`, `split()`, `join()`을 사용해 변환한다. `slice()`은 메서드 시작할때 `#`를 제거한다.
			```js
			const extendHex = shortHex => 
				'#' + 
				shortHex
					.slice(shortHex.startsWith('#') ? 1 : 0)
					.split('')
					.map(x => x + x)
					.join('')

			extendHex('#03f') // '#0033ff'
			extendHex('05a') // #0055aa'
			```
	- date
  	- dayOfYear: 새해로부터 몇번째 날인지 가져온다. `getFullYear()`를 사용해 해당 연도의 첫날의 Date객체에서 인자로 받은 date를 뺀 값을 ms로 나눠 결과를 얻는다.
			```js
			const dayOfYear = date => {
				const SECONDS_OF_DAY = 86400
				return Math.floor(date - new Date(date.getFullYear(), 0, 0) / SECONDS_OF_DAY)
			}

			dayOfYear(new Date()) // 272
			```
  	- formatDuration: 주어진 ms 숫자를 사람이 읽을 수 있는 형식으로 반환한다. `entries()`, `filter()`를 함께 사용해 0이 아닌 값을 유지한다. `map()`을 사용해 각 값에 대해 적절한 문자열이 들어가도록 한다. `join()`으로 값을 합친다.
			```js
			const formatDuration = ms => {
				if (ms < 0) {
					ms = -ms
				}
				const time = {
					day: Math.floor(ms / 86400000),
					hour: Math.floor(ms / 3600000) % 24,
					minute: Math.floor(ms / 60000) % 60,
					second: Math.floor(ms / 1000) % 60,
					millisecond: Math.floor(ms) % 1000
				}
				return Object.entries(time)
					.filter(val => val[1] !== 0)
					.map(([key, val]) => `${val} ${key}${val !== 1 ? 's' : ''}`)
			}

			fromDuration(1001) // '1 second, 1millisecond'
			fromDuration(34325055574) // '397 days, 6 hours, 44 minutes, 15 seconds, 574 milliseconds'
			```
  	- getColonTimeFromDate: Date 객체에서 `hh:mm:ss` 형식의 문자열을 반환한다. `toTimeString()`, `slice()`를 사용한다.
			```js
			const getColonTimeFromDate = date => date
				.toTimeString()
				.slice(0, 8)

			getColonTimeFromDate(new Date()) // '23:31:58'
			```
  	- getDaysDiffBetweenDates: 두 개의 날짜를 인자로 받아 첫번째로 받은 값과 두번째로 받은 값의 차이를 반환한다.
			```js
			const getDaysDiffBetweenDates = (dateInitial, dateFinal) => (dateFinal - dateInitial) / 86400 * 1000

			getDaysDiffBetweenDates(new Date('2019-02-12'), new Date('2019-02-21')) // 9
			```
  	- getMeridiemSuffixOfInteger: 숫자 정수를 받아 오전과 오후를 구분한 시간으로 반환한다. `%` 나누기 연산자로 조건부 검사를 사용한다.
			```js
			const getMeridiemSuffixOfInteger = num => {
				if (num > 24) {
					throw new Error('number is too long')
				}
				return num === 0 || num === 24
					? 12 + 'am'
					: num === 12
						? 12 + 'pm'
						: num < 12
							? (num % 12) + 'am'
							: (num % 12) + 'pm'
			}
			```
  	- isAfterDate/isBeforeDate: 두 날짜를 받아 연산자 `>`, `<`를 사용해 앞에 받은 날짜 a가 두번재 날짜 b보다 앞/뒤 날짜인지 확인한다.
			```js
			const isAfterDate = (dateA, dateB) => dateA > dateB
			isAfterDate(new Date(2019, 02, 20), new Date(2019, 02, 20))

			const isBeforeDate = (dateA, dateB) => dateA < dateB
			isBeforeDate(new Date(2019, 02, 20), new Date(2019, 02, 21))
			```
  	- isSameDate
			```js
			const isSameDate = (dateA, dateB) => dateA.toISOString() === dateB.toISOString()
			
			isSameDate(new Date(2019, 02, 17), new Date(2019, 02, 17))
			```
  	- maxDate/minDate: `Math.max.apply()`, `Math.min.apply()`을 사용해 가장 최대/최소 날짜를 찾고 `new Date()`를 사용해 Date 객체로 변환해 반환한다.
			```js
			const arr = [
				new Date(2017, 4, 13),
				new Date(2018, 2, 12),
				new Date(2016, 0, 10),
				new Date(2019, 1, 17)
			]

			const maxDate = (...dates) => new Date(Math.max.apply(null, ...dates))
			maxDate(arr) // // Sun Feb 17 2019 00:00:00 GMT+0900 (한국 표준시)
			const minDate = (...dates) => new Date(Math.min.apply(null, ...dates))
			minDate(arr); // Sat Jan 09 2016 00:00:00 GMT+0900 (한국 표준시)

			```
  	- tomorrow
    	```js
			const tomorrow = () => {
				let time = new Date()
				time.setDate(time.getDate() + 1)
				return time.toString()
			}

			tomorrow() // Mon Feb 18 2019 01:34:01 GMT+0900 (한국 표준시)
			```

## 07.07.2020

- thread
  - 소프트웨어가 실행되는 작업단위인 프로세스와 같이 쓰이는 단어로 프로세스가 실행되는 흐름의 단위를 말한다. 스레드가 모여 프로세스가 된다.
  - javascript 같은 경우에는 하나의 직렬로 처리하는 싱글스레드 방식이다. 요청이 하나가 있으면 하나를 처리할 때까지 다음 요청은 대기상태로 있는 하나씩만 실행할 수 있다는 뜻이다.

- typescript
  - class access modifier
    - public: 상속도 가능하고 외부 객체를 통해 접근도 가능하다.
			```ts
			class Base {
				public defaultAge = 30
			}

			class Member extends Base {
				age = 1

				public getAge() {
					return this.age + this.defaultAge
				}
			}

			let member = new Member()
			console.log(member.getAge()) // 31
			```
    - private: 상속도 외부객체에서의 접근도 불가능하다.
			```ts
			class Base {
				private birthYear = '1989' // Property 'birthYear' is private and only accessible within class 'Base'.
			}

			class Member extends Base {
				private age = 0
				private getBirthYear() {
					return this.birthYear
				}
			}

			let member = new Member()
			member.age() // Property 'age' is private and only accessible within class 'Member'.
			member.getAge() // Property 'getAge' is private and only accessible within class 'Member'.
			```
    - protected: public처럼 상속은 가능하지만 외부객체에서 접근이 허용되지 않는다.
			```ts
			class Base {
				protected birthYear = '1989'
			}

			class Member extends Base {
				protected getBirthYear() {
					return this.birthYear
				}
			}

			let member = new Member()
			member.getBirthYear() // Property 'getBirthYear' is protected and only accessible within class 'Member' and its subclasses.
			```

## 08.07.2020

- browser
	- multiple process architecture
		- 스레드는 프로세스 내부에 있으며 프로세스로 실행하는 프로그램의 일부를 실행한다.
		- 애플리케이션의 모든 상태가 할당된 메모리에 저장되며 애플리케이션을 닫으면 프로세스가 사라지고 운영체제가 메모리를 비운다.
		- 프로세스는 여러 작업을 수행하기 위해 운영체제에 다른 프로세스를 실행하라고 요청한다. 그러면 메모리의 다른 부분이 새 프로세스에 할당된다.
		- 두 프로세스가 서로 정보를 공유해야할 때는 ipc(Inter-Process Communication)을 사용한다.
		- 작업 프로세스가 응답하지 않을 때 애플리케이션의 다른 부분을 실행하는 프로세스를 중지하지 않고도 응답하지 않는 프로세스를 다시 시작할 수 있는 이유이다.
		- 브라우저마다 프로세스 아키텍처가 다르지만 크롬을 기준으로 설명하자면 렌더러 프로세스는 여러 개가 만들어져 각 탭마다 할당한다.
		- 최근까지 크롬은 탭마다 프로세스를 할당했지만 이제는 iframe에 있는 사이트를 포함한 사이트마다 프로세스를 할당한다.
		- 프로세스
			- 브라우저: 주소표시줄, 북마크 막대, 뒤로가기 버튼 등을 제어하며 네트워크 요청이나 파일접근 권한이 필요한 부분도 처리한다.
			- 렌더러: 탭 안에서 웹사이트가 표시되는 부분의 모든 것을 제어한다.
			- 플러그인: 웹사이트에서 사용하는 플러그인을 제어한다.
			- gpu: 여러 애플리케이션의 요청을 처리하고 같은 화면에 요청받은 내용을 그리므로 별도 프로세스로 분리되어있다.
		- 만약 모든 탭이 하나의 프로세스에서 실행중이라면 탭이 하나만 응답하지 않아도 모든 탭이 응답하지 못하게 된다.
		- 이처럼 여러 프로세스에 나눠서 처리하는 방법은 보안과 샌드박스화할 수 있다는 것이다. 운영체제를 통해 프로세스의 권한을 제한할 수 있어 브라우저는 특정 프로세스가 특정 기능을 사용할 수 없게 제한할 수 있다.
		- 프로세스는 전용 메모리공간을 사용하므로 공통부분을 복사해 가지고 있는 경우가 많다. 따라서 동일한 프로세스가 메모리를 공유할 수 있는데 반해 서로 다른 프로세스는 메모리를 공유할 수 없어 메모리 사용량이 많이질 수밖에 없다.
		- 크롬은 메모리를 절약하기 위해 실행할 수 있는 프로세스 개수를 제한한다.
		- 크롬은 브라우저의 각 부분을 서비스로 실행해 여러 프로세스로 쉽게 분할하거나 하나의 프로세스로 통합할 수 있도록 아키텍처를 변경하고 있다.
		- 성능이 좋은 하드웨어에서는 각 서비스를 여러 프로세스로 분할해 안정성을 높이고, 리소스가 제한적인 장치에서는 서비스를 하나의 프로세스에서 실행해 메모리 사용량을 줄이는 것이 기본 아이디어이다.
		- 메모리 절약을 위한 방식은 안드로이드에서는 예전부터 사용하고 있는 방식이다.
		- 사이트 격리는 최근 도입된 기능으로 iframe의 사이틀르 별도의 렌더러 프로세스에서 실행하는 것이다.
		- iframe의 사이트가 같은 프로세스에서 실행된다면 서로 다른 사이트간에 메모리가 공유될 수 있다는 문제가 있었다. same origin 정책은 웹보안 모델의 핵심인데 한 사이트는 동의 없이 다른 사이트의 데이터에 접근할 수 없어야 한다. 이 정책을 우회해서 보안공격을 할 여지를 없앴다고 할 수 있다.
		- meltdown, spectre 사태로 여러 프로세스를 이용해 사이트를 격리해야 한다는 것이 더 분명해졌다.
		- 사이트 격리는 iframe이 서로 통신하는 방식을 근본적으로 바꿔야 했고 다른 프로세스에서 실행하는 iframe이 있는 웹페이지에서 개발자도구를 자연스럽게 사용하기 위해 많은 작업이 뒤에서 이루어졌다.
	
## 09.07.2020

- browser
	- navigator
		- ui 스레드는 먼저 입력되는 내용이 검색어인지 url인지 확인한다. 주소 표시줄은 검색창이기도 하다. ui 스레드는 입력되는 내용을 파싱해 검색엔진으로 이동할지 요청한 사이트로 이동할지 결정해야한다.
		- 입력된 문자열이 검색어인지 url인지 판별하는 것은 어렵기때문에 브라우저는 이를 도와줄 서버와 통신하거나 dns lookup을 실행하기도 한다.
		- enter 키를 누르면 사이트의 컨텐츠를 가져오기 위해 ui 스레드가 네트워크 호출을 시작한다. 로딩 스피너가 탭의 모서리에 표시되고 네트워크 스레드는 요청에 대한 dns lookup 및 tls 연결 설정과 같은 적절한 프로토콜을 거쳐 요청처리를 한다.
		- 응답 본문인 페이로드가 들어오기 싲가하면 네트워크 스레드는 필요에 따라 스트림의 처음 몇 바이트를 확인한다.
		- 페이로드가 어떤 형식의 데이터인지는 응답헤더의 Content-Type 헤더가 알려주지만 잘못된 정보가 있을 수 있다.
		- 이때 mime 스니핑을 실행해 데이터의 실제형식을 알아낸다. 이 작업은 까다로운 작업이다.
		- 이 단계는 safe browsing의 검사가 실행되는 단계이다. 도메인과 응답데이터가 악성사이트로 알려진 사이트와 일치한다면 네트워크 스레드는 경고 페이지를 표시하라고 알린다. 
		- 모든 검사가 끝나고 브라우저가 요청된 사이트로 이동해야 한다고 네트워크 스레드가 확신하게 되면 네트워크 스레드는 ui 스레드에 데이터가 준비되었음을 알린다. 그 다음 ui 스레드는 웹페이지의 렌더링을 수행할 렌더러 프로세스를 찾는다.
		- 내비게이션이 완료된 경우 사용자가 주소표시줄에 다른 url을 입력하면 브라우저 프로세스는 동일한 단계를 거쳐 다른 사이트로 이동을 처리한다. 그 전에 현재 렌더링된 사이트에서 `beforeunload` 이벤트를 확인해야한다. 이 이벤트는 탭을 닫거나 이동할때 경고창을 만들 수 있다.
		- 최근 서비스 워커가 도입되며 내비게이션 과정도 변화가 생겼다. 서비스 워커는 애플리케이션의 코드에 네트워크 프락시를 작성할 수 있는 수단이다. 서비스 워커를 통해 웹개발자는 무엇을 로컬 캐시에 저장할지 언제 네트워크에서 새 데이터를 가져올지 제어할 수 있다. 
  - compositor
		- 브라우저 관점에서 모든 동작들은 입력 이벤트이다. 화면 터치같은 사용자 제스처가 발생한 경우 가장 먼저 제스처를 수신하는 것은 브라우저 프로세스이다. 브라우저 프로세스는 어디에서 제스처가 발생했는지만 알고 있다. 
		- 탭 내부의 콘텐츠는 렌더러 프로세스가 처리해야 한다. 그래서 브라우저 프로세스는 이벤트 유형과 이벤트가 발생한 좌표를 렌더러 프로세스로 보낸다.
		- javascript 실행은 메인 스레드의 작업이므로 웹페이지가 합성되는 경우 컴포지터 스레드는 이벤트 핸들러가 연결된 영역을 고속스크롤 불가영역이라고 표시한다.
		- 이벤트 핸들러를 작성할때 위임 패턴을 사용한다. 이벤트 버블링때문에 하나의 이벤트 핸들러를 최상위 요소에 연결하고 이벤트 대상을 고려해 처리를 위임할 수 있다.
		- 간단하게 `e.preventDefault()`를 사용하면 핸들러를 하나만 작성하면 되므로 편해보이지만 브라우저 관점에서는 웹페이지의 모든 영역이 고속스크롤 불가영역으로 표시된다.
		- 포인터 이벤트에서 옵션으로 `{ passive: true }`를 켜면 메인스레드에서 이벤트를 받지만 컴포지터가 메인스레드의 처리를 기다리지 않고 새 프레임을 만들어도 된다는 힌트를 브라우저에 준다. 따라서 스크롤 이동도 부드럽게 할 수 있다.
		- 어떤 박스의 스크롤 방향을 가로로만 제한하고 싶은 경우에는 `e.cancelable()` 메서드를 사용하면 수직 스크롤 시작여부를 확인해 처리할 수 있다.
		- `touch-action`과 같은 css 규칙을 사용해 이벤트 핸들러를 아예 쓰지 않을 수도 있다.
		- 메인스레드로 이벤트를 전송하는 것을 최소화하는 것이 중요하다. 메인 스레드 호출이 과도해지는 것을 막기 위해 크롬은 연속적인 `wheel`, `mousewheel`, `mousemove`, `pointermove`, `touchmove`를 합쳐서 다음번 `requestAnimationFrame()` 메서드 실행 직전까지 전송하지 않고 기다린다.
		- `keydown`, `keyup`, `mouseup`, `mousedown`, `touchstart`, `touchend`와 같은 비연속적인 이벤트는 즉시 전달된다.
		- 한 프레임 안에서 합쳐진 이벤트를 얻으려면 `getCoalescedEvents()` 메서드를 사용한다.

## 10.07.2020

- data-analysis
	- 정제: 비정형 데이터를 구조화시키는 과정이다. 
		- 변환: etl
		- 교정: 결측치 변환, 이상치 삭제, 노이즈 데이터 교정을 하며 비정형 데이터를 수집할때 반드시 수행해야한다.
		- 통합: 데이터 분석이 용이하도록 기존/유사데이터를 연계, 통합한다.
	- 분석
		- 통계적 분석: 전통적인 분석 방법으로 수치형 데이터로 확률을 기반으로 어떤 현상을 추정, 예측하는 기법이다.
			- 회귀 분석
				- lasso: 예측 성능 향상을 위해 2개 이상의 변수를 동시에 선택하는 기법
				- ensemble: 고성능 모델을 만들기 위해 2개 이상의 모델을 결합하는 기법
				- support vector machine: 자료분리를 위해 초평면을 찾는 기법
			- 주성분 분석
		- 데이터 마이닝: 대용량의 데이터로부터 패턴인식, 인공지능 기법을 이용해 숨겨진 데이터간의 상호 관련성 유의미한 정보를 추출하는 기법이다. 
			- 샘플 추출: 데이터 선정시 몇 개의 레이어로 나눠 각 레이어로부터 동등하게, 비례에 따라 무작위 방법으로 선정하는 기법
			- 데이터 구성 변환: 이상치를 제거하고 데이터 표준화가 되어야하며 각 변수의 영향도를 파악해 적용 여부를 판단하는 기법
			- 분석 모형: 연속형 데이터의 독립변수와 종속변수에 따라 예측하거나 범주형 데이터의 예측 변수와 결과변수와의 관계를 찾는 기법
			- 데이터 시각화: 데이터 분석 결과를 지도 및 각종 차트를 이용해 시각적 분석기능을 제공하는 기법
				- 시간: 막대, 누적 막대, 점 그래프
				- 분포: 파이, 도넛, 트리맵, 누적 연속 그래프
				- 관계 : 스캐터플롯, 버블차트, 히스토그램
				- 비교: 히트맵, 스타차트, 평행 좌표계, 다차원 척도법
				- 공간: 지도 매핑
			- 군집화
				- k-means: 군집의 중심과 거리를 최소화하는 기법
				- hierachical: 군집을 계층 구조로 만드는 기법
				- model based: 자료를 군집화한 후 분포를 추정하는 기법
		- 텍스트 마이닝: 텍스트 기반의 데이터로부터 새로운 정보를 발견할 수 있도록 정보검색, 추출, 체계화, 분석을 모두 포함하는 문자처리 기술을 말한다.
			- 형태소 분석: 문장에 포함된 단어를 구성하는 형태소를 분리하고 형태소의 기본형 및 품사정보를 추출하는 기법
			- 개체 분석: 인명, 지명, 기관명같은 개체명을 인식해 해당 개체에 분류 태그를 부착하는 기법
			- 텍스트 분류: 텍스트 데이터의 특성을 정의해 텍스트 데이터간 유사도를 계산하고 유사한 문서끼리 분류하는 기법
			- 자동 요약: 텍스트 데이터의 활용도를 높이기 위해 텍스트 데이터의 특성을 유지하면서 길이와 복잡도를 줄이는 기법
			- 토픽 분석: 텍스트 데이터로부터 토픽을 추출하고 토픽간 연관성을 측정하여 연관성 네트워크를 구성하는 기법
			- 감성 분석: 미리 텍스트 데이터로부터 감성 표현을 분류하고 분류 기준에 따라 자동으로 분류하도록 하는 학습 기법

- edge-computing
	- 사용자나 데이터 소스의 물리적인 위치나 그 위치가 가까운 곳에서 컴퓨팅을 수행하는 것을 말한다.
	- 기업이 다수의 위치에서 공통의 리소스 풀을 사용해 데이터 연산 및 처리르 분산시킬 수 있는 방법 중 하나이다.
	- 전통적인 클라우드는 대규모 데이터 센터로 서비스를 중앙집중화하는데 초점을 맞췄지만 엣지는 소규모 컴퓨팅에 중점을 두어 네트워크 비용을 절감하고 대역폭 제한을 피하며, 전송지연과 서비스 장애를 줄이고, 민감한 데이터의 이동을 더욱 효과적으로 제어할 수 있다. 

- javascript
	- map: 키가 있는 데이터를 저장한다는 점에서 객체와 유사하다. 다만 키에 다양한 자료형을 허용한다는데서 차이가 있다.
	- set: 중복을 허용하지 않는 값을 모아놓은 특별한 컬렉션이다. 셋에 키가 없는 값이 저장된다.

## 13.07.2020

- jwt
	- features
		- 사용자가 로그인할 때 클라이언트에게 access token을 발급한다. 서버는 access token을 데이터베이스나 파일에 저장할 필요없이 메모리상에서 미리 정의된 비밀키를 이용해 비교하는 것만으로 인증처리를 하기때문에 추가적인 i/o 작업이 필요가 없다.
		- 때문에 서버는 특정 사용자의 접속을 강제로 만료시키기 어렵다. 일반적으로 클라이언트는 스스로의 저장 공간에서 토큰을 삭제하는 방법을 사용해 사용자의 접근을 막는다.
		- 짧은 만료시간을 설정한다면 기기나 access token이 탈취되더라도 빠르게 만료된다. 하지만 사용자는 자주 로그인해야한다. 한 사용자가 오랫동안 상주하는 서비스라면 갑자기 인증이 만료되어 로그인창이 뜨는 경우를 볼 수 있다.
		- 긴 만료시간을 설정한다면 사용자가 자주 로그인할 필요가 없다. 하지만 기기나 access token이 탈취되면 오랫동안 제약없이 사용가능하다.
	- sliding-sessions
		- 보안과 편의성 모두 잡기 위해 나온 전략이다. 세션을 지속적으로 이용하는 유저에게 자동으로 만료기한을 늘려주는 방법이다.
		- 주로 유효한 access token을 가진 클라이언트의 요청에 대해 서버가 새로운 access token을 발급해주는 방법을 사용한다.
		매 요청마다 새로운 토큰을 내려주는 것도 가능하지만 글을 작성하다가 인증이 만료되는 참담한 경우를 막기 위해 글작성을 시작할때 발급해준다거나, 쇼핑몰에서 장바구니에 아이템을 담는 경우에 발급해주는 등의 전략을 사용하는 것도 괜찮은 방법이다.
		- 클라이언트가 토큰의 발급시간 속성을 참조해서 갱신요청하는 방법도 있다.
		- 글을 작성하거나 결제하는 등의 세션유지가 필요한 순간에 세션이 만료되는 문제를 방지할 수 있다.
		- 사용자가 자주 로그인할 필요가 없다.
		- 접속시 단발성으로 이루어지는 서비스의 경우 이 전략이 효과적이지는 않다.
		- 긴 만료시간을 갖는 access token을 사용하는 경우 로그인을 전혀 하지 않아도 되는 경우가 발생한다.
	- refresh-token
		- access token은 30분 내외로 refresh token은 2주에서 한 달 정도의 만료기간을 보통 부여한다.
		- 클라이언트는 access token이 만료되었다는 오류를 받으면 따로 저장해두었던 refresh token을 이용해 access token의 재발급을 요청한다.
		- 서버는 유효한 refresh token으로 요청이 들어오면 새로운 access token을 발급하고 만료된 refresh token으로 요청이 들어오면 오류를 반환해 사용자에게 로그인을 요구한다.
		- access token은 서버에 따로 저장해둘 필요가 없지만, refresh token의 경우 서버의 스토리지에 따로 저장해서 이후 검증에 활용해야 한다. 따라서 refresh token을 사용한다는 것은 추가적인 i/o 작업이 필요하다는 의미이며, 빠른 인증처리를 장점으로 내세우는 jwt의 스펙에 포함되지 않는다.
		- refresh token은 탈취되어서는 곤란하므로 클라이언트는 보안이 유지되는 공간에 이를 저장해야한다.
		- refresh token은 서버에서 따로 저장하므로 강제로 토큰을 만료시키는 것이 가능하다.
		- 짧은 만료기간을 사용할 수 있기때문에 access token이 탈취되더라도 제한된 기간만 접근 가능ㅎ다ㅏ.
		- 사용자가 자주 로그인할 필요가 없다.
		- 클라이언트는 access token의 만료에 대한 연장 요청을 구현해야한다.
		- 인증 만료 기간의 자동 연장이 불가능하다.
	- sliding-sessions + refresh-token
		- sliding sessions 전략으로 access token의 자체 만료기간을 늘려주었다면 이 전략은 refresh token의 만료기간을 늘려준다.
		- refresh token의 만료기간이 늘어나므로 sliding sessions 전략처럼 빈번하게 만료기간을 연장할 필요가 없고, 사용자의 유휴 허용기간을 refresh token 기간에 근접하게 늘려준다.
		- 반면 사용자가 접속을 뜸하게 하는 경우에도 refresh token의 만료기간이 늘어나기때문에 기기가 탈취되는 경우 지속적으로 이용이 가능하다.
		- 이를 막는 방법으로 인증이 확실히 요구되는 경우 비밀번호를 한 번 더 묻거나 비밀번호 변경 등의 이벤트가 발생할 때 강제로 refresh token을 만료시키는 처리를 하면 좋다.

## 14.07.2020

- network
	- Rx(Receive): 데이터 수신을 의미
	- Tx(Transmit): 데이터 송신을 의미

- lora
	- 전파법
		- 국내에는 433MHz 주파수를 사용하는 모델과 868/915MHz 주파수를 사용하는 모델이 판매중이다.
		- 국내 전파인증된 로라를 구입하면 전파법 걱정은 하지 않아도 된다.
		- 대부분의 제품은 해외에서 수입하는 제품으로 국내 전파법을 따르는지 정확히 확인해야한다.
		- 국내 전파법에 해당하는 채널 중 26~32 채널은 25mW까지 출력세기를 높일 수 있다. 높은 출력을 낼수록 신호를 더욱 강하게 멀리 보낼 수 있다.
	- 특징
		- 국내 이통사의 통신수단을 사용하지 않고 멀리까지 데이터를 보낼 수 있는 몇 되지 않는 좋은 통신수단이다.
		- LoRaWAN은 LoRa 전용 MAC 계층에서 사용하는 프로토콜이다. 데이터를 정확하게 전달하기 위해 사용한다.
		- LoRaWAN를 구성하지 않아도 통신을 하고 여러 노드를 모아서 서비스를 구성할 수는 있다.
		- 대규모 LoRa 장비들을 일괄적으로 정확하게 제어하기 위해서는 LoRa 재단에서는 LoRaWAN을 구성하는 것을 추천한다.
		- SF(Spreading Factor)를 적절하게 설정해주어야 원하는 목적을 이룰 수 있다. 
			- SF7은 가장 짧은 시간안에 데이터를 전송할 수 있지만 가장 짧은 거리를 보낸다. 배터리 소모량이 적다.
			- SF12는 전송하는데 가장 오랜 시간이 걸리지만 가장 멀리 보낼 수 있다. 배터리 소모량이 많다.
			- 확산계수가 증가하면 같은 양의 데이터를 전송하는데 대기시간이 2배가 된다.
		- 쌍방향 대칭키 암호화 방식인 AES128 기법으로 암호화를 한다. 16개의 키로 데이터를 암호화해서 전송하고 수신측에서는 수신한 데이터를 동일한 키로 복호화해서 사용한다.
		- 저전력 로라를 구현하고싶다면 Tx, SF를 낮춰야 한다. 하지만 원하는 거리에서 통신하는 것이 목적이므로 먼저 통신테스트를 실시해서 데이터가 정상적으로 전달되는지 확인해야한다.
		- 이후 Tx, SF를 변경하면서 데이터 수신시 RSSI, SnR을 참고해 최적의 Tx, SF를 설정할 수 있다.
	- LoRa 하드웨어
		- LoRa 통신칩만 구매해서 하드웨어 제작
			- 원활한 통신을 보장하기 위해 테스트와 최적화 작업이 필요하다.
			- Semtech의 가이드라인에 맞춰 설계해야한다.
			- 난이도가 가장 높다.
		- LoRa 통신 모듈에 CPU와 주변회로를 추가해서 하드웨어 제작
			- LoRa 통신을 위한 최적화 작업을 하지 않아도 되므로 난이도가 적당하다.
		- LoRa 통신 모듈에 CPU와 주변회로가 하나로 구성된 로라 모듈
			- 아두이노, 라즈베리파이 보드에 시리얼과 전원만 연결해서 쉽게 사용할 수 있다.
			- 로라 통신칩이 모듈 내 CPU에 물리적으로 연결되어있어 통신모듈 제조사에서 동작 펌웨어를 미리 구성해둔다.
			- 사용자는 다른 CPU를 통해 모듈을 손쉽게 동작할 수 있다.
			- 가격은 비싸다.

- encryption
  - bidirectional: 암호화, 복호화가 가능하다.
    - private(asymmetric)
      - 암/복호화에 서로 동일한 키를 사용하는 방식이다. 그래서 키를 비공개로 한다.
      - 속도가 빠르다.
      - 송신측에서 수신측으로 키를 전달하는 과정 중에 노출우려가 있다.
      - 보통 암호화 알고리즘 하면 이것을 가리킨다.
      - 훌륭한 방식이지만 키 배송에 관한 문제로 어떻게든 송신 측에는 수신 측의 암호를 전달해야만 하고, 이 키가 전달되는 과정에 털린다면 아무리 뛰어난 암호화 알고리즘을 사용했더라도 평문이 털리고 만다.
      ![](https://t1.daumcdn.net/cfile/tistory/99AF053B5AF07E0506)
    - public(symmetric)
      - 암/복호화에 서로 다른 키가 사용되는 암호화 방식이다. 하나의 키는 공캐키로 사용한다.
      - 키 전달 중 생기는 문제를 근본적으로 차단해 안정성이 높다.
      - 대칭키에 비해 속도가 느리다.
      - 2개의 키 A, B가 있다고 가정했을 때, A로 암호화한 암호문은 B로만 복호화할 수 있고, B로 암호화한 암호문은 A로만 복호화할 수 있다.
      - 이 중 하나의 키만 비밀로 보호하고 다른 하나의 키는 공중에 공개해도 관계가 없다.
      - 공개키로 암호화한 암호문은 어차피 개인키를 가진 사람만이 풀어볼 수 있으므로 상호간에 공개키만 교환하고 상대의 공개키로 암호화를 해서 데이터를 교환하면 상대는 자신의 개인키로 복호화한다.
      - 따라서 키 전달 문제는 근본적으로 발생하지 않는다.
      - 개인/공개키의 관계를 이용해서 전자서명에 활용하기도 한다. 특정 문서를 개인키로 암호화해서 발송하면 이 문서는 해당 발신자의 공개키로만 복호화하는 방식이다.
      - 공개키이므로 아무나 열어볼 수 있지만 해당 발신자의 공개키로만 열린다는 사실에서 이 문서가 해당 발신자에게 온 것을 인증할 수 있다.
      ![](https://t1.daumcdn.net/cfile/tistory/99357A3B5AF07E053D)
- unidirectional: 암호화는 가능하지만 복호화는 불가능하다.
  - 주로 해시기법을 사용하며 최소한 sha-2를 쓰는 것이 좋다.
  - 기본적으로 동일한 평문은 동일한 암호문으로 저장되는 순수한 상태지만 이를 바탕으로 평문을 복원할 수는 없다.
  - 패스워드는 양방향 암호로 저장하는 것보다 단방향 암호로 저장하는 것이 안전하다.
  - 암호화된 패스워드 목록이 털리더라도 이를 가지고 원래의 패스워드를 복원할 수 없기때문이다.
  - 패스워드 자체를 검증할 때는 입력받은 값을 암호화해서 암호화한 값끼리 비교해 인증처리를 한다.
  
- iot-class
  - a
    - 상시전원을 사용하지 않고 배터리로 운영하는 경우에 사용한다.
    - 디바이스가 게이트웨이에 up-link를 수행한 후 두번에 걸쳐 down-link를 수신할 수 있다.
    ![](https://t1.daumcdn.net/cfile/tistory/2561413D5899B5C12E)
  - b
    - a class에 비해 낮은 지연시간을 가지고 있다.
    - 배터리로 운영하는 경우 고려할 수 있다.
    - 일정시간 간격마다 수신할 수 있는 상태가 될때 LoRa 게이트웨이로부터 데이터를 받을 수 있다.
		![](https://t1.daumcdn.net/cfile/tistory/263F513D5899B5C231)
  - c
    - 타 class에 비해 지연시간이 가장 짧다.
    - 대신 전력 소비량이 가장 크기때문에 충분한 전력이 공급되는 상황에 사용해야한다.
    - 스마트 플러그, 원격 제어 등에 적합하다.

## 15.07.2020

- firebase-auth
	- firebase id token은 수명이 1시간 정도이며, refresh token을 사용해 새 id token을 가져올 수 있다.
	- refresh token은 사용자가 삭제되거나 비활성화되거나 계정에 비밀번호, 이메일 주소 업데이트 등의 이벤트가 감지된 경우 자동으로 만료된다.
	- refresh token을 취소하는 기능도 있다. 사용자가 구글에 기기 도난신고를 하면 기존 refresh token은 취소된다.
	- 비밀번호 재설정을 해도 사용자의 기존 token은 취소되지만 이 경우 firebase 인증 백엔드에서 자동으로 취소 처리한다.

- [IoT 모듈](http://www.libelium.com/development/waspmote/documentation/lora-vs-lorawan/)
	- LoRa
		- link 계층만 가지고 있다. 
		- 노드간 p2p 통신에 안성맞춤이다. 
		- LoRaWAN 모듈보다 조금 더 저렴하다.
	- LoRaWAN
		- network 계층까지 포함하고 있다. 
		- 클라우드 플랫폼에 연결된 어느 기지국으로건 데이터를 보낼 수 있다.
		- 소켓의 오른쪽 안테나에 부착하면 다른 주파수에서 작동한다.

- woz(Wizard of Oz prototyping)
	- 아직 완성되지 않은 특정 시스템을 설계하거나 프로그램의 인터페이스를 설계하고자 할때 현실적으로 불가능한 기술이나 상황이 발생한 경우 시스템의 목적과 기능에 대한 task scenarios를 준비하고 prototyping을 적용해 결과를 도출하는 방법이다.
	- 실험을 수행하면서 사용자의 주변, 보이지 않는 공간에 wizard의 역할을 하는 사람이 상주해 각 task마다 상황에 필요한 prototyping을 신속하게 제공해 실험을 반복한다.
	- 프로세스
		- task 디자인과 프로토타입 제작
		- wizard의 역할과 task scenario 준비
		- 역할 수행과 실험 설비 준비
		- woz 진행
		- 데이터 분석과 인사이트 결과 도출

- backbone
	- 자신에게 연결된 소형 회선들로부터 데이터를 모아 빠르게 전송할 수 있는 대규모 전송회선을 말한다.
	- 인터넷이나 다른 통신망에서는 장거리 접속을 위해 연결된 근거리 및 지역망의 모음이다.
	- 각 접속점들은 네트워크 노드 또는 전송데이터 교환 스위치라고 한다.