## 02.08.2020

- oauth2
  - 인증과 권한부여에 관한 기본적인 흐름뿐 아니라 목적에 맞게 확장할 수 있도록 설계되어있다.
  - 서버와 클라이언트 사이에 인증을 완료하면 서버는 권한부여의 결과로 access token을 전송한다.
  - 클라이언트는 access token을 이용해서 접근 및 서비스를 요청할 수 있다.
  - 서버는 access token을 기반으로 서비스와 권한을 확인하며 접근을 허용할지 말지를 결정하고 결과데이터를 클라이언트에게 보낸다.
  - 서버는 access token을 기반으로 클라이언트를 확인하기때문에 session, cookie를 이용해 클라이언트의 상태정보를 유지할 필요가 없다.
  - oauth 2.0은 외부 서비스의 인증 및 권한부여를 관리하는 범용 프레임워크이다.
  - oauth 기반 서비스의 api를 호출할 떄는 http 헤더에 access token을 포함해 요청을 보낸다.
  - 사용자 입장에서는 oauth의 권한 요청 절차는 access token을 획득하는 것이 주요한 목적이며, 서비스 제공자 입장에서는 인증된 사용자에게 access token을 발급하는 것이 가장 중요하다고 할 수 있다.
  - oauth를 구성하고 있는 주요 4가지 역할
    - resource owner: protected resource에 접근하는 권한을 제공한다.
    - resource server: access token을 사용해 요청을 수신할때 권한을 검증한 후 적절한 결과를 응답한다.
    - client: resource owner의 protected resource에 접근을 요청하는 애플리케이션이다.
    - authorization server: client가 성공적으로 access token을 발급받은 이후에 resource owner를 인증하고 obtaining authorization을 한다.
  - 권한 허가를 위한 절차
    - client가 resource owner에게 authoriation request를 한다. 이 떄 권한 요청은 resource owner에게 직접하거나 resource server를 통해 간접적으로 할 수도 있다.
    - resource owner가 권한을 허가하면 client는 권한증서를 발급받는다.
      - 권한증서는 자원소유자가 자원에 접근할 수 있는 권한을 부여했다는 확인증으로 client가 access token을 얻어오는데 사용한다. 아래와 같은 4가지 타입이 있다.
        - authorization code: client가 resource owner에게 직접 권한부여를 요청하는 대신 resource owner가 authorization server에서 인증을 받고 권한을 허가한다. 소유자가 권한을 허가하면 권한코드가 발급된다. 이 코드를 client에게 전달한다. client는 이 코드를 권한 서버에 보내주면서 자신이 권한을 허가받았다는 사실을 알리고 access token을 받는다. 이 방법은 보안상 이점이 있다. access token을 바로 client에 전달하지 않기때문에 잠재적인 유출위험을 방지할 수 있다.
        - implicit: 권한코드를 간소화한 절차이다. 권한코드 방식에서 access token을 얻기위한 중간 매개체로 권한코드를 사용했던 것과는 달리, 이 방식은 권한코드를 발급하지 않고 access token을 바로 발급한다. 대신 보안성이 떨어진다.
        - resource owner password credentials: 자원소유자의 계쩡 아이디와 비밀번호같은 계쩡 인증정보가 access token을 얻기위한 권한증서로 사용된다. 계정정보를 애플리케이션에 직접 입력해야 하므로 신뢰할 수 있어야 한다. access token을 얻은 후에는 리소스요청을 위해 아이디, 비밀번호를 client가 보관하고 있을 필요는 없다.
        - client credentials: client 인증방식이라고도 한다. 자원소유자가 유저가 아닌 client인 상황에 활용한다. client가 관리하는 리소스에만 접근할 경우 권한이 한정된 경우 활용할 수 있다. client는 곧 resource owner인 상황이다. client는 자기를 인증할 수 있는 정보를 authorization server에 보내면서 access token을 요청한다.
    - authorization grant를 받은 client는 최종 목적인 access token을 권한서버에 요청한다.
    - 요청을 받은 authorization server는 client가 보내온 권한증서의 유효성으 검증한다. 유효하다면 access token을 발급하고 결과를 client에게 알려준다.
    - access token을 받은 client는 resource server에 자원을 요청할 수 있게 된다.
    - 요청을 받은 resource server는 access token의 유효성을 검증하고 유효하다면 요청을 처리해준다.
  - 결론
    - authorization code, implicit은 서비스에 접근하는 외부 앱을 위한 방법이다. 
    - authorization code는 자신만의 서버를 갖고 동작하는 서비스인 경우에 적합하다.
    - implicit은 백엔드없이 순수 client에서만 동작하는 앱의 경우에 적합하다.
    - client credentials를 사용하고자 한다면 firebase같은 paas를 사용하는 것이 좋다.
    - resource owner password credentials는 자신의 authorization server에 접속해 인증하기때문에 clinet id, secret을 하드코딩하게 된다. 

## 05.08.2020

- clean-code
  - 본인이 짠 코드에 자신이 없을 경우, 측정할 수 있는 무언가를 통해 자신감이나 만족감을 얻고싶은 욕구를 느낀다. 대표적으로 엄격한 lint, 네이밍 규칙, 폴더구조, 중복제거 등이 그렇다.
  - 중복제거를 자동화할 수는 없지만 연습을 통해 능력을 개선할 수는 있다.
  - 보통 리팩토링 후에 코드의 양이 줄거나 늘었다는 것을 따지기 십상이다.
  - 결과적으로 중복을 제거한 것은 코드에 대한 객관적인 지표를 개선시킨 것처럼 느끼게 만든다. 
  - 함수나 클래스로 로직을 분리해 코드를 심플하게 만드는 것은 좋은 일이다. 
  - 단지 이것은 프로그램의 복잡도를 낮추고자 하는 시도일 뿐이며, 코드가 어떻게 바뀔지 모르는 상황에서 피해를 최소한으로 줄이고자 하는 방어전략 중 하나일 뿐이다. 얽매이지 말아야 한다.