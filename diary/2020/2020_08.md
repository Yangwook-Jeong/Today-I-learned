## 02.08.2020

- oauth2
  - 인증과 권한부여에 관한 기본적인 흐름뿐 아니라 목적에 맞게 확장할 수 있도록 설계되어있다.
  - 서버와 클라이언트 사이에 인증을 완료하면 서버는 권한부여의 결과로 access token을 전송한다.
  - 클라이언트는 access token을 이용해서 접근 및 서비스를 요청할 수 있다.
  - 서버는 access token을 기반으로 서비스와 권한을 확인하며 접근을 허용할지 말지를 결정하고 결과데이터를 클라이언트에게 보낸다.
  - 서버는 access token을 기반으로 클라이언트를 확인하기때문에 session, cookie를 이용해 클라이언트의 상태정보를 유지할 필요가 없다.
  - oauth 2.0은 외부 서비스의 인증 및 권한부여를 관리하는 범용 프레임워크이다.
  - oauth 기반 서비스의 api를 호출할 떄는 http 헤더에 access token을 포함해 요청을 보낸다.
  - 사용자 입장에서는 oauth의 권한 요청 절차는 access token을 획득하는 것이 주요한 목적이며, 서비스 제공자 입장에서는 인증된 사용자에게 access token을 발급하는 것이 가장 중요하다고 할 수 있다.
  - oauth를 구성하고 있는 주요 4가지 역할
    - resource owner: protected resource에 접근하는 권한을 제공한다.
    - resource server: access token을 사용해 요청을 수신할때 권한을 검증한 후 적절한 결과를 응답한다.
    - client: resource owner의 protected resource에 접근을 요청하는 애플리케이션이다.
    - authorization server: client가 성공적으로 access token을 발급받은 이후에 resource owner를 인증하고 obtaining authorization을 한다.
  - 권한 허가를 위한 절차
    - client가 resource owner에게 authoriation request를 한다. 이 떄 권한 요청은 resource owner에게 직접하거나 resource server를 통해 간접적으로 할 수도 있다.
    - resource owner가 권한을 허가하면 client는 권한증서를 발급받는다.
      - 권한증서는 자원소유자가 자원에 접근할 수 있는 권한을 부여했다는 확인증으로 client가 access token을 얻어오는데 사용한다. 아래와 같은 4가지 타입이 있다.
        - authorization code: client가 resource owner에게 직접 권한부여를 요청하는 대신 resource owner가 authorization server에서 인증을 받고 권한을 허가한다. 소유자가 권한을 허가하면 권한코드가 발급된다. 이 코드를 client에게 전달한다. client는 이 코드를 권한 서버에 보내주면서 자신이 권한을 허가받았다는 사실을 알리고 access token을 받는다. 이 방법은 보안상 이점이 있다. access token을 바로 client에 전달하지 않기때문에 잠재적인 유출위험을 방지할 수 있다.
        - implicit: 권한코드를 간소화한 절차이다. 권한코드 방식에서 access token을 얻기위한 중간 매개체로 권한코드를 사용했던 것과는 달리, 이 방식은 권한코드를 발급하지 않고 access token을 바로 발급한다. 대신 보안성이 떨어진다.
        - resource owner password credentials: 자원소유자의 계쩡 아이디와 비밀번호같은 계쩡 인증정보가 access token을 얻기위한 권한증서로 사용된다. 계정정보를 애플리케이션에 직접 입력해야 하므로 신뢰할 수 있어야 한다. access token을 얻은 후에는 리소스요청을 위해 아이디, 비밀번호를 client가 보관하고 있을 필요는 없다.
        - client credentials: client 인증방식이라고도 한다. 자원소유자가 유저가 아닌 client인 상황에 활용한다. client가 관리하는 리소스에만 접근할 경우 권한이 한정된 경우 활용할 수 있다. client는 곧 resource owner인 상황이다. client는 자기를 인증할 수 있는 정보를 authorization server에 보내면서 access token을 요청한다.
    - authorization grant를 받은 client는 최종 목적인 access token을 권한서버에 요청한다.
    - 요청을 받은 authorization server는 client가 보내온 권한증서의 유효성으 검증한다. 유효하다면 access token을 발급하고 결과를 client에게 알려준다.
    - access token을 받은 client는 resource server에 자원을 요청할 수 있게 된다.
    - 요청을 받은 resource server는 access token의 유효성을 검증하고 유효하다면 요청을 처리해준다.
  - 결론
    - authorization code, implicit은 서비스에 접근하는 외부 앱을 위한 방법이다. 
    - authorization code는 자신만의 서버를 갖고 동작하는 서비스인 경우에 적합하다.
    - implicit은 백엔드없이 순수 client에서만 동작하는 앱의 경우에 적합하다.
    - client credentials를 사용하고자 한다면 firebase같은 paas를 사용하는 것이 좋다.
    - resource owner password credentials는 자신의 authorization server에 접속해 인증하기때문에 clinet id, secret을 하드코딩하게 된다. 

## 05.08.2020

- clean-code
  - 본인이 짠 코드에 자신이 없을 경우, 측정할 수 있는 무언가를 통해 자신감이나 만족감을 얻고싶은 욕구를 느낀다. 대표적으로 엄격한 lint, 네이밍 규칙, 폴더구조, 중복제거 등이 그렇다.
  - 중복제거를 자동화할 수는 없지만 연습을 통해 능력을 개선할 수는 있다.
  - 보통 리팩토링 후에 코드의 양이 줄거나 늘었다는 것을 따지기 십상이다.
  - 결과적으로 중복을 제거한 것은 코드에 대한 객관적인 지표를 개선시킨 것처럼 느끼게 만든다. 
  - 함수나 클래스로 로직을 분리해 코드를 심플하게 만드는 것은 좋은 일이다. 
  - 단지 이것은 프로그램의 복잡도를 낮추고자 하는 시도일 뿐이며, 코드가 어떻게 바뀔지 모르는 상황에서 피해를 최소한으로 줄이고자 하는 방어전략 중 하나일 뿐이다. 얽매이지 말아야 한다.


## 09.08.2020

- design-pattern
  - adapter: 서로 다른 두 클래스가 있고, 이 둘은 그대로 둔 채로 이 둘의 인터페이스를 연결하고자 어댑터 클래스를 만들어 사용하는 구조를 말한다. 이미 정의된 인터페이스를 수정하기 어려운 상황에 사용하기 좋다.
    <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbAgRVy%2FbtqDF1ayTFc%2FijlsiFtlo4ykPMx0kMxTy0%2Fimg.png">
  - composite: 여러개의 클래스가 크게보면 같은 요소에 속하지만, 여기에 속한 어떤 클래스가 다른 클래스를 가질 수 있는 구조를 말한다. 부모자식 관계를 나타내고 싶은 경우에 사용하기 좋다.
    <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb9RGse%2FbtqDH1gnUiN%2F494imhovd8kWrLhxGE2lsK%2Fimg.png">
  - decorator: 각각 기능을 담당하는 클래스들과 이 기능을 적용할 클래스를 분리한 뒤에 필요에 따라 동적으로 각 기능을 적용할 수 있는 구조를 말한다. 경우에 따라 부가적인 기능을 추가하거나 빼고 싶을 때 사용한다.
    <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbBRrjm%2FbtqDGfzDLPS%2FaV6YcRuKqvAvvng46TYvjk%2Fimg.png">
  - proxy: 구체적인 업무를 담당하는 클래스에 접근하기 전에 간단한 사전 작업처리를 하는 클래스를 두는 구조를 말한다. 주요 기능이 요청을 받아 수행하기 전에 이 요청에 대한 부가적인 전처리를 수행하는 로직을 세우고 싶을 때 사용한다.
    <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FYZKDU%2FbtqDGJmYL7U%2FrYiDgcf7dWYQzlHHKXw3Vk%2Fimg.png">

- refactoring
  - 코드에서 나는 악취
    - 명료하고 정확하지 않은 이름
      - 변수, 함수, 클래스, 파일명 모두 해당한다.
      - 이름이 항상 무엇을 하는지 명확히 드러내야 한다. 
    - 중복 코드
      - 3번 이상 등장하는 코드가 있다면 어떻게든 한 곳으로 모아준다.
    - 긴 함수, 클래스, 매개변수
      - 길수록 보기 어렵고 이해하기 어렵다.
      - 길다는 건 너무 많은 역할을 담당하고 있다는 것이다. 쪼개거나 묶어야한다.
    - 전역 데이터
      - 전역데이터는 어디서든 건드릴 수 있고 누가 바꿨는지 찾아내기 힘들다.
    - 추측성 일반화
      - 나중에 필요할거라는 생각으로 작성한 로직과 코드는 실제로 사용하지 않는 경우가 많다.
      - 실제로 사용하면 다행이지만 그렇지 않다면 이해와 복잡도를 증가시킬 뿐이다.
    - 주석
      - 항상 나쁘지는 않다. 주석은 필요한 경우 코드에 향기를 입힌다.
      - 장황한 설명이 달린 주석은 코드를 잘못 작성했기때문인 경우가 의외로 많다.
      - 주석보다는 함수나 변수명으로 의도를 명확히 드러내는 것이 좋다.
  - 리팩토링
    - 베이직
      - 함수 추출
        - 목적과 구현을 분리한다.
        - 코드를 보면 어떻게보다 무엇을 하는지 한 번에 알 수 있도록 함수명을 변경한다.
        - 하나의 함수를 한가지 목적만 가지고 한가지일만 해야한다.
        - 한 줄짜리 함수라도 상관없다. 무엇을 하는지 드러나야 한다.
        - 함수의 길이는 한 눈에 들어와야 한다.
        - 두 번이상 사용될 코드는 함수로 만든다.
        - 함수명이 짓기 어려우면 주석으로 먼저 무슨 일을 하는지 적어둔다.
        - 코드 자체로 무엇을 하는지 명확히 보인다면 굳이 추출하지 않는다.
      - 변수 추출
        - 복잡한 표현식은 과정을 나누어 표현한다.
        - 각 과정을 잘 드러내는 임시변수를 사용한다.
        - 변수이름을 문맥에 맞게 잘 짓는다.
        - 문맥은 함수, 클래스 내부, 전역 등에 따라 달라지므로 어떻게 사용할지 생각하고 지어야한다.
        - 추출하지 않아도 그 자체로 명확히 보인다면 추출하지 않는게 좋다.
      - 매개변수 객체 생성
        - 몰려다니는 데이터 무리를 데이터구조 하나로 모아준다.
        - 데이터구조를 묶으면 데이터 사이의 관계까 아주 명확해진다.
        - 객체를 만드는 것은 어떤 개념을 추상화하는 것이다.
        - 변수를 하나의 객체로 묶어 하나의 개념을 만들어내고, 이것은 더 나은 디자인을 만들 수 있다.
          ```py
          # before
          def amount_invoiced(start_date, end_date):
            pass
          def amount_recevived(start_date, end_date):
            pass
          def amount_overdue(start_date, end_date):
            pass
          
          # after
          def amount_invoiced(date_range):
            pass
          def amount_recevived(date_range):
            pass
          def amount_overdue(date_range):
            pass
          ```
      - 여러 함수를 클래스로 묶기
        - 클래스로 묶으면 함수들이 공유하는 공통환경과 목적을 명확히 표현할 수 있다.
        - 또한 함수 매개변수를 줄여 호출을 더 간결하게 만들 수 있다.
        - 원하는 함수를 클래스 단위로 빠르게 찾을 수 있다.
          ```py
          # before
          def base(reading):
            pass
          def taxableCarge(reading):
            pass
          def calculate_base_charge(reading):
            pass

          # after
          class Reading:
            def __init__(self, reading):
              self.reading = reading
            def base(self):
              pass
            def taxableCarge(self):
              pass
            def calculate_base_charge(self):
              pass
          ```
    - 캡슐화
      - 레코드 캡슐화
        - 곳곳에 쓰이는 가변데이터는 레코드가 아니라 객체로 저장해야 한다.
        - 데이터구조를 명확히 표현할 수 있고, 코드 한 곳에서 관리하고 표현할 수 있게 된다.
      - 임시변수를 질의함수로 변경
        - 곳곳에 쓰이는 임셔변수 메서드를 만들어 굳이 임시변수를 만들지 않아야한다.
      - 클래스 추출
        - 개발과정에서 점점 비대해지는 클래스를 적절히 분리한다.
        - 단일 책임 원칙을 잊지 말아야한다.
        - 일부 데이터와 메서드를 따로 묶을 수 있다면 분리하라는 신호이다.
        - 함께 변경되는 일이 많거나 의존하는 데이터들도 분리한다.
        - 개발중 일부 기능만을 사용하기 위해 서브클래스를 만들어야 한다면 클래스를 나눠야 한다는 신호이다.
        - 리팩토링을 거치면서 쓸모 없어진 클래스는 이과정을 반대로 한다.
    - 기능 이동
      - 문장 슬라이딩
        - 관련된 코드들이 가까이 모여있다면 이해하기 쉽다.
        - 데이터 구조를 이용하는 문장들은 한데 모여야 그 쓰임을 정확히 알 수 있다.
        - 함수 첫머리에 변수를 몽땅 선언하기보다 처음 사용할때 선언하는 것이 좋다.
        - 관련된 것들은 한데모아두어야 추가 리팩토링을 하기 쉽다.
      - 반복문 쪼개기
        - 하나의 반복문은 하나의 일만 해야 이해하기도 관리하기도 쉽다.
        - 한 반복문에 두가지 일을 하면 두가지 일 모두 이해해야 하고 수정할때도 신경써야한다.
        - 성능최적화는 당장 고려하지 않는다.
        - 성능적으로 문제가 있다는게 밝혀지면 그때 다시 합치면 된다.
        - 코드분리는 또 다른 최적화나 디자인 패턴의 길을 열어주기도 한다.
          ```py
          # before
          average_age = 0
          total_salary = 0
          for person in people:
            average_age += person.age
            total_salary += person.salary
            
          average_age = average_age / len(people)

          # after
          total_salary = 0 
          for person in people: 
            total_salary += person.salary 

          average_age = 0 
          for person in people: 
            average_age += person.age 

          average_age = average_age / len(people)
          ```
    - 조건부 로직 간소화
      - 조건문 분해
        - 긴 조건문은 의도를 드러낼 수 있는 함수로 추출해 로직을 명확히 해야한다.
      - 조건식 통합
        - 하나로 합칠 수 있는 조건식은 합친 뒤에 의도를 드러낼 수 있는 함수로 추출한다.
      - 특이케이스 추가
        - 특수한 경우 공통 동작을 요소 하나에 모아서 사용하면 관리하기 쉽다.
        - 일반적으로 특정 값에 대해 똑같이 반응하는 코드가 여러 곳이면 그 반응을 한데로 모으는게 효율적이다.
        - 모으는 것은 리터럴 객체나 따로 정의한 클래스에 모을 수 있다.
        - 데이터를 담기만 하는 경우 리터럴 객체를 쓰면 되고, 어떤 동작을 수행해야하면 클래스로 추출하면 된다.
        - null object 패턴이라고도 한다.
      - 어셔선 추가
        - 어떤 상태임을 가정한채 실행되는지 다른 개발자에게 알려주는 소통 도구이다.
        - 어서션이 있고 없고가 프로그램의 정상 동작에 아무런 영향을 주지 않도록 작성되어야 한다.
        - 다시 말해 실패해서는 안된다. 실패한다면 어딘가 잘못 구현한 코드가 있다는 뜻이다.

- highcharts
  - title: 테이블 상단에 보이는 텍스트
    <img src="https://www.highcharts.com/docs/chart-concepts/titleandsubtitle.png">
  - series: 차트에 보여지는 데이터의 계열
    <img src="https://www.highcharts.com/docs/chart-concepts/linewidth_demo.png">
  - tooltip: 차트 계열을 호버링하면 값
    <img src="https://www.highcharts.com/docs/chart-concepts/tooltip.png">
  - legend: 그래프에서 데이터 계열을 보여주고 하나 이상의 계열을 켜고 끌 수 있게 해준다.
    <img src="https://www.highcharts.com/docs/chart-concepts/legend.png">
  - axes: 차트의 x, y축으로 다른 데이터 계열을 여러 축을 보여줄 수 있다. 게이지같은 경우는 1개의 축을, 파이차트같은 경우는 축이 없다.
    <img src="https://www.highcharts.com/docs/chart-concepts/axis_description.png">

## 10.08.2020

- smb(Server Message Block)

- d3
	- svg를 사용해 커스텀이 용이하다.
	- 비표준 규격 플롯을 그릴 수 있다.
	- 저수준까지 공부할 자신이 있다면 커스텀을 다양하게 할 수 있다.	
	- dc같은 d3로 작성한 라이브러리가 있다.
	- 너무 저수준이라는 것이 단점이다. 따라서 시간을 많이 쏟을 수밖에 없다.
- highcharts
	- css 스타일시트를 추가하기 용이하며 svg를 사용해 그린다.
	- 다양한 옵션으로 커스텀이 용이하다.
	- psd에서도 웹에 그린 디자인과 같은 디자인으로 그릴 수 있다.
	- 툴팁 통합이 용이하다.
	- 다른 차트로 동기화시키는 것이 용이하다.
	- 문서가 훌륭하다.
	- 광범위한 표준 규격 플롯을 그릴 수 있다.
	- cross-filter를 지원하지 않는다.

- svg(Scalable Vector Graphic)
	- ms의 vml, apple의 pgml 대신 w3c에 채택된 표준 벡터 그래픽 기술이다.

- esb(Enterprise Service Bus)
  - 비즈니스 내에서 서비스, 애플리케이션, 자원을 연결하고 통합하는 미들웨어라고 할 수 있다.
  - 이를 통해 분산된 서비스 컴포넌트를 쉽게 통합, 연동할 수 있어 신뢰성있는 메시지 통신이 가능하다.
  - 물리적 컴퓨터 버스와 매우 유사한 기능을 제공하지만 훨씬 높은 추상화 수준을 제공하므로 버스라는 단어를 쓴다.
  - soa를 실현하는 플랫폼으로 사용할 수 있다.

## 11.08.2020

- iot-gcp-vs-aws
	- authentication and authorization
		- gcp: 공개/암호키쌍과 jwt를 통한 인증을 지원한다.
		- aws: 약간 더 복잡한 커스텀 인증 스킴을 제공한다. 
	- communication protocols
		- 둘 다 http, mqtt 프로토콜을 지원하지만 aws는 비동기 websocket 통신을 지원한다. 모든 통신은 tls를 사용해 보호받는다.
	- data analytics
		- gcp: bigquery, cloud dataflow같은 머신러닝 서비스를 통합시켜준다.
		- aws: 데이터를 수집하고 기본적인 데이터 관리(filtering, transforming 등)만을 제공한다. 후속처리는 다른 서비스를 사용해야한다.
	- device management
		- gcp: 디바이스 설정과 관리가 aws에 비해 좋지 않다.
		- aws:  디바이스 등록을 모든 방식으로 지원한다. 기기별 권한 관리, 모니터링, 트러블슈팅을 지원한다.

- etl
	- 각기 다른 rdbms로부터 데이터를 불러오고 데이터를 변형해 dw에 적재한다.
	- etl 서버나 staging 영역에서 데이터 변형을 마친다.
	- 데이터가 staging에 먼저 적재되고 나중에 target system에 적재된다. 시간에 민감하다.
	- 데이터 변형이 완료될 때까지 기다려야 한다. 데이터 사이즈가 커질수록 변형에 들어가는 시간이 증가한다.
	- 높은 수준의 유지보수가 요구되고, 적재하고 변형할 데이터를 선택해야 한다.
	- 구현 복잡도가 초기영역에서는 쉽다.
	- on-premise 환경에 관계형이고 정형데이터에 사용한다.
	- 설계를 하는 시점에 중요한 데이터들만 적재한다.
	- 데이터셋에 추가되는 데이터 단위마다 aggragation하는 난이도가 증가한다.
	- 기존 column을 덮어쓰거나 데이터셋을 추가하고 target platform에 push한다.
	- 20년 이상 사용된 컨셉으로 best practice를 쉽게 찾을 수 있다.
- elt
	- 데이터 이동에 대한 툴의 접근에 대한 관점을 다르게 본 것으로 추출, 적재, 변형으로 볼 수 있다.
	- 타겟 시스템이 데이터 변형을 할 수 있게 해준다. 즉, 툴이 직접 데이터 변형을 할 수 있다는 말이다.
	- dw의 db에 데이터가 남는다.
	- target system에서 데이터 변형을 실행한다.
	- target system에 한 번만 로드된다. 시간 소요가 적다.
	- 데이터 사이즈와 시간은 관계가 없다.
	- 낮은 수준의 유지보수가 요구되며, 데이터는 모두 사용할 수 있다.
	- 프로세스를 구현하기 위해 기술과 툴에 대한 깊은 이해가 요구된다.
	- 확장가능한 클라우드 환경에서 사용하며 정형/비정형 데이터를 모두 지원한다.
	- 데이터레이크가 비정형 데이터를 사용할 수 있게 도와준다.
	- target platform의 힘으로 중요 단위 데이터를 빠르게 aggregate한다.
	- 존재하는 테이블에 계산된 column을 쉽게 추가할 수 있다.
	- 새로운 컨셉이기때문에 구현이 복잡하다.

- gcp
	- containers
		- gke
			- 컨테이너식 앱실행을 위한 관리형 환경
			- cd 파이프라인을 설계할 때 사용할 수 있다. 앱 코드를 수정하면 변경이 파이프라인을 트리거해 새 버전의 앱을 자동으로 빌드, 테스트, 배포한다.
				<img src="https://cloudx-bricks-prod-bucket.storage.googleapis.com/b453d3e462abf6cfb021b92471e2a00e5dfe0b89a85749aa987afb39052c8bcd.svg">
			- 2계층 앱을 마이그레이션할 때 사용할 수 있다. migrate for anthos를 사용해 워크로드를 직접 이전할 수 있다. 
	- iot
		- cloud iot core
			- iot 기기 관리, 통합, 연결 서비스
			- 기기관리자를 사용하면 개별 기기를 간단한 방식으로 구성, 관리할 수 있다. 
			- protocol bridge는 모든 기기에 자동 load balancing을 사용해 프로토콜용 엔드포인트를 제공한다. 모든 기기 분석을 pub/sub에 게시해 이 결과를 다운스트림 분석시스템에서 사용할 수 있다.
			- tls로 비대칭 키 인증을 사용해 end-to-end 보안을 설정할 수 있다. 
			- pub/sub에 올라가는 데이터는 7일간 보관된다.
			- rest api로 규모에 맞게 기기 등록, 배포, 운영을 관리할 수 있다. 기기가 연결되지 않은 경우에도 api를 사용해 기기 속성, 상태를 검색, 업데이트할 수 있다.
			- gw를 사용해 리소스가 제한된 기기 대신 통신, 인증 등의 작업을 수행할 수 있다.
	- serverless
		- cloud functions
			- 클라우드 이벤트에 응답하는 함수를 만드는 플랫폼
			- 타사 서비스, api와 통합을 할 수 있다. 자체적인 microservice를 제공하거나 웹훅 통합 기능을 제공하는 타사 서비스와 통합해 결제 성공후 이메일 전송이나 sms 이벤트 응답 등을 할 수 있도록 앱을 확장할 수 있다.
				<img src="https://cloudx-bricks-prod-bucket.storage.googleapis.com/e95d4c33e1af335c2eeff991f3731fc78d46e448b7a578933b4503767da4c293.svg">
			- 서버리스 모바일 백엔드를 만들 수 있다. 사용자 작업, 분석, 인증이벤트에 대한 응답으로 코드를 실행해 이벤트 기반 알림을 통해 cpu, 네트워크 소모가 많은 작업의 부하를 분산할 수 있다.
				<img src="https://cloudx-bricks-prod-bucket.storage.googleapis.com/05160504d56cfbe1aaf1a16ef9f374f6d8e1087ec34a4f21d0e5dc26689f6e99.svg">
			- 서버리스 iot 백엔드를 만들 수 있다. telemetry 데이터수집, 실시간처리, 분석을 위한 백엔드를 구축할 수 있다.
				<img src="https://cloudx-bricks-prod-bucket.storage.googleapis.com/e65df84c862c4487cd4249ae046953b767abfcb7223800952fd53ac97cd75ad1.svg">
			- 실시간 파일 처리를 할 수 있다. 파일을 업로드하는 즉시 처리해 이미지 업로드의 미리보기 이미지 생성, 로그처리, 컨텐츠 검사, 동영상 트랜스코딩, 실시간 데이터검사와 집계, 필터링 작업을 수행할 수 있다.
				<img src="https://cloudx-bricks-prod-bucket.storage.googleapis.com/a1d59ecf9e16669e82f5a8a82b46b334a0fcbc0e08d135840c954013354d7820.svg">
			- 실시간 스트림 처리를 할 수 있다. 트랜잭션 처리, 클릭스트림 분석, 앱 작업 추적, iot 기기 telemetry, 소셜 미디어 분석을 비롯한 스트리밍 데이터를 처리, 변환, 보강할 수 있다.
				<img src="https://cloudx-bricks-prod-bucket.storage.googleapis.com/4253788a8b8a6e49d886bf49322e0faef425d15b251e5a96932f2008fca6d9ca.svg">
			- 애플리케이션에 ai를 빌드할 수 있다. 사용자의 작업을 안내하는 음성, 텍스트 기반의 자연어 대화환경을 갖추도록 제품과 서비스를 확장할 수 있다.
				<img src="https://cloudx-bricks-prod-bucket.storage.googleapis.com/31b5bfef7017b6db48c0148e9695f8522b442778a14ebeb227910c36241fed0f.svg">
			- 동영상, 이미지를 분석할 수 있다.
				<img src="https://cloudx-bricks-prod-bucket.storage.googleapis.com/3be926f64a62ecfe1ca99cdcb80d4f09b4ba27cefe059ee12337ee11f97edef5.svg">
			- 텍스트의 구조와 의미를 파악해 감정분석을 할 수 있다.
				<img src="https://cloudx-bricks-prod-bucket.storage.googleapis.com/725d935a9ec199b5459300d07b48e0fe4281c827b63291b2ba487cb5bcb13af3.svg">
	- analytics
		- bidquery
			- serverless dw로 aws redshift와 같은 역할을 한다. dw로 데이터를 적재하기 전 etl을 할 수 있다.
		- dataflow
			- 일괄 처리 및 스트림 데이터 처리
			- 스트림 분석을 사용해 데이터를 즉시 활용할 수 있다. 실시간 데이터를 수집, 처리, 분석하는데 필요한 리소스를 제공한다.
				<img src="https://cloudx-bricks-prod-bucket.storage.googleapis.com/d7c57ac02f4941ae23beb551ddc60af79868051e21d64a19c0726099a31c49ac.svg">
			- 예측분석, 사기감지, 실시간 개인맞춤 설정 등을 실시간 ai를 통해 가능하게 한다. kubeflow 파이프라인을 통해 ml을 위한 ci/cd를 지원한다.
			- 센서, 로그데이터 처리를 할 수 있다.
		- pub/sub
			- 이벤트 수집, 전송을 위한 메시징 서비스
			- 스트림 분석을 할 때 사용할 수 있다.
			- 비동기 마이크로서비스를 통합할 수 있다. 서비스를 통합하기 위한 메시징 미들웨어로 동작하거나 마이크로서비스의 단순 통신 매체로 작동한다. 지연시간이 짧은 풀전송은 웹훅 노출이 옵션이 아닌 경우 사용하거나 처리량이 높은 스트림을 효율적으로 처리하기 위해 사용할 수 있다.
		- cloud data fusion
			- 데이터 파이프라인 빌드, 관리를 위한 데이터 통합
			- 분산형 데이터 레이크를 빌드하는데 도움이 된다. 
			- 광범위한 커넥터, 시각적 인터페이스 추상화를 통해 tco를 낮추고 반복작업을 줄일 수 있다.
		- data catalog
			- 데이터를 검색, 이해, 관리하는 메타데이터 서비스
			- 데이터 소스에서 메타데이터를 수집하는 자체 커넥터를 만들 수도 있지만, 다양한 공용 데이터 소스에서 메타데이터를 수집할 수 있는 오픈 소스 커넥터를 제공한다.
				<img src="https://cloudx-bricks-prod-bucket.storage.googleapis.com/8a6c7d9f2216a512961fdbce7591c8e181dfcfbbb3b306434e977fe7d0cb5f95.svg">
		- dataprep
			- 분석, 머신러닝을 위한 데이터를 준비하는 서비스
			- 추론을 통해 사용자가 선택한 데이터의 변환 인텐트를 해석한다.
			- 한 번의 클릭으로 집계, 피벗, 피벗해제, 조인, 통합, 추출, 계산, 비교, 조건추가, 병합, 정규식 등의 기능을 적용할 수 있다. 
				<img src="https://cloudx-bricks-prod-bucket.storage.googleapis.com/29692cfceb42f30e1b6fcd317be2856dca4957fd917742bc355ae67fbbbd9e98.svg">
		- dataproc
			- 관리형 apache spark, hadoop
	- developer tools
		- cloud build
			- ci/cd 플랫폼
			- 기존 dockerfile을 가져와서 시작할 수도 있다.  지속적배포를 위해 gke, cloud run으로 배포를 자동화한다.
		- cloud code
			- k8s 앱 작성, 실행, 디버깅을 위한 ide 지원
		- cloud run
			- 컨테이너식 앱 실행을 위한 완전 관리형 환경
			- 웹 앱 배포에 사용할 수 있다.
				<img src="https://cloudx-bricks-prod-bucket.storage.googleapis.com/dad5a0272f27af95525b772149adfdba13a83d83d1d5f7d84d5bb722a010d5dc.svg">
			- rest api 백엔드 배포에 사용할 수 있다. db는 같은 vpc 안에 들어가 앱-리소스 데이터에 대한 액세스 권한이 부여된다.
				<img src="https://cloudx-bricks-prod-bucket.storage.googleapis.com/ba7e4e7b69dfbdf12d02b231c54788f11e5460bf05e899aab5bc121fd8d9d741.svg">
			- 백오피스를 관리할 수 있다.
				<img src="https://cloudx-bricks-prod-bucket.storage.googleapis.com/d664d32cddd84155f5de3c28ed390c748becc7fe89004a766c162bf44e16bbe7.svg">
			- 간단한 데이터가 도착하는 즉시 구조화된 데이터로 저장하는 데이터 처리 앱을 빌드할 수 있다. `.csv`가 만들어지면 이벤트가 발생하며 pub/sub을 통해 cloud run 서비스로 도착한다. 
				<img src="https://cloudx-bricks-prod-bucket.storage.googleapis.com/adb73854dd658476734c1a6562d1b00a31f98f4969b9d33939b9e133e90ee6aa.svg">
			- pdf 생성도구에서 서버리스로 실행해 예약된 문서 생성을 자동화할 수 있다.
				<img src="https://cloudx-bricks-prod-bucket.storage.googleapis.com/27f850f4bb2beb93e982196c93b89662edea608b06f99f528c4abb051a63143b.svg">
			- 이벤트 기반 접근방법을 사용해 작업을 연결할 수 있다. cloud function과의 차이는 docker 컨테이너를 사용할 수 있다는 점이다.
				<img src="https://cloudx-bricks-prod-bucket.storage.googleapis.com/7bd6d395c59ba5e8215f4bcd3df3c1ef4c7b3e8be001fdbf1daa1abd385b6f9f.svg">
		- cloud tasks	
			- 비동기 작업실행을 위한 작업관리 서비스
			- 마이크로서비스를 대상으로 하는 분산형 큐잉을 제공한다.
		- cloud scheduler
			- 작업자동화 및 관리를 위한 cron 작업 스케줄러
	- networking
		- cloud cdn
			- 웹, 동영상 컨텐츠 전송을 위한 네트워크
			- http/https 로드밸런서와 함께 작동해 사용자에게 컨텐츠를 전송할 수 있다. 
				<img src="https://lh3.googleusercontent.com/jKc6k8-_KCpx7eyZZRLnZbWACEojC-4Qh_-o5LpODsph4bo6vbYRaQr88EU4qBpP7wj2BbynFtFN=e14-rj-sc0xffffff-h400-w953">
		- cloud dns
			- 안정적이고 지연시간이 짧은 name 조회를 위한 dns
		- cloud load balancing
			- 애플리케이션, 리전에 트래픽 분산하는 서비스
			- http/https 로드밸런싱을 통해 단일 전역 ip주소로 전체 앱을 사용할 수 있어 dns가 단순해진다.
			- cloud logging이 로드밸런서에 전송된 모든 요청을 로깅한다. 디버깅용은 물론 사용자 트래픽 분석에 사용할 수 있다.
			- tcp/ssl 부하를 분산할 수 있다. ssl 프록시가 부하분산과 함께 https 외 트래픽에 대한 ssl 종료 기능을 제공한다.
			- ssl 인증서와 복호화를 관리할 수 있는 ssl 오프로드를 지원한다.
			- ipv6, websocket, 사용자 정의 요청 헤더, 비공개 vip용 프로토콜 전달 등의 기능도 지원한다.
	- databases
		- cloud bigtable
			- 지연시간이 짧은 빅데이터 저장을 위한 nosql wide column 데이터베이스
			- 키/값 저장소의 대규모 데이터를 저장하는데 적합하며 짧은 지연시간으로 높은 읽기, 쓰기 처리량을 지원한다. 
			- 처리량은 선형으로 확장하므로 bigtable 노드를 추가해 qps를 늘릴 수 있다.
			- 행동기반 모델을 구축해 재무분석을 할 수 있다. 시장데이터, 거래활동, 소셜데이터, 트랜잭션 데이터 등의 기타 데이터를 저장하고 통합한다.
				<img src="https://cloudx-bricks-prod-bucket.storage.googleapis.com/28ce9767378279997d9c186f7e1a19237b36870e5f3f8e5f528b06238f0e186c.svg">
			- 빠른 속도의 iot 데이터에 맞게 센서에서 실시간으로 대량의 시계열 데이터를 수집하고 분석해 정상/비정상 동작을 추적한다.
				<img src="https://cloudx-bricks-prod-bucket.storage.googleapis.com/7896f9da602782e115d3e6b4451fb27b553009b86de0133b59f19af909530881.svg">
			- 채널 전바넹 걸쳐 일관된 고객활동을 유도하기 위해 여러 소스에서 정제되지 않은 대규모 데이터를 통합한다. 고객 전반에 걸쳐 대량의 행동 데이터를 수집하고 비교해 추천/영업을 유도할 수 있는 공통패턴을 찾는다.
				<img src="https://cloudx-bricks-prod-bucket.storage.googleapis.com/bbc864b2fa821913c8b98426c0a2432f78192a9340401740ee8fd46f23507a23.svg">
		- memorystore
			- 신속한 데이터처리를 위한 redis용 메모리 저장 서비스
		- cloud spanner
			- 데이터베이스 관리를 위한 관계형 데이터베이스 관리시스템
		- cloud sql
			- 관계형 데이터베이스
		- firestore
			- 모바일, 웹 앱 데이터용 nosql 문서 데이터베이스
			- 데이터베이스와 직접 연결해 앱 개발 속도를 빠르게 만들 수 있다.
			- cloud function, bigquery 등을 손쉽게 통합할 수 있다.
		- firebase realtime database
			- 실시간 데이터 저장, 동기화를 위한 nosql 데이터베이스
			- json 데이터 실시간 동기화가 가능하다.
	- compute
		- app engine
			- app, backend용 serverless 앱 플랫폼
			- 웹용 아키텍처
				<img src="https://cloudx-bricks-prod-bucket.storage.googleapis.com/319f10cf7f09f8df1bfebba76befca436212150f615375e3a4fd8d7968e69329.svg">
			- 모바일용 백엔드 아키텍처
				<img src="https://cloudx-bricks-prod-bucket.storage.googleapis.com/70eb42ad287e1b01bdc5edbbe73ce52ab972d14bcced1359c6172dbdb8627d31.svg">

## 12.08.2020

- gatsby
	- 블로그, 포트폴리오를 빌드하고자 한다면 사용하는 것이 좋다.
	- nextjs에 비해 튜토리얼이 복잡하고 방대하다. 
	- 스타터 템플릿을 무료로 제공해 테마를 선택할 수 있다.
- nextjs
	- 컨텐츠가 많거나 앞으로 많아질 것이라고 예상한다면 빌드시간이 너무 오래걸려 static이 좋지 않기때문에 사용하는 것이 좋다.
	- 데이터 접근 방법에 자유롭고 싶다면 사용하는 것이 좋다.
	- 	- 전통적인 방법에서 벗어나 서버 하나에만 프로그램을 올려 ssr로 돌릴 수 있다.

## 13.08.2020

- nextjs
  - dynamic import
    - es2020 기능인 
  - automatic static optimization
  - static html export
  - absolute imports and module path aliases
  - amp support
  - customizing babel config
  - customizing postcss config
  - custom server
  - custom app
  - custom document
  - custom error page
  - src directory
  - multi zones
  - measuring performance
  - dubugging

## 14.08.2020

- typescript 
	- namespace
		- 어떤 모듈을 만들 수 있도록 도와주는 역할을 한다. 일정양의 코드를 조직화할 때 사용한다.
		- namespace로 조직화해서 Internal Modules로 만드는 것이 주 목적이다.
		- 코드 묶음에 이름을 부여해 이름을 통해 어디서든 접근가능하게 하는 것이다.
		- 어디서든 접근하게 만들기 위해서는 `declare namespace Validation {}`처럼 namespace를 선언해야 한다.
		- 여러 파일로 확장해서 작성할 수 있지만 `--outFile`로 합치는 것이 가능하다. 하지만 이 방법은 전역 namespace 오염이 발생할 가능성이 있어 대형 앱에서는 의존성을 파악하기 쉽지 않다.

- module
	- internal
		- typescript만의 고유한 모듈 방법으로 다른 module loader에 의존하지 않고 typescript를 컴파일할때 이름이 명명된 javascript object를 생성하면서 모듈화한다.
		- typescript는 top-level에 export가 존재하면 해당 ts 파일을 **모듈 파일**로 생각한다. 파일의 top-level에 아무런 import, export가 존재하지 않는다면 typescript는 파일을 모듈이 아닌 **스크립트 파일**로 생각하고 이는 일반적인 js파일과 같이 파일 내 생성된 변수는 window, global같은 전역스코프에 영향을 미친다.
		- 말 그대로 이름을 붙이는 namespace를 생성한다고 볼 수 있다.
		- 내부모듈을 namespace를 참조해 script 태그로 해소할 수 있다.  
			```ts
			// namespace를 참조하는 ts파일
			<reference path="Validation.ts" />
			<reference path="LettersOnlyValidator.ts" />

			// 컴파일된 js에 아래와 같이 의존함
			<script src="Validation.js" type="text/javascript" />
			<script src="LetterOnlyValidator.js" type="text/javascript" />
			```
		- 간단한 프로그램에서는 es module을 이용하는 것이 좋다. 
		- typescript에서 외부모듈은 기본으로 es2015의 모듈컨셉을 사용한다.
		- 
	- external
		- module loader에 의존해 모듈화하는 방법이다.
		- es module, common js, require.js와 같이 따로 module loader를 사용하는 모듈 방법에 해당된다.
		- 외부모듈을 사용하는 방법은 아래와 같다. 컴파일된 js, es module에 의존하는 것을 볼 수 있다.
			```ts
			import * as express from 'express'
			```

## 19.08.2020

- rational process
  - workers
    - system analyst: 시스템의 범위를 정의하고 기능의 초안을 작성한다. 사용사례를 모델링하는 작업을 수행한다.
    - designer: 클래스의 책임, 연산, 속성과 클래스간의 관계를 정의하고 구현환경에서 어떻게 적용할 것인지 결정한다.
    - test designer: 테스트 계획, 설계, 구현, 평가를 담당한다.
  - activities
    - plan an iteration: pm이 수행한다.
    - find use cases, actors: 분석가가 수행한다.
    - review the design: 설계담당자가 수행한다.
    - execute a performance test: 테스트담당자가 수행한다.
  - artifacts
    - 유스케이스, 디자인 모델 등
    - 모델의 구성요소
    - 비즈니스 케이스, 소프트웨어 아키텍처와 같은 문서
    - 소스코드
    - 실행파일
  - workflows
    - engineering
      - business modeling
        - 조직의 구조와 기능을 이해하기 위한 과정이다.
        - 고객과 엔드유저, 개발자들이 조직에 대한 이해를 공유할 수 있다.
        - 조직을 지원하기 위해 필요한 요구사항을 추출할 수 있다.
      - requirements
        - 시스템이 무엇을 해야하는가에 대한 고객과 사용자의 동의를 획득하는 것이 목적이다.
        - 개발자에게 시스템의 요구사항에 대해 충분히 이해를 시킬 수 있다.
        - 시스템의 기능을 정의할 수 있다.
        - 반복의 계획과 기술적인 내역을 위한 기초를 제공한다.
        - 시스템을 개발하는데 필요한 시간과 비용을 측정하기 위한 기초를 제공한다.
        - 시스템의 ui를 정의할 수 있다. 
      - analysis, design
        - 시스템을 구현하는 방법을 기술하는 사양을 추출하는 것이 가장 큰 목적이다.
        - 요구사항을 이해하고 최적의 구현전략을 선택함으로써 시스템 설계에 반영해야 한다.
        - 이해하기 쉽고 구축하기 쉽고 발전시키기 쉬운 설계를 위해서는 초기단계에 튼튼한 아키텍처를 설정해야한다.
        - 설계를 구현환경에 알맞게 수정하는 작업을 그 다음 수행한다.
        - 이 과정에서 성능, 안정성, 확장성, 테스트 가능성을 고려해야 한다.
      - implementation
        - 계층화된 서브시스템의 관점에서 코드의 체계를 정의한다.
        - 컴포넌트로 클래스와 객체를 구현한다.
        - 개발된 컴포넌트의 단위테스트를 수행한다.
        - 개발된 컴포넌트를 하나의 실행가능한 시스템으로 통합한다.
      - test
        - 객체와 컴포넌트간의 상호작용을 검증한다.
        - 소프트웨어를 구성하는 모든 컴포넌트가 올바르게 통합도었는지 검증한다.
        - 모든 요구사항이 올바르게 구현되었는가 검증한다.
        - 소프트웨어가 배포되기 전에 결함을 인식해 해결할 수 있다.
      - deployment
        - 소프트웨어의 완성된 릴리즈를 생산 및 조립한다.
    - supporting
      - project management
      - configuration, change management
      - environment
        - toolsmithing을 한다.
      
## 20.08.2020

- nextjs
  - document
    - document가 정의되는 시점은 csr이 시작되었을 떄이다. 아직 렌더링이 끝나지 않아 document가 정의되지 않았는데 dom을 조작하려고 한다면 **document is not defined**와 같은 에러가 발생한다.
    - modal 창을 띄우고 없애는 것 또한 dom 조작이므로 컴포넌트가 마운트된 후에 해야 한다.
    - `pages/_document.js`를 수정하면 전체적인 페이지에 해당 수정을 적용할 수 있다. 특정한 문서에서 특정한 문서구조를 갖게할 수도 있다.
    - `render()`에서 반환하는 값이 html 태그를 포함하는 전체 문서이면 된다.
      ```js
      import Document, { Head, Main, NextScript } from 'next/document'

      export default class CustomDocument extends Document {
        render() {
          return (
            <html>
              <Head>
                {/* global head에 적용시킬 코드를 넣는다. */}
              </Head>
              <body>
                <Main /> {/* 각각 라우트에 해당하는 페이지가 렌더링 되는 부분이다. */}
                <NextScript /> {/* nextjs 관련한 자바스크립트 파일이다. */}
              </body>
            </html>
          )
        }
      }
      ```
  - app
    - 초기에 기본 페이지들의 컴포넌트로 사용된다. 
    - 페이지들이 변화할때 레이아웃을 유지해준다.
      ```js
      const Layout = ({ children }) => {
        return (
          <div className="layout">{children}</div>
        )
      }

      const App = ({ Component, pageProps }) => {
        return (
          <Layout>
            <Component {...pageProps} />
          </Layout>
        )
      }
      ```
    - 페이지를 이동할때 상태를 유지해준다.
    - 에러를 관리해준다.
      ```js
      class MyApp extends App {
        componentDidCatch (err, info) {
          console.log(err)
          super.componentDidCatch(err, info)
        }
      }
      ```
    - 페이지들에 추가데이터를 사용가능하다.
  - link
    - default
      ```js
      <Link href={href}><a>{children}</a></Link>
      ```
    - replace: pushState 대신에 사용한다.
      ```js
      <Link href={href} replace><a>{children}</a></Link>
      ```
    - querystring
      ```js
      <Link href={{
        pathname: href,
        query: {
          querystring1: querystrings[0],
          querystring2: querystrings[1],
        }
      }}><a>{children}</a></Link>
      ```
  - router
    - attributes
      - route: 현재경로이다.
      - pathname: querystring을 포함한 전체 경로를 말한다.
      - query: querystring이 파싱되어 저장된 객체로 기본값은 `{}`을 갖는다.
      - push: 주어진 url 파라미터에 따라 `pushState()`를 호출한다.
      - replace: 주어진 url 파라미터에 따라 `replaceState()`를 호출한다.
      ```js
      <span onClick{() => Router.push(href)}>{children}</span>
      ```
    - events
      - `routeChangeStart(url)`: 라우팅이 시작될때 호출된다.
      - `routeChangeComplete(url)`: 라우팅이 끝나면 호출된다.
      - `routeChangeError(err, url)`: 라우팅 도중 에러 발생시 호출된다.
      - `beforeHistoryChange(url)`: 브라우저 내의 히스토리가 바뀌기 직전에 호출된다.
      - `appUpdated(nextRoute)`: 페이지가 업데이트 되었는데 새 버전의 애플리케이션이 사용가능한 경우 호출한다.
      ```js
      // pages/*
      
      Router.onRouteChangeStart = url => console.log(url)
      Router.onRouterChangeError = (err, url) => console.log(err, url)
      ```
  - css
    - jss
      ```js
      <style jsx>{`
        .some-container {
          padding: 0;
        }
      `}</style>
      ```
    - global stylesheet
      ```js
      import styles from './styles.css'

      export default () => {
        <div className={styles.someContainer}></div>
      }
      ```
    - dangerouslySetInnerHTML
      ```js
      <style dangerouslySetInnerHTML={{
        __html: `
          html {
            padding: 0;
          }
        `
      }}>
      ```
    - webpackloader
      ```js
      import './main.scss'
      ```
  - scripts
    - `-p` 옵션으로 포트를 지정할 수 있다.

- apollo
  - 캐시, 분석 도구까지 제공하고 플러그인이 많은 graphql 클라이언트이다.
  - react가 렌더링될 때 데이터를 로드하고 쿼리에서 사용하는 변수가 바뀌면 다시 로드한다.
  - 데이터, 로딩, 에러를 상태로 관리해줘 react-hooks와 잘어울린다.
  - 타입별 id 기반 캐시를 사용한다. 데이터에 식별자가 꼭 있어야 가능하다.
  - 페이지가 렌더링되면 캐시에 있는 데이터를 먼저 로드한 후에 네트워크로 조회한 데이터로 갱신한다.
  - `FetchPolicy`에서 캐시와 네트워크 설정을 할 수 있다.
  - 로컬상태를 graphql로 관리해 redux, mobx를 대체할 수 있다.
  - 컴포넌트에서 사용할 쿼리를 뽑아 호출하고 페이지 렌더링할 때 로컬캐시로 제공한다.
  - ssr을 적용할 쿼리와 아닌 쿼리를 구분 가능하다.
  - 여러번 나눠 호출하는 쿼리를 하나로 합칠 수 있다.
  - 요청이 최적화되는 장점이 있지만 가장 느린 쿼리가 응답할때까지 기다린다는 단점이 있다.
  - ssr에서는 batch를 사용하고 csr에서는 batch를 끄면 좋다.
  - 단일 엔드포인트에 post방식으로 필요한 쿼리를 매번 요청한다.
  - 이 방식은 유연하고 편하지만 캐시와 오버헤드 문제가 있다. post는 네트워크 캐시를 사용할 수 없고 거대한 쿼리는 매번 오버헤드이다.
  - `PersistedQueries`는 요청을 hash key로 치환해 get방식을 사용한다. 캐시가 사용가능하고 거대한 쿼리를 사용하지 않아도 된다. 
  - 요청하는 사람이 응답할 데이터를 정의할 수 있다는 특징때문에 mock을 작성하는 것이 굉장히 유연하다. 
  - 필요한 데이터를 mock 데이터로 미리 만들어 작업하고 백엔드 개발이 완료되면 타입스크립트의 리팩토링 기능으로 변수명을 맞춰주면 된다.

- storybook
  - 공통 컴포넌트를 개발하기 위해서 임의의 페이지를 만들어야 한다. 이것을 위한 개발환경이다.
  - 디자인이 깔끔하고 사용법이 쉬워 공통 컴포넌트를 개발하거나 갤러리 용도로 사용하기 좋다.

- styled-component
  - pros
    - 주석기능
      - `//#region style`, `//#endregion`으로 스타일 코드를 감싸면 접었다 펼 수 있다.
    - 컴포넌트
      - 컴포넌트별로 스타일을 분리해서 관리가능하다.
      - 클래스 이름을 자동으로 생성해 중복문제가 해결된다.
      - 여기를 고치면 저기가 망가지고 저기를 고치면 여기가 망가지는 일이 없다.
    - css 코드 최적화
      - 페이지에서 사용하는 컴포넌트의 스타일만 사용한다.
      - 불필요한 스타일은 제거한다.
    - 자바스크립트 사용
      - css를 코딩할 수 있다.
      - 변수나 함수를 만들고 자바스크립트 코드와 상수를 공유할 수 있다.
      - 테스트 코드 작성이 가능하다.
      - 타입스크립트를 이용한 자동완성을 지원한다.
    - 벤더사 지원
      - `-moz`, `-webkit`을 자동으로 붙여준다.
  - cons
    - 페이지 로드시 자바스크립트를 분석해 css를 생성한다.
    - css 생성시 오버헤드가 크다. 
    - 렌더링되는 시점에 스타일 코드가 추가된다.
    - css 파일을 캐시할 수가 없다.
    - head 영역이 아닌 body 영역에 렌더링된다. 스타일 없는 컴포넌트가 렌더링되고 스타일이 뒤늦게 적용된다. ssr을 통해 극복할 수 있다.
    
## 24.08.2020

- n-api
  - native add-on을 빌드하기 위한 api이다.
  - v8처럼 js runtime으로부터 독립적이다.

- deno
  - v8 엔진, rust를 기반으로 하는 javascript, typescript용 runtime 환경이다.
  - based technology
    - v8 javascript runtime
    - rust (replaced cpp)
    - tokio (event loop)
    - typescript
  - nodejs의 단점
    - 중앙 배포식의 잘못 설계된 모듈 시스템
    - 지원해야하는 상당수의 레거시 api
    - 퍼미션 없이 리소스 읽기/쓰기가 가능해 보안이 부족함
  - features
    - es module만 사용
      - nodejs는 비표준격인 commonjs로 로드했지만 deno는 표준방식을 사용한다.
      - deno 자체가 패키지 매니저 역할을 하며 서드파티 모듈을 위한 중앙 저장소가 없다.
      - nodejs처럼 npm서버에 장애가 발생하거나 인터넷이 되지 않는 환경도 deno는 캐싱되어있는 모듈이 있으면 바로 사용가능하다.
        ```js
        import {serve} from 'https://{module_path}'
        ```
    - enhanced security
      - sandbox 환경으로 외부자원에 접근시 반드시 퍼미션을 명시해야 한다.
      - 실행시에 제한된 권한만 부여하며 의도하지 않은 일이 일어나지 않도록 지정한다.
        - --allow-read
        - --allow-write
        - --allow-net
        - --allow-env
        - --allow-run
        - -A, --allow-all
        - --allow-read=/tmp 혹은 --allow-net=google.com 처럼 세부적인 설정도 가능함
      - nodejs의 경우 포착되지 않는 오류가 발생하더라도 계속 허용함으로써 버그가 발생한 포인트를 찾지 못하지만 deno는 프로세스를 중지한다.
    - built-in typescript
      - 복잡한 ts 개발환경을 만들 필요없이 기본적인 환경을 제공한다.
    - top level await in supported
      - 탑레벨 코드에서 async로 감싸주는 것 없이 바로 await 처리가 가능하다.
    - browser compatible
      - 브라우저 호환성을 중시한다.
      - nodejs에서 fetch를 써야하는 상황에서는 의존성을 추가해야하지만 일반 브라우저에서는 fetch가 내장되어있다.
      - deno는 브라우저 호환성을 위해 api 환경이 브라우저와 동일하게 구성되어있다.
    - sample code
      - get, post, put을 이용한 간단한 api 서버 구성
        ```ts
        import {Application, Router} from 'https://deno.land/x/oak/mod.ts'
        import router from './routes.ts'

        const app = new Application()

        app.use(router.routes())
        app.use(router.allowedMethods())

        await app.listen({ port: 5000 })
        ```
      - 임시적으로 메모리에 배열로 저장하는 코드 작성해서 요청이 올때마다 내용을 전달해준다.
        ```ts
        // router.ts
        import { Router } from "https://deno.land/x/oak/mod.ts";
        import { v4 } from "https://deno.land/std/uuid/mod.ts";
        import { Book } from "./types.ts"
        
        const books: Book[] = [
            {
                id : v4.generate(),
                title : "Book One",
                author : "One"
            },
            {
                id : v4.generate(),
                title : "Book Two",
                author : "Two"
            },
            {
                id : v4.generate(),
                title : "Book Three",
                author : "Three"
            }
        ]

        const router = new Router()

        router
          .get('/', ctx => {
            ctx.response.body = 'Hello World'
          })
          .get('/book', ctx => {
            ctx.response.body = books
          })
          .post('/book', async ctx => {
            const body = ctx.request.body()

            if (!ctx.request.hasBody) {
              ctx.response.status = 400
              ctx.response.body = 'No data'
            } else {
              const book: Book = await body.value
              book.id = v4.generate()
              ctx.response.status = 201
              ctx.response.body = book
            }
          })
          .get('/book/:id', async ctx => {
            const book: Book | undefined = books.find(b => b.id === ctx.params.id)

            if (book) {
              ctx.response.status = 200
              ctx.response.body = book
            } else {
              ctx.response.status = 404
              ctx.response.body = 'Not found'
            }
          })

        export default router
        ```

## 25.08.2020

- javascript
	- mouseover/out: 지정된 요소는 물론이고, 자식요소가 있다면 해당 자식요소의 영역까지 포함된다.
	- mouseenter/leave: 지정되 요소의 영역에만 해당되며, 만약 자식요소가 있다면 해당 자식요소의 영역은 제외된다.

## 26.08.2020

- nextjs
  - `_document`
    - custom document를 만들때만 사용하며 생략된 경우 nextjs가 기본값을 사용한다.
      ```js
      import Document, { Head, Main, NextScript } from 'next/document'

      export default class RootDocument extends Document {
        render () {
          return (
            <html>
              <Head>
                <meta charSet="utf-8" />
                <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no" />
                <meta name="description" content="description"/>
                <meta name="keywords" content="keywords" />
                <link rel="manifest" href="/static/manifest.json" />
                <link rel="shortcut icon" href="/static/favicon.ico" />
                <link rel="stylesheet" href="path" />
              </Head>
              <body>
                <Main />
                <NextScript />
              </body>
            </html>
          )
        }
      }
      ```
  - `_app`
    - 공통 레이아웃을 작성할 수 있다.
    - error boundary로 에러를 조작할 수 있다.
    - routing 된 경우 progressing 처리를 할 수 있다.
  - `_error`
  - routing
    - csr: `Router.push()`
      - 아래와 같은 방법으로 버튼을 통해 어떤 경로로 간다면 url에는 qs가 붙고, `router.query.history`에 정보가 남는다.
        ```js
        <button onClick={() => Router.push('/?history=foo')} />
        ```
    - ssr: `<Link href='/'></Link>`
    - as 속성으로 url params를 아래와 같이 숨길 수 있다. 하지만 이 방법에 있는 문제라면 새로고침을 한 경우 `router.query.history`가 비어있으므로 전달 받을 인자를 받지 못하게 된다.
      ```js
      // csr
      <button onClick={() => Router.push('/?history=foo', '/')} />

      // ssr
      <Link href="/?history=foo" as="/" />
      ```
    - `withRouter`로 컴포넌트를 감싸주면 props로 `router`를 받아서 사용할 수 있다.

## 27.08.2020

- typescript
  - partial: 인터페이스의 모든 프로퍼티를 optional하게 변경한다.
  - required: 인터페이스의 모든 프로퍼티를 required하게 변경한다.
  - pick: 인터페이스의 프로퍼티 중 일부만 받도록 설정한다.
    ```ts
    type PickFoo = Pick<IFoo, 'foo' | 'bar'>
    const pickFoo = PickFoo = {
      foo: 'foo', // required
      bar: 'bar', // required
      // baz: 'baz' --> (x)
    }

    type PickFoo2 = Pick<IFoo, 'foo' | 'bar'> & Pick<Partial<IFoo>, 'baz'>
    const pickFoo2: PickFoo2 = {
      foo: 'foo', // required
      bar: 'bar', // required
      baz: 'baz' // optional
    }
    ```
- sub-partial: 특정 속성만 제거할 수 있다.
  ```ts
  interface IPerson {
    foo: string
    bar: string
    baz: string
  }
  
  type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>
  type SubPartial<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>

  type Person = SubPartial<ISubPartial, 'foo'>
  let person: Person
  ```
- diff: 앞의 조건에 부합하면 `X`가 정의되고, 그렇지 않다면 `Y`가 정의되는 타입이다. 두 타입이나 객체 사이에서 다른 것을 추릴때 가장 기본이 된다. 기준이 되는 앞의 타입과 뒤에 정의한 타입 사이에 겹치지 않는 결과물만 정의되었다. 
  ```ts
  type Diff<T, U> = T extends U ? never : T

  type DiffExample = Diff<'a' | 'b' | 'c' | 'd', 'a' | 'c' | 'f'> // 'b' | 'd'
  ```
- omit
  ```ts
  type Omit<T, U extends keyof T> = Pick<T, Exclude<keyof T, K>>

  type OmitExample = Omit<{
    a: 'string',
    b: 'number',
    c: 'symbol'
  }, 'b' | 'c'> // { a: 'string' }
  ```
- dig: pick 타입은 특정 인터페이스의 원하는 키만 뽑아서 새 타입을 만들때 유용하지만 중첩된 객체의 형식으로 있을 때 그 내부를 뽑아쓰기 힘들어서 중첩된 객체를 파낸다는데서 착안해서 dig라고 한다. 동작 특성상 중첩 객체 탐색용으로 쓰는 것이 좋고 평상시에는 pick 타입만으로도 충분하다.
  ```ts
  type Dig<T, U extends keyof T> = Pick<T, U>[U]
  ```
- overwrite: 주어진 인터페이스를 활용하면서 특정 속성만 새로운 타입으로 덮어씌우고 싶을때 사용한다. 기존 `extends`, `&`로는 제대로 동작하지 않는다. 인터페이스의 `extends`는 애초에 에러가 발생하며, `&`는 예상하지 못한 결과가 나온다. `&` 기호는 새로운 속성을 덧붙일때만 써야한다. 속성을 덮어씌우기 위해 먼저 정의된 타입의 key를 빼버리고 우리가 새로 덮어쓸 정의와 합쳐주면 된다.
  ```ts
  type A = {
    a: string
    b: string
  }

  type Overwrite<T, U> = {
    [P in Diff<keyof T, keyof U>]: T[P]
  } & U

  type B = Overwrite<A, { b: number }>

  const b: B = {
    a: 'foo',
    b: 100 // No error
  }

  ```
- sub-type: 특정 타입을 입력하면 그에 맞는 속성-타입 쌍을 추리는 헬퍼 타입이다. 어떤 인터페이스에서 `string` 타입만 가지고 있는 속성만 추릴 수 있다.
  ```ts
  type SubType<BaseType, ConditionType> = Pick<BaseType, {
    [Key in keyof BaseType]: BaseType[Key] extends ConditionType ? Key : never
  }[keyof BaseType]>
  ```
  - 참고로 이런 타입은 함수 시그니처도 인식한다.
    ```ts
    type PersonLoader = SUbType<Person, (_: any) => any>
    /**
     * { load: () => Promise<Person> }
     */
    ```

- nextjs
  - 주소창이나 외부링크를 통해 해당페이지를 접속하면 `getInitialProps` 함수를 포함해 렌더링 함수가 ssr 처리가된다.
  - 렌더링 함수가 같은 코드여도 해당 페이지에 어떻게 접속하냐에 따라 서버단에서 실행될 수도 있고 클라이언트 단에서 실행될 수도 있다.
  - 다만 `getInitialProps` 함수는 ssr에서만 실행되는 서버사이드 스크립트이며 렌더링 전에 실행된다.
  - `getInitialProps`를 이용해 서버에서 처리할 수 있는 작업들을 미리 처리한다면 시스템 성능을 끌어올릴 수 있다.
  - 해당 페이지에 접속했을 때 특정조건을 만족못해 다른 페이지로 리디렉션해야한다면 굳이 현재페이지의 렌더링 작업이 필요하지 않다. 그래서 서버단에서 리디렉션을 처리하면 더욱 빠르게 다른 페이지로 이동할 수 있게 된다.
  - Link
    - `prefetch`를 사용하면 데이터를 먼저 불러온 다음에 라우팅을 시작한다. `getInitialProps`와 연관있을 것 같다.

## 28.08.2020

- html
  - repaint
    - 레이아웃에는 영향을 주지 않지만 가시성에 영향을 주는 엘리먼트가 변경되면 발생한다.
    - 예를 들어 opacity, background-color, visibility, outline 등이 있다.
    - 브라우저가 dom 트리에 있는 다른 모든 노드의 가시성을 확인해야하므로 리페인트는 비용이 많이 든다고 한다.
  - reflow
    - 모든 엘리먼트의 위치, 길이 등을 다시 계산하는 것으로 문서의 일부 혹은 전체를 다시 렌더링한다.
    - 단일 엘리먼트 하나를 변경해도 하위 엘리먼트나 상위 엘리먼트에 영향을 미칠 수 있다.

- react
	- fragment
		- 여러개의 컴포넌트를 리턴할 때 불필요한 div 생성을 줄이기 위해 사용한다.
		- map함수와 배열을 렌더링할때도 유용하다. 배열 렌더에 필요한 key를 가질 수 있기때문이다.
		- 하위 컴포넌트에서 div로 컴포넌트 내의 엘리먼트에 flex, grid를 주는데도 유용하다.

- media queries
	- subtractive
		- 처음엔 가장 큰 해상도로 시작한다.
		- 감소한다는 이름을 가졌지만 기반 스타일에 overriding하기 위해 더 많은 css 코드를 쳐야한다.
	- additive
		- 처음엔 가상 작은 해상도로 시작한다.
		- 더 적은 css가 불러와지므로 ux에 좋다.


- typescript
	- additional type
		- tuple
  		- 기본적인 성격은 array와 동일하다. 차이점은 요소로 가질 수 있는 타입이 여러가지로 나뉠 수 있다는 점이다.
  		- 1, 2번째 요소는 각각 boolean, number여야 하지만 그 뒤의 요소는 그냥 `boolen || number`이면 된다.
  		- ts tuple은 요소 추가, 삭제, 수정이 자유롭지만 python의 tuple처럼 고정된 크기의 배열로 사용하는 것(immutable)이 바람직한 사용법이다.
      ```ts
      let tuple: [boolean, number] = [true, 0]
      tuple.concat([false, 1])
      tuple.push('string') // 'string' is not assignable
      ```
		- any: js 기반의 프로그램을 만드는 경우 어쩔 수 없이 사용하는 경우가 종종 있다.
		- void: `null || undefined`로 리턴이 가능하다.
		- never
  		- 그 어떤 값도 할당할 수 없다.
  		- 함수에 할당하는 경우 도달 불가능한 부분이 있어야 타입체크를 통과한다.
  		- 예를 들어 항상 에러를 호출하거나 무한루프가 호출된 함수여야 한다.
        ```ts
        const alwaysError = (): never => {
          throw new Error()
        }
        const infiniteLoop = (): never => {
          while(true) {}
        }
        ```
		- enum: 타 언어에서 보던 enumeration과 흡사하다.
		- union: `any`보다 나은 점이라면 어쨌든 타입을 제한할 수 있고 intellisense가 지원된다는 점이 있다.
		- unknown: `any`처럼 어떤 타입을 값을 초기화하건 괜찮다. 
	- interface vs. type alias
  	- type alias를 이용해 타입에 새로운 이름을 붙일 수 있다. 인터페이스로는 이것을 표현하는 것이 불가능하다.
  	- type alias는 실제로는 새 타입을 생성하지 않는다.
    	- `type User = { name: string }`에서 에러가 발생하면 `User` 대신 `{ name: string }`이 메시지에 등장한다.
    	- `interface User { name: string }`에서 에러가 발생하면 `User`가 메시지에 등장한다.
  	- 인터페이스는 `extends` 키워드를 이용해 확장할 수 있는 반면 type alias의 경우 그런 수단을 제공하지 않는다.
  	- 결론은 항상 type alias보다는 인터페이스를 사용할 것을 건장한다.
  	- 인터페이스로 표현할 수 있는 모든 타입은 인터페이스로 표현하고, 기본 타입에 새로운 이름을 붙이고싶거나 유니온 타입을 명명하고싶은 경우만 type alias를 사용한다.

- styled component
	- mixin: 스타일 시트 전체에서 재사용할 css 선언그룹을 정의하는 기능이다.
		```js
		const someCss = css`
			box-shadow: 0 4px 6px blue, 0 1px 3px blue
		`	
		const SomeBOx = styled.input.attrs({
			type: 'checkbox',
			checked: true
		})`
			border-radius: 5px
			${someCss}
		`
		```
		- `ThemeProvider`로 제공된 테마를 적용하는 방법으로 `App.js`에서 `ThemeProvider`, `theme`을 import한 뒤 컴포넌트 최상단에 삽입한다.
			```js
		   const theme = {
			   mainColor: 'red',
			   dangerColor: 'blue',
			   successColor: 'gray'
		   }
			
		   export default theme
			```

## 29.08.2020

- component
  - 응집도
    - rep(Reuse/Release Equivalence Principle) 
      - 재사용 단위는 릴리즈 단위와 같다.
      - 컴포넌트를 잘 분리하고, 재사용을 위해 릴리즈 버전 관리를 잘하자는 원칙이다.
    - ccp(Common Closure Principle)
        - 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶고, 반대인 경우는 다른 컴포넌트로 분리해야 한다.
        - 같은 이유로 변경될 가능성이 있는 클래스를 한 곳으로 모으라는 말이다.
        - 변경사항이 생겼을 때 여파를 최소화하기 위해 전략적으로 폐쇄해야 한다.
        - 클래스 단위에서는 ocp를, 컴포넌트 단위에서는 ccp가 기반 원칙이 된다.
    - crp(Common Reuse Principle)
      - 컴포넌트 사용자들을 필요하지 않는 것에 의존하도록 강요하지 말아야 한다.
      - 없어도 될 의존성을 컴포너트 사이에 두지 않도록 분리해야 한다.
      - 같이 재사용하는 경향이 있는 클래스와 모듈은 같은 컴포넌트에 포함하라는 의도가 있다.
  - 결합
    - adp(Acylic Dependencies Principle)
      - 컴포넌트 의존성 그래프에 순환이 있어서는 안된다.
      - 어떤 컴포넌트에서 시작하더라도 의존성 관계를 따라가면 최초의 컴포넌트로 돌아가지 않게 되어야 한다. 사실상 3개의 컴포넌트가 순환하는 관계를 가지면 하나의 거대한 컴포넌트가 되버린다. 
      - 때문에 분리, 테스트, 빌드도 어려워진다. 특히 빌드 순서를 명확히 알기 어렵다.
        <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FOeTag%2FbtqGRROjK3W%2F7KmY8sCc5Xwpc3SASwzFp0%2Fimg.png" width="500">
      - 아래와 같은 방법으로 의존성 순환 문제를 풀 수 있다. 이 방법들은 sdp에 위배되는 경우에도 똑같이 적용된다. 의존성 방향을 제어하는데 일반적으로 사용하는 방식이라고 할 수 있다.
        - 의존성 역전 원칙
          <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FZGYld%2FbtqGG0Nhpvl%2FLKNkAICpEp44rvUCrE6DM1%2Fimg.png" width="500">
        - 새로운 컴포넌트를 만드는 것
          <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FZGYld%2FbtqGG0Nhpvl%2FLKNkAICpEp44rvUCrE6DM1%2Fimg.png" width="500">
    - sdp(Stable Dependencies Principle)
      - 안정성의 방향으로 의존해야 한다.
      - 안정된 컴포넌트 x가 있다고 치자. 3개의 컴포넌트를 책임지지만 x가 의존하는 컴포넌트가 없으면 독립적이라고 한다.
        <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FC1rmk%2FbtqGK4nmazW%2FK7KqtdbLzBZt2Y0Xn74E8k%2Fimg.png" width="500">
      - y는 상당히 불안정한 컴포넌트이다. 어떤 컴포넌트도 y에 의존하지 않으므로 y는 책임성이 없다고 할 수 있다. y는 3개의 컴포넌트에 의존하므로 변경이 발생할 수 있는 요인이 3가지가 된다. y는 이 경우 의존적이라고 말한다.
        <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb08aCb%2FbtqGPOdnZkL%2FjL5MNeCybmKQHLe8eenx2k%2Fimg.png" width="500">
      - 변경이 쉽지 않은 컴포넌트가 변동이 예쌍되는 컴포넌트에 의존하게 만들어서는 안된다. 한 번 의존하면 변동성이 큰 컴포넌트도 결국 변경이 어려워진다. 
      - sdp를 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않게 만들 수 있다.
      - 아래처럼 의존성 방향이 안정된 컴포넌트로 향하는 것이 좋다.
        <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FrBJ1l%2FbtqGHwyJbR4%2FUOkBt3DpqCVpALjMjad810%2Fimg.png" width="500">
    - sap(Stable Abstractions Principle)
      - 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.
      - 안정성과 추상화 정도 사이의 관계를 나타낸다.
      - 일반적으로 고수준의 아키텍처나 정책 결정에 관련된 소프트웨어는 안정도 높은 컴포넌트에 배치한다.
      - 안정도가 높은 컴포넌트는 변경하기 어렵다.
      - 변경하기 어려우므로 유연하지 않고 확장하기 어렵다.
      - 즉 인터페이스와 추상 클래스로만 구성한 컴포넌트를 만드는 것이다. 컴포넌트에 dip를 적용하는 것이다.

## 30.08.2020

- solid: 함수와 데이터 구조를 클래스로 배치하는 방법, 클래스간 결합하는 방법을 설명한다. 변경에 유연하고, 이해하기 쉽고, 컴포넌트의 기반이 되는 것을 목적으로 한다.
  - srp: (Single Responsibility Principle)
    - 하나의 모듈, 하나의 함수는 하나의 일만 해야한다.
    - 액터란 이해관계를 가진 변경을 요청하는 집단을 말한다.
    - 코드는 이 단일 액터만을 책임질 수 있도록 묶어야 한다.
  - ocp: (Open-Closed Principle)
    - 확장하기 쉽도록 만든다.
    - 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 한다.
    - 시스템을 컴포넌트 단위로 분리하고 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조를 짜야 한다.
    - srp, dip가 잘되어있으면 ocp도 잘 지킬 수 있다.
  - lsp: (Liskov SUbstitution Principle)
    - 추상 클래스의 서브 타입 클래스들은 서로 치환이 가능해야 한다.
    - 애초에 인터페이스와 상속관계를 잘 생각하면 lsp를 잘지키는 셈이다.
    - oop에서 이것이 클래스 수준이라면, 아키텍처에서는 모듈, 서비스, 컴포넌트 단위가 된다. rest api에서는 uri가 일종의 인터페이스가 된다. 즉 통신하는 하위 서비스들은 uri 형식을 잘 지켜야 한다.
  - isp: (Interface Segregation Principle)
    - 자신이 사용하지 않는 메서드에 의존관계를 맺지 않고 분리시켜야 한다.
    - 아래에서 메서드들은 모두 Ops라는 클래스 한 곳에 모여있다. User1 입장에서는 사용하지 않을 메서드가 Ops에 다 모여있는 셈이다.
      <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcNI9Y2%2FbtqGH2Xgz44%2FhPvSgx0KmKfbD6X0Ivpoyk%2Fimg.png" width="500">
    - 각 클래스는 자기가 사용하는 메서드만 가지고 있는 객체를 사용한다. 아래처럼 분리시켜놓으면 훨씬 유연하고 결합도가 낮아진다. 또한 불필요한 컴파일과 재배포를 막을 수 있다.
      <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbLwuG4%2FbtqGG9ivFkq%2F9M6VCK0GKEGIMGWxQ7kbV0%2Fimg.png" width="500">
  - dip: (Dependency Inversion Principle)
    - 의존성은 추상에 의존해야 하며 구체에 의존하지 않아야 한다.
    - 구체적인 요소는 우리가 개발중이라 자주 변경되는 모듈들을 말한다.
    - 변동성이 큰 구체 클래스를 참조하거나 상속하지 않아야 한다.
    - 구체함수를 오버라이드 하지 말아야 한다.

- architecture
  - feature
    - 좋은 아키텍처는 시스템을 쉽게 이해하고, 개발하며, 유지보수하고, 배포할 수 있는 것을 말한다.
    - 아키텍처는 시스템의 동작 여부 자체와는 거의 관련이 없다.
    - 소프트웨어를 유연하고 부드럽게 구조화한다.
    - 좋은 아키텍트는 시스템의 핵심적인 정책을 식별하고, 동시에 세부사항은 이 정책에 무관하게 만들 수 있는 형태로 구축한다.
    - 좋은 아키텍트는 세부사항에 대한 결정을 가능한 한 오랫동안 미룰 수 있는 방향으로 정책을 설계한다.
    - 중요한 것과 중요하지 않은 것을 구분하고, 중요하지 않은 것에 의존하지 않도록 잘 분리해 설계한다.
  - clean architecture
    - 영역: 안쪽으로 갈수록 추상화와 정책의 수준이 높아 고수준이라고 하며, 바깥쪽으로 갈수록 구체적인 세부사항으로 구성되는 저수준이라고 한다.
      <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc1ghLN%2FbtqGWSBfbwh%2FfMMtDCt9pH3P0n91KMpgZk%2Fimg.jpg" width="500">
      - entities
        - 핵심 업무 규칙을 캡슐화한다.
        - 메서드를 가지는 객체거나 일련의 데이터 구조와 함수의 집합일 수 있다.
        - 가장 변하지 않고, 외부로부터 영향받지 않는 영역이다.
      - use cases
        - 애픨리케이션에 특화된 업무 규칙을 포함한다.
        - 시스템의 모든 유스케이스를 캡슐화하고 구현한다.
        - 엔티티로 들어오고 나가는 데이터 흐름을 조정하고 조작한다.
        - 엔티티는 유즈케이스를 절대로 알지 못해야 한다. 이 계층의 변경이 엔티티에 영향을 미쳐서는 안된다. 또한 외부 db, ui같은 외부환경의 변경에 영향받으면 안된다.
      - interface adapter
        - 일련의 어댑터들로 구성한다.
        - 어댑터는 데이터를 유스케이스와 엔티티에 가장 편한 형식 <-> 데이터베이스나 웹같은 외부 에이전시에게 가장 편리한 형식으로 변환한다.
        - 컨트롤러, 프레젠터, 게이트웨이 등이 여기에 속한다.
        - entities, use cases에 가장 편리한 포맷에서 db와 같은 외부에 가장 편리한 포맷으로 변한되는 곳이다.
        - db는 딱 이곳까지만 알아야 한다. use cases, entities에 있는 코드들은 db에 대해 아는 것이 없어야 한다.
      - framework & driver
        - 시스템의 핵심 업무와는 관련없는 세부사항이다. 언제든 갈아끼울 수 있다.
        - 프레임워크나 데이터베이스, 웹서버 등이 여기에 해당한다.
    - 영역의 의존성 방향
      - 의존성 방향은 항상 바깥쪽에서 안쪽 원으로 향해야 한다. 안쪽원은 바깐쪽 원의 어떤 것도 알지 못한다.
      - 하지만 의존성의 방향과 제어 흐름이 반대인 경우가 있다. 이런 경우에는 의존성 역전 원칙을 사용해 해결한다.
      - 즉 유스케이스 내부에 프레젠터의 인터페이스를 정의하고 프레젠터에 이 인터페이스를 구현하도록 만들면 된다.
  - main component
    - 메인 컴포넌트는 가장 낮은 수준의 가장 바깥쪽의 정책이며, 시스템의 초기 진입점이다.
    - 그 어떤 컴포넌트도 이 메인 컴포넌트를 의존하지 않는다.
    - 의존성을 주입하는 일은 바로 이 메인 컴포넌트에서 이뤄져야 한다.
    - 메인은 일종의 config이자 플러그인이라고 볼 수 있다.
    - 따라서 개발용, 테스트용, 프로덕션용 메인 컴포넌트를 따로 두고 필요에 따라 다르게 플러그인 할 수 있다.
  - layer: 계층을 나누는데서 오는 장점은 특정 계층에 대한 수정이 다른 계층에 영향을 거의 주지 않는다는 점이다. 복잡한 수정사항이 생기더라도 어떤 부분을 고치면 될지 금방 파악할 수 있다. 모듈, 패키지, 폴더 구성이 자연스럽게 각 계층별로 트리구조를 이루기때문에 몇달 뒤에 보더라도 그 코드를 이해하고 수정할 수 있다. 
    <img src="https://miro.medium.com/max/1250/1*Y3c0eHFi4SHUJbhdOVdt7g.jpeg" width="500">
    - presentation: 화면의 표시, 애니메이션, 사용자 입력 등 ui에 관련된 모든 처리를 한다.
      - view
        - 직접적으로 플랫폼 의존적인 구현, ui 화면 표시와 사용자 입력만 담당한다.
        - 자기가 화면에 그리는 것이 어떤 의미가 있는지 전혀 알지 못하고 프레젠터의 명령을 ㅂ다아 화면을 어떤 이미지, 색으로 그릴지 결정할 뿐이다.
        - 데이터도 화면의 좌표와 같은 것만 가진다.
      - presenter
        - mvp/viper에서의 프레젠터만을 의미하는 용어가 아니라 넓은 의미의 단어로 생각하면 좋다.
        - mvvm 구조라면 view model과 동일한 단어로 생각할 수 있다.
        - 플랫폼에 직접적으로 의존하지 않는 클래스이다.
        - 따라서 손쉽게 단위 테스트가 가능하다.
        - 화면에 그리는 것이 어떤 의미를 가지는지를 알고 있다.
        - 사용자 입력이 왔을 때 어떤 반응을 해야할지에 대한 판단 역시 프레젠터가 한다.
    - domain
      - user case: 비즈니스 로직이 여기에 구현된다.
      - model: 앱의 실질적인 데이터가 여기에 구현된다. 
      - translater: entity와 domain을 변환하는 mapper 역할을 한다.
    - data
      - repository
        - 관점에 따라 도메인 계층 소속일 수도, 데이터 계층 소속일 수도 있다.
        - 유스케이스가 필요로 하는 데이터 저장/수정 등의 기능을 제공하는 클래스이다.
        - 데이터 소스를 인터페이스 형태로 참조하기때문에 이 클래스에서 데이터 소스 객체를 갈아끼우는 형태로 외부 api 호출, db 접속 등을 전환할 수 있다.
      - data source: 실제 데이터의 입출력이 여기서 일어난다.
      - entity
        - 데이터 소스에서 사용되는 데이터를 정의한 모델로 맨 위의 엔티티와는 다른 개념이다.
        - rest api의 요청/응답을 위한 json, db에 저장하기 위한 테이블이 대표적이다.

- browser 
  - render process
    - dom, ccsom
      - 가장 첫번째 단계는 서버로부터 받은 html, css를 다운받는 일이다.
      - 이것들은 단순 텍스트이므로 연산과 관리가 유리하도록 object model로 만든다.
    - render tree
      - dom, cssom tree를 가지고 render tree를 생성한다.
      - 순수한 요소들의 구조와 텍스트만 존재하는 dom tree와 달리 render tree에는 스타일 정보가 있으며 실제 화면에 표현되는 노드들로만 구성된다.
        <img src="https://blog.kakaocdn.net/dn/lph3J/btqw55WR4Wn/552yhvux3qRnjWJeshq5wK/img.png" width="500">
      - `display: none` 같은 속성의 경우 화면의 어떤 공간도 차지하지 않기떄문에 render tree를 만드는 과정에서 제외된다.
      - 참고로 `visibility: invisible`은 동작은 위와 비슷하지만 공간은 차지하고 요소가 보이지 않게만 하기때문에 render tree에 포함된다.
    - layout
      - 브라우저의 뷰포트 내에서 각 노드들의 정확한 위치와 크기를 계산한다.
      - 노드들이 가진 스타일과 속성에 따라 브라우저 화면의 어느 위치에 어느 크기로 출력할지 계산하는 단계라고 할 수 있다.
      - 이 단계에서 %, vh, em과 같은 상대적인 속성은 실제 화면에 그려지는 pixel 단위로 변환된다.
      - 뷰포트는 그래픽이 표시되는 브라우저의 영역, 크기를 말한다.
    - paint
      - 이전 단계에서 이미 요소들의 위치와 크기, 스타일 계산이 완료된 render tree를 이용해 실제 픽셀 값을 채워넣는다.
      - 이 때 텍스트, 색, 이미지 등 모두 처리되어 그려진다.
      - 이 때 처리해야할 스타일이 복잡할수록 소요시간이 길어진다. `background-color`의 경우 paint 속도가 빠르지만 그라데이션, 그림자 효과 등은 시간이 비교적 더 오래걸린다.
  - optimizing
    - reflow
      - 최종적으로 페이지가 그려진다고 해서 렌더링 과정이 다 끝난 것은 아니다.
      - 액션이나 이벤트에 따라 엘리먼트의 크기나 위치 등을 수정하면 그에 영향을 받는 노드들을 포함해 layout 과정을 다시 수행한다.
      - 이렇게 되면 render tree와 각 요소들의 크기와 위치를 다시 계산한다.
      - reflow가 일어나는 대표 사례는 아래와 같다.
        - 페이지 초기 렌더링 시
        - 윈도우 리사이징 시
        - 노드 추가 혹은 제거
        - 요소의 위치, 크기 변경
        - 폰트 변경과 이미지 크기 변경
    - repaint
      - reflow만으로는 실제 화면에 반영되지 않고 paint 단계를 다시 실행하는 것을 repaint라고 한다.
      - `background-color`, `visibility`와 같이 레이아웃에는 영향을 주지 않는 스타일 속성이 변경된 경우에는 reflow 실행이 필요없으므로 repaint만 수행한다.
    - conclusion
      - reflow가 일언면 repaint도 필연적으로 일어나기때문에 가능하다면 repaint만 발생하는 속성을 사용하는 것이 좋다.
      - left, right, width, height보다는 transform을, visibility, display보다는 opacity를 사용하는 것이 성능 개선이 도움이 된다.
      - 애니메이션이 많거나 레이아웃 변화가 많은 요소의 경우 `position: absolute`나 `fixed`를 사용해 영향을 받는 주변 노드를 줄일 수 있다.
      - 또 다른 방법으로는 애니메이션 시작시 요소를 absolute, fixed로 변경 후 애니메이션이 종료되었을 때 원상복구하는 방법도 도움이 된다.
      - 애니메이션 프레임 수를 줄이는 것도 성능 개선이 도움이 된다.

- cqrs: Command Query Responsibility Segregation. 전통적인 crud 아키텍처 기반에서 앱을 개발 및 운영하다보면 domain model의 복잡도가 증가한다. 달라지는 요구사항을 충족하는 모델을 만드는 것은 점점 어려운 일이 되간다. 명령과 쿼리 작업은 단순 데이터 조회가 대부분인데 이 두 업무를 동일한 domain model에서 처리하면 증가하는 복잡도를 해결하기 위해 분리구현하자는 생각에서 시작되었다. 단점도 있는데 매우 간단한 서비스라면 분리로 인해 서비스 복잡도가 커질 수 있으니 굳이 도입할 필요는 없다. 또한 어떤게 command이고 어떤게 query인지 구분하기 어려운 사용자 인증토큰 발행 로직이나 스택 자료구조의 pop 연산 등이 약간의 문제이다.
  - common
    - db는 분리하지 않고 기존 구조 그대로 유지하고 model layer 부분만 command와 query model로 분리하는 수준으로 간단하게 적용할 수 있다.
    - 이렇게 분리된 model은 각자의 domain layer만 모델링하고 코딩하기때문에 훨씬 단순하게 구현, 적용할 수 있다.
    - 하지만 동일 db 사용에 따른 성능상 문제는 개선하지 못한다.
      <img src="http://www.popit.kr/wp-content/uploads/2016/09/CQRS1.png" width="500">
  - premium
    - 쿼리용 db를 분리해 별도의 broker를 통해 둘 간의 데이터를 동기화 처리하는 방식이다.
    - 이 경우는 데이터를 조회하려는 대상 서비스는 각자 자신의 시스템에 맞는 저장소를 선택할 수 있기때문에 polyglot 저장구조로 구성할 수 있다.
    - 이 경우 모델에 맞게 튜닝할 수 있다는 장점이 있다.
    - 하지만 동기화 처리를 위한 broker의 가용성과 신뢰도가 보장되어야 한다는 리스크가 있다.
      <img src="http://www.popit.kr/wp-content/uploads/2016/09/CQRS2.png" width="500">
  - delux
    - 앱 내의 모든 활동을 이벤트로 전환해서 이벤트 스트림을 별도의 db에 저장하는 방식인 이벤트 소싱을 적용한 구조이다. 
    - 이벤트 스트림을 저장하는 db는 오직 데이터 추가만 가능하고 계속적으로 쌓인 데이터를 구체화시키는 시점에서 그때까지 구축된 데이터를 바탕으로 조회대상 데이터를 작성하는 방법을 말한다.
    - cqrs에 이벤트 소싱이 필수는 아니지만 이벤트 소싱에 cqrs는 필수이다.
      <img src="http://www.popit.kr/wp-content/uploads/2016/09/CQRS3.png" width="500">

- typescript
  - readonly: 속성명 앞에 `readonly` 키워드를 붙여 해당 속성의 재할당을 막을 수 있다.
    ```ts
    const user: {
      readonly a: string;
      b: number;
    } = { a: 'ab', b: 2 }
    user.name = 'cd' // cannot assign to 'a' because it is a constant
    ```
  - fn overloading
    - 함수는 하나 이상의 타입 시그니처를 가질 수 있다.
    - 함수는 단 하나의 구현만을 가질 수 있다.
    - 오버로딩을 통해 여러 형태의 함수 타입을 정의할 수 있지만 실제 구현은 한 번만 가능하므로 여러 경우에 대한 분기는 함수 본문 내에서 이뤄져야 한다.
      ```ts
      function double (str: string): string;
      function double (num: number): number;
      function double (arr: boolean[]): boolean[];

      function double(arg) {
        if (typeof arg === 'string') {
          return `${arg}${arg}`
        } else if (typeof arg === 'number') {
          return arg * 2
        } else if (Array.isArray(arg)) {
          return arg.concat(arg)
        }
      }

      const num = double(3) // number
      const str = double('ab') // string
      const arr = double([true, false]) // boolean[]
      ```
  - this
    - javascript에서는 함수 내부에서의 this 값은 함수가 정의된느 시점이 아닌 실행되는 시점에 결정된다.
    - typescript에서는 함수 내에 this 타입을 명시할 수 있는 수단을 제공한다.
    - 함수의 this 타입을 명시하기 위해 함수의 타입 시그니처에서 매개변수 가장 앞에 this를 추가한다.
    - 이때 this 타입은 타입 시스템을 위해서만 존재하는 가짜 타입이다.
    - this 매겨변수를 추가해도 함수가 받는 인자 수와 같은 실제 동작은 변하지 않는다.
      ```ts
      interface HTMLElement {
        tagNmae: string
      }
      interface Handler {
        (this: HTMLElement, event: Event, cllaback: () => void): void
      }
      let cb: any
      const onClick: Handler = function (event, cb) {
        console.log(this.tagName)
        cb()
      }
      ```
    - this의 타입을 void로 명시하면 함수 내부에서 this에 접근하는 것을 막을 수 있다.
      ```ts
      interface NoThis {
        (this: void): void
      }
      const noThis: NoThis = function () {
        console.log(this.a) // does not exist on type 'void'
      }
      ```

- styled component
  ```tsx
  import React, { useContext } from 'react'
  import styled, { ThemeContext } from 'styled-components'

  const SomeComp = () => {
    const themeContext = useContext(ThemeContext)

    return (
      <Container>
        <Button
          fillColor={themeContext.colors.green}
          textColor={themeContext.colors.white}
        />
      </Container>
    )
  }
  ```