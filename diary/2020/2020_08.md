## 02.08.2020

- oauth2
  - 인증과 권한부여에 관한 기본적인 흐름뿐 아니라 목적에 맞게 확장할 수 있도록 설계되어있다.
  - 서버와 클라이언트 사이에 인증을 완료하면 서버는 권한부여의 결과로 access token을 전송한다.
  - 클라이언트는 access token을 이용해서 접근 및 서비스를 요청할 수 있다.
  - 서버는 access token을 기반으로 서비스와 권한을 확인하며 접근을 허용할지 말지를 결정하고 결과데이터를 클라이언트에게 보낸다.
  - 서버는 access token을 기반으로 클라이언트를 확인하기때문에 session, cookie를 이용해 클라이언트의 상태정보를 유지할 필요가 없다.
  - oauth 2.0은 외부 서비스의 인증 및 권한부여를 관리하는 범용 프레임워크이다.
  - oauth 기반 서비스의 api를 호출할 떄는 http 헤더에 access token을 포함해 요청을 보낸다.
  - 사용자 입장에서는 oauth의 권한 요청 절차는 access token을 획득하는 것이 주요한 목적이며, 서비스 제공자 입장에서는 인증된 사용자에게 access token을 발급하는 것이 가장 중요하다고 할 수 있다.
  - oauth를 구성하고 있는 주요 4가지 역할
    - resource owner: protected resource에 접근하는 권한을 제공한다.
    - resource server: access token을 사용해 요청을 수신할때 권한을 검증한 후 적절한 결과를 응답한다.
    - client: resource owner의 protected resource에 접근을 요청하는 애플리케이션이다.
    - authorization server: client가 성공적으로 access token을 발급받은 이후에 resource owner를 인증하고 obtaining authorization을 한다.
  - 권한 허가를 위한 절차
    - client가 resource owner에게 authoriation request를 한다. 이 떄 권한 요청은 resource owner에게 직접하거나 resource server를 통해 간접적으로 할 수도 있다.
    - resource owner가 권한을 허가하면 client는 권한증서를 발급받는다.
      - 권한증서는 자원소유자가 자원에 접근할 수 있는 권한을 부여했다는 확인증으로 client가 access token을 얻어오는데 사용한다. 아래와 같은 4가지 타입이 있다.
        - authorization code: client가 resource owner에게 직접 권한부여를 요청하는 대신 resource owner가 authorization server에서 인증을 받고 권한을 허가한다. 소유자가 권한을 허가하면 권한코드가 발급된다. 이 코드를 client에게 전달한다. client는 이 코드를 권한 서버에 보내주면서 자신이 권한을 허가받았다는 사실을 알리고 access token을 받는다. 이 방법은 보안상 이점이 있다. access token을 바로 client에 전달하지 않기때문에 잠재적인 유출위험을 방지할 수 있다.
        - implicit: 권한코드를 간소화한 절차이다. 권한코드 방식에서 access token을 얻기위한 중간 매개체로 권한코드를 사용했던 것과는 달리, 이 방식은 권한코드를 발급하지 않고 access token을 바로 발급한다. 대신 보안성이 떨어진다.
        - resource owner password credentials: 자원소유자의 계쩡 아이디와 비밀번호같은 계쩡 인증정보가 access token을 얻기위한 권한증서로 사용된다. 계정정보를 애플리케이션에 직접 입력해야 하므로 신뢰할 수 있어야 한다. access token을 얻은 후에는 리소스요청을 위해 아이디, 비밀번호를 client가 보관하고 있을 필요는 없다.
        - client credentials: client 인증방식이라고도 한다. 자원소유자가 유저가 아닌 client인 상황에 활용한다. client가 관리하는 리소스에만 접근할 경우 권한이 한정된 경우 활용할 수 있다. client는 곧 resource owner인 상황이다. client는 자기를 인증할 수 있는 정보를 authorization server에 보내면서 access token을 요청한다.
    - authorization grant를 받은 client는 최종 목적인 access token을 권한서버에 요청한다.
    - 요청을 받은 authorization server는 client가 보내온 권한증서의 유효성으 검증한다. 유효하다면 access token을 발급하고 결과를 client에게 알려준다.
    - access token을 받은 client는 resource server에 자원을 요청할 수 있게 된다.
    - 요청을 받은 resource server는 access token의 유효성을 검증하고 유효하다면 요청을 처리해준다.
  - 결론
    - authorization code, implicit은 서비스에 접근하는 외부 앱을 위한 방법이다. 
    - authorization code는 자신만의 서버를 갖고 동작하는 서비스인 경우에 적합하다.
    - implicit은 백엔드없이 순수 client에서만 동작하는 앱의 경우에 적합하다.
    - client credentials를 사용하고자 한다면 firebase같은 paas를 사용하는 것이 좋다.
    - resource owner password credentials는 자신의 authorization server에 접속해 인증하기때문에 clinet id, secret을 하드코딩하게 된다. 

## 05.08.2020

- clean-code
  - 본인이 짠 코드에 자신이 없을 경우, 측정할 수 있는 무언가를 통해 자신감이나 만족감을 얻고싶은 욕구를 느낀다. 대표적으로 엄격한 lint, 네이밍 규칙, 폴더구조, 중복제거 등이 그렇다.
  - 중복제거를 자동화할 수는 없지만 연습을 통해 능력을 개선할 수는 있다.
  - 보통 리팩토링 후에 코드의 양이 줄거나 늘었다는 것을 따지기 십상이다.
  - 결과적으로 중복을 제거한 것은 코드에 대한 객관적인 지표를 개선시킨 것처럼 느끼게 만든다. 
  - 함수나 클래스로 로직을 분리해 코드를 심플하게 만드는 것은 좋은 일이다. 
  - 단지 이것은 프로그램의 복잡도를 낮추고자 하는 시도일 뿐이며, 코드가 어떻게 바뀔지 모르는 상황에서 피해를 최소한으로 줄이고자 하는 방어전략 중 하나일 뿐이다. 얽매이지 말아야 한다.


## 09.08.2020

- design-pattern
  - adapter: 서로 다른 두 클래스가 있고, 이 둘은 그대로 둔 채로 이 둘의 인터페이스를 연결하고자 어댑터 클래스를 만들어 사용하는 구조를 말한다. 이미 정의된 인터페이스를 수정하기 어려운 상황에 사용하기 좋다.
    <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbAgRVy%2FbtqDF1ayTFc%2FijlsiFtlo4ykPMx0kMxTy0%2Fimg.png">
  - composite: 여러개의 클래스가 크게보면 같은 요소에 속하지만, 여기에 속한 어떤 클래스가 다른 클래스를 가질 수 있는 구조를 말한다. 부모자식 관계를 나타내고 싶은 경우에 사용하기 좋다.
    <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb9RGse%2FbtqDH1gnUiN%2F494imhovd8kWrLhxGE2lsK%2Fimg.png">
  - decorator: 각각 기능을 담당하는 클래스들과 이 기능을 적용할 클래스를 분리한 뒤에 필요에 따라 동적으로 각 기능을 적용할 수 있는 구조를 말한다. 경우에 따라 부가적인 기능을 추가하거나 빼고 싶을 때 사용한다.
    <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbBRrjm%2FbtqDGfzDLPS%2FaV6YcRuKqvAvvng46TYvjk%2Fimg.png">
  - proxy: 구체적인 업무를 담당하는 클래스에 접근하기 전에 간단한 사전 작업처리를 하는 클래스를 두는 구조를 말한다. 주요 기능이 요청을 받아 수행하기 전에 이 요청에 대한 부가적인 전처리를 수행하는 로직을 세우고 싶을 때 사용한다.
    <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FYZKDU%2FbtqDGJmYL7U%2FrYiDgcf7dWYQzlHHKXw3Vk%2Fimg.png">

- refactoring
  - 코드에서 나는 악취
    - 명료하고 정확하지 않은 이름
      - 변수, 함수, 클래스, 파일명 모두 해당한다.
      - 이름이 항상 무엇을 하는지 명확히 드러내야 한다. 
    - 중복 코드
      - 3번 이상 등장하는 코드가 있다면 어떻게든 한 곳으로 모아준다.
    - 긴 함수, 클래스, 매개변수
      - 길수록 보기 어렵고 이해하기 어렵다.
      - 길다는 건 너무 많은 역할을 담당하고 있다는 것이다. 쪼개거나 묶어야한다.
    - 전역 데이터
      - 전역데이터는 어디서든 건드릴 수 있고 누가 바꿨는지 찾아내기 힘들다.
    - 추측성 일반화
      - 나중에 필요할거라는 생각으로 작성한 로직과 코드는 실제로 사용하지 않는 경우가 많다.
      - 실제로 사용하면 다행이지만 그렇지 않다면 이해와 복잡도를 증가시킬 뿐이다.
    - 주석
      - 항상 나쁘지는 않다. 주석은 필요한 경우 코드에 향기를 입힌다.
      - 장황한 설명이 달린 주석은 코드를 잘못 작성했기때문인 경우가 의외로 많다.
      - 주석보다는 함수나 변수명으로 의도를 명확히 드러내는 것이 좋다.
  - 리팩토링
    - 베이직
      - 함수 추출
        - 목적과 구현을 분리한다.
        - 코드를 보면 어떻게보다 무엇을 하는지 한 번에 알 수 있도록 함수명을 변경한다.
        - 하나의 함수를 한가지 목적만 가지고 한가지일만 해야한다.
        - 한 줄짜리 함수라도 상관없다. 무엇을 하는지 드러나야 한다.
        - 함수의 길이는 한 눈에 들어와야 한다.
        - 두 번이상 사용될 코드는 함수로 만든다.
        - 함수명이 짓기 어려우면 주석으로 먼저 무슨 일을 하는지 적어둔다.
        - 코드 자체로 무엇을 하는지 명확히 보인다면 굳이 추출하지 않는다.
      - 변수 추출
        - 복잡한 표현식은 과정을 나누어 표현한다.
        - 각 과정을 잘 드러내는 임시변수를 사용한다.
        - 변수이름을 문맥에 맞게 잘 짓는다.
        - 문맥은 함수, 클래스 내부, 전역 등에 따라 달라지므로 어떻게 사용할지 생각하고 지어야한다.
        - 추출하지 않아도 그 자체로 명확히 보인다면 추출하지 않는게 좋다.
      - 매개변수 객체 생성
        - 몰려다니는 데이터 무리를 데이터구조 하나로 모아준다.
        - 데이터구조를 묶으면 데이터 사이의 관계까 아주 명확해진다.
        - 객체를 만드는 것은 어떤 개념을 추상화하는 것이다.
        - 변수를 하나의 객체로 묶어 하나의 개념을 만들어내고, 이것은 더 나은 디자인을 만들 수 있다.
          ```py
          # before
          def amount_invoiced(start_date, end_date):
            pass
          def amount_recevived(start_date, end_date):
            pass
          def amount_overdue(start_date, end_date):
            pass
          
          # after
          def amount_invoiced(date_range):
            pass
          def amount_recevived(date_range):
            pass
          def amount_overdue(date_range):
            pass
          ```
      - 여러 함수를 클래스로 묶기
        - 클래스로 묶으면 함수들이 공유하는 공통환경과 목적을 명확히 표현할 수 있다.
        - 또한 함수 매개변수를 줄여 호출을 더 간결하게 만들 수 있다.
        - 원하는 함수를 클래스 단위로 빠르게 찾을 수 있다.
          ```py
          # before
          def base(reading):
            pass
          def taxableCarge(reading):
            pass
          def calculate_base_charge(reading):
            pass

          # after
          class Reading:
            def __init__(self, reading):
              self.reading = reading
            def base(self):
              pass
            def taxableCarge(self):
              pass
            def calculate_base_charge(self):
              pass
          ```
    - 캡슐화
      - 레코드 캡슐화
        - 곳곳에 쓰이는 가변데이터는 레코드가 아니라 객체로 저장해야 한다.
        - 데이터구조를 명확히 표현할 수 있고, 코드 한 곳에서 관리하고 표현할 수 있게 된다.
      - 임시변수를 질의함수로 변경
        - 곳곳에 쓰이는 임셔변수 메서드를 만들어 굳이 임시변수를 만들지 않아야한다.
      - 클래스 추출
        - 개발과정에서 점점 비대해지는 클래스를 적절히 분리한다.
        - 단일 책임 원칙을 잊지 말아야한다.
        - 일부 데이터와 메서드를 따로 묶을 수 있다면 분리하라는 신호이다.
        - 함께 변경되는 일이 많거나 의존하는 데이터들도 분리한다.
        - 개발중 일부 기능만을 사용하기 위해 서브클래스를 만들어야 한다면 클래스를 나눠야 한다는 신호이다.
        - 리팩토링을 거치면서 쓸모 없어진 클래스는 이과정을 반대로 한다.
    - 기능 이동
      - 문장 슬라이딩
        - 관련된 코드들이 가까이 모여있다면 이해하기 쉽다.
        - 데이터 구조를 이용하는 문장들은 한데 모여야 그 쓰임을 정확히 알 수 있다.
        - 함수 첫머리에 변수를 몽땅 선언하기보다 처음 사용할때 선언하는 것이 좋다.
        - 관련된 것들은 한데모아두어야 추가 리팩토링을 하기 쉽다.
      - 반복문 쪼개기
        - 하나의 반복문은 하나의 일만 해야 이해하기도 관리하기도 쉽다.
        - 한 반복문에 두가지 일을 하면 두가지 일 모두 이해해야 하고 수정할때도 신경써야한다.
        - 성능최적화는 당장 고려하지 않는다.
        - 성능적으로 문제가 있다는게 밝혀지면 그때 다시 합치면 된다.
        - 코드분리는 또 다른 최적화나 디자인 패턴의 길을 열어주기도 한다.
          ```py
          # before
          average_age = 0
          total_salary = 0
          for person in people:
            average_age += person.age
            total_salary += person.salary
            
          average_age = average_age / len(people)

          # after
          total_salary = 0 
          for person in people: 
            total_salary += person.salary 

          average_age = 0 
          for person in people: 
            average_age += person.age 

          average_age = average_age / len(people)
          ```
    - 조건부 로직 간소화
      - 조건문 분해
        - 긴 조건문은 의도를 드러낼 수 있는 함수로 추출해 로직을 명확히 해야한다.
      - 조건식 통합
        - 하나로 합칠 수 있는 조건식은 합친 뒤에 의도를 드러낼 수 있는 함수로 추출한다.
      - 특이케이스 추가
        - 특수한 경우 공통 동작을 요소 하나에 모아서 사용하면 관리하기 쉽다.
        - 일반적으로 특정 값에 대해 똑같이 반응하는 코드가 여러 곳이면 그 반응을 한데로 모으는게 효율적이다.
        - 모으는 것은 리터럴 객체나 따로 정의한 클래스에 모을 수 있다.
        - 데이터를 담기만 하는 경우 리터럴 객체를 쓰면 되고, 어떤 동작을 수행해야하면 클래스로 추출하면 된다.
        - null object 패턴이라고도 한다.
      - 어셔선 추가
        - 어떤 상태임을 가정한채 실행되는지 다른 개발자에게 알려주는 소통 도구이다.
        - 어서션이 있고 없고가 프로그램의 정상 동작에 아무런 영향을 주지 않도록 작성되어야 한다.
        - 다시 말해 실패해서는 안된다. 실패한다면 어딘가 잘못 구현한 코드가 있다는 뜻이다.

- highcharts
  - title: 테이블 상단에 보이는 텍스트
    <img src="https://www.highcharts.com/docs/chart-concepts/titleandsubtitle.png">
  - series: 차트에 보여지는 데이터의 계열
    <img src="https://www.highcharts.com/docs/chart-concepts/linewidth_demo.png">
  - tooltip: 차트 계열을 호버링하면 값
    <img src="https://www.highcharts.com/docs/chart-concepts/tooltip.png">
  - legend: 그래프에서 데이터 계열을 보여주고 하나 이상의 계열을 켜고 끌 수 있게 해준다.
    <img src="https://www.highcharts.com/docs/chart-concepts/legend.png">
  - axes: 차트의 x, y축으로 다른 데이터 계열을 여러 축을 보여줄 수 있다. 게이지같은 경우는 1개의 축을, 파이차트같은 경우는 축이 없다.
    <img src="https://www.highcharts.com/docs/chart-concepts/axis_description.png">

## 10.08.2020

- smb(Server Message Block)

- d3
	- svg를 사용해 커스텀이 용이하다.
	- 비표준 규격 플롯을 그릴 수 있다.
	- 저수준까지 공부할 자신이 있다면 커스텀을 다양하게 할 수 있다.	
	- dc같은 d3로 작성한 라이브러리가 있다.
	- 너무 저수준이라는 것이 단점이다. 따라서 시간을 많이 쏟을 수밖에 없다.
- highcharts
	- css 스타일시트를 추가하기 용이하며 svg를 사용해 그린다.
	- 다양한 옵션으로 커스텀이 용이하다.
	- psd에서도 웹에 그린 디자인과 같은 디자인으로 그릴 수 있다.
	- 툴팁 통합이 용이하다.
	- 다른 차트로 동기화시키는 것이 용이하다.
	- 문서가 훌륭하다.
	- 광범위한 표준 규격 플롯을 그릴 수 있다.
	- cross-filter를 지원하지 않는다.

- svg(Scalable Vector Graphic)
	- ms의 vml, apple의 pgml 대신 w3c에 채택된 표준 벡터 그래픽 기술이다.

- esb(Enterprise Service Bus)
  - 비즈니스 내에서 서비스, 애플리케이션, 자원을 연결하고 통합하는 미들웨어라고 할 수 있다.
  - 이를 통해 분산된 서비스 컴포넌트를 쉽게 통합, 연동할 수 있어 신뢰성있는 메시지 통신이 가능하다.
  - 물리적 컴퓨터 버스와 매우 유사한 기능을 제공하지만 훨씬 높은 추상화 수준을 제공하므로 버스라는 단어를 쓴다.
  - soa를 실현하는 플랫폼으로 사용할 수 있다.