## 01.04.2020

- aws
  - code-star
    - 특징
      - 서버 구성, 빌드, 배포, 모니터링을 위한 통합 서비스이다.
      - 배포 환경의 서버 인프라 구성을 자동화하고자 한다면 적합하다.
      - 빌드 결과물을 생성하기 위해 jenkins 서버를 따로 운영한다면 좋은 대안이다.
      - 빌드를 위한 운영 비용을 줄이는데 좋다.
    - 과정
      - 프로세스 생성
        - ec2나 eb를 통해 용량 프로비저닝, 로드밸런싱, 크기조정부터 모니터링까지 배포를 자동으로 처리할 수 있다.
        - code-commit을 통해 안전한 git 저장소를 쉽게 호스팅할 수 있다. 소스코드에서 바이너리까지 모든 것을 안전하게 저장할 수 있고, 기존 git도구와 원활하게 연동할 수 있다.
      - 빌드
        - code-build를 통해 소스코드를 컴파일하는 단계부터 테스트 실행 후 소프트웨어 패키지를 배포한느 단계까지 마칠 수 있는 완전관리형 빌드 서비스이다.
      - 배포
        - code-pipeline
          - 코드 변경이 있을 때마다 사용자가 정의한 릴리즈 프로세스 모델에 따라 빌드, 테스트 및 배포가 가능하다.
          - 소스 저장소에 변경내역을 감지하는 것을 시작으로 배포하기까지의 일련의 흐름을 관리한다.
          - 애플리케이션을 짧은 주기로 지속적으로 통합하고 전달할 수 있도록 도와준다.
          - 기능과 업데이트를 신속하고 안정적으로 제공할 수 있다.
          - 지속적 전달과정에서 여러가지 테스트를 할 수 있는데, ui테스트, 로드테스트, 통합테스트, api안정성 테스트 등이 포함될 수 있다.
          - 온프레미스에서는 힘들었지만, 클라우드에서는 테스트용으로 여러개의 환경을 생성하고 복제하는 작업을 효율적인 비용으로 손쉽게 자동화할 수 있다.
      - 모니터링
        - cloud-watch를 이용해 지표를 수집 및 추적하고, 로그 파일을 통해 경보설정을 하고 aws 리소스 변경에 자동으로 대응이 가능하다.

## 02.04.2020

- push notification
  - app
    - `expo-permissions`을 호출하고, 푸시 api 엔드포인트를 상수로 선언한다.
    - 알림을 받기 위한 알림, 메시지를 상태로 선언한다.
    - 푸시알림 토큰을 서버에 등록하는 메서드를 만든다.
    - 서버에 토큰을 요청하기 전에 인가된 상태인지 확인하는 상태를`Permission.askAsync()`로 받아온다.
    - 인가되었다면 토큰을 `Notifications.getExpoPushTokenAsync()`로 받아온다.
    - 토큰이 적절하다면 엔드포인트를 사용해 등록을 위해 서버로 요청을 보낼 것이다.
    - 요청에는 토큰과 사용자를 객체에 담아 보낸다.
    - 토큰이 등록되면 애플리케이션에서 발생할 알림을 위한 event listener를 만든다.
    - 새로운 알림이 수신될 떄마다 event handler가 실행된다.
    - 나중에 렌더에서 사용하기 위해 콜백에 전달된 새로운 알림을 상태에 넘겨주면 된다.
    - 상태가 변경될때마다 렌더할 수 있도록 한다.
    - 보낼 메시지를 상태에 담아 보내는 코드도 작성한다.
  - server
    - 푸시알림을 보내주는 `expo-server-sdk`를 호출한다.
    - 앱에 등록된 토큰을 저장하기 위한 배열을 선언한다.
    - 서버에는 두 개의 엔드포인트가 필요하다.
      - 토큰을 등록하기 위한
      - 앱에서 메시지를 받아오기 위한
    - 토큰 등록함수를 작성한다.
    - 앱에서 받은 메시지를 푸시알림을 보내는 함수를 작성한다.
      - 토큰 배열을 순회하면서 토큰을 검증한다.
      - 검증된 토큰으로 메시지를 보낸다.
    - 메시지 배열을 받아오면 expo 서버로 전송한다.
    - expo 서버에 등록된 모든 기기에 푸시알림을 해준다.
    - `chunckPushNotifications()`, `sendPushNotificationsAsync()`를 통해 expo 서버에서 메시지 배열을 받는다.
    - `POST /token`로 토큰을 받아서 토큰을 수신했다는 응답을 반환한다.
    - `POST /message`로 메시지를 받아서 expo 서버로 전송해준다.

## 03.04.2020

- functional
  - 쓰기작업에서 side effect를 없애기 위해 함수 내에 사용하는 모든 변수값을 파라미터로 받고, 새로운 값을 만들어서 반환하는 순수함수를 사용한다.
  - 아래와 같은 3종류의 함수를 input/output으로 연결해 섞어쓰는 것을 composition이라고 한다.
    - generator: 생성자나 get 함수. input은 없고 output만 있는 것
    - function: input, output 모두 있는 것
    - consumer: set 함수. input은 있고 output은 없는 것
  - 데이터가 아닌 흐름에 집중해서 프로그램을 만드는 것이 좋다.
- reactive
  - 비동기 프로그램을 해야할 때 stream으로 연결하고 그것을 흘려보내는 것이 reactive이다.
  - stream 사이에는 다음과 같은 함수들이 있다.
    - observable: 데이터 생성자
    - subscriber: 데이터 처리자
    - operator: 파이프라인에서 데이터 변형자
  - 문자열을 가져오는 `getText()` 함수에 url을 넣어 어떤 데이터를 받을때 return으로 data가 아닌 stream을 준다.
  - stream을 먼저 연결한 뒤, 서버에서 데이터를 가져온다.
  - 데이터가 생기면 그때 stream을 통해 원하는 곳으로 흘려보낸다.

- react
  - ref
    - 포커스, 텍스트 선택영역, 애니메이션, 미디어 재생을 관리할 때 사용한다.
    - 서드파티 dom 라이브러리를 react와 같이 사용할 때 사용한다.
    - 선언적으로 해결할 수 있는 문제에는 `ref` 사용을 지양해야 한다.
    - 애플리케이션에 어떤 일이 일어나게 할 때 사용할 수 있다. 
    - 부모 컴포넌트에서 자식의 dom 노드에 접근하려는 경우 권장하지는 않지만 사용할 수는 있다. 자식의 dom 노드를 포커스 하는 일이나, 크기, 위치를 계산하는 일에 효과적이다.

- data mapper
  - crud 코딩을 상당량 줄일 수 있게 되고, 덩달아 버그도 줄일 수 있다.
  - crud 코드 작성에 소모되는 시간을 줄일 수 있다는 것은 비즈니스 로직 부분 코드를 작성하는데 더 많은 시간을 투자할 수 있다는 것을 의미한다.
  - 테이블이 변경될 때 객체의 변경을 최소화할 수 있다.
  - data mapper는 데이터베이스에서 메모리 위에 있는 개체를 분리하는 레이어이다.

- active record
  - 개체는 데이터와 행동 두 가지를 전달한다.
  - crud와 같이 복잡하지 않은 도메인 로직에서 좋은 선택으로, 단일 레코드 기반의 차이와 검증은 이 구조에서 작업이 수월하다.

## 04.04.2020

- typeorm
  - active record
    - 모델 그 자체에 쿼리 메서드를 지정하고, 모델의 메서드를 사용해 crud하는 방식이다.
    - `BaseEntity`를 갖고 있는 메서드와 static으로 만들어내는 커스텀 메서드를 이용할 수 있다.
    - entity를 직접 다룰 수 있도록 new 키워드를 이용해 새로운 인스턴스를 만들어 사용하는 것이 가능하다.
  - data mapper
    - 모델에 접근하지 않고 repository에서 데이터에 접근하는 것이 다르다.
    - 정의한 클래스를 generic 타입을 이용해 상속하게 한다.
    - `getRepository()`를 사용해 만들어진 모델을 사용한다.

## 06.02.2020

- 프로그래밍 추세
  - 재미/실시간성: 라이브방송, 실시간 댓글, 협업, 메신지 기능이 있다.
  - 독창성/완성도: 애니메이션, 무한스크롤, 벽돌
  - 동시성: 비동기 i/o, csp, stm, actor
  - 반응성/고가용성: elb, auto scaling, otp supervisor
  - 대용량/정확성/병렬성: map-reduce, clojure recuders
  - 복잡도: msa

- oop: 데이터를 먼저 디자인한 후, 데이터에 맞는 메서드를 디자인하는 방식으로 구성된다.
- fp: 함수를 먼저 만들고, 함수에 맞게 데이터셋을 구성하는 방식으로 구성된다.

- csp(Cloud Solution Provider)
  - ms의 클라우드 서비스를 파트너사의 서비스/솔루션과 결합해 제공하는 서비스
  - office 365, azure, dynamics 365 등이 해당된다.
    - dynamics 365: 클라우드 crm/erp 솔루션

- stm(Software Transaction Memory)
  - lock 기반 multi-thread 프로그래밍 대신 새로운 병렬 프로그래밍 모델로 주목받고 있다.
  - db에서 말하는 transaction의 개념을 프로그래밍 언어로 빌려온 것이다.
  - 프로그램 내에서 하나의 단위로 수행되어야 하는 일을 묶어주고, 그 일을 모두 수행하거나 전혀 수행하지 않는다.
  - stm에서는 중간상태가 노출되는 문제가 발생하지 않는다.

- erlang
  - 병행성 분야에서 주류언어에 속하며, db에서 map-reduce의 구현 혹은 dbms의 전체 구현을 위해 많이 사용된다.
  - 채팅, 메시징, 금융시스템, 게임서버와 같은 분야에 이용된다.
  - 실수와 정수형 타입에서 자동 형변환이 있지만 강타입에 동적타입을 따른다고 한다.
- elixir
  - erlang 가상머신인 beam 위에서 동작하는 함수형, 동시성 프로그래밍 언어이다.
  - erlang이 가진 분산처리, 장애 내구성, 실시간, 무정지 애플리케이션 등의 특징을 공유한다.

- meta-programming
  - 자신 혹은 다른 애플리케이션을 데이터로 취급해 프로그램을 작성/수정하는 것을 말한다.
  런타임에 수행해야할 작업의 일부를 컴파일 타임동안 수행하는 프로그램을 말하기도 한다.
  - 동작하는 방식은 아래의 종류가 있다.
    - 런타임 엔진 코드를 api를 통해 프로그램에 노출시키는 방식
    - 문자열 혹은 다른 형태로 된 명령을 동적으로 수행시키는 방식. 프로그램이 프로그램을 작성하게 할 수 있다. 한 언어가 이 두가지 방식을 취할 수도 있으나, 대개 언어들은 둘 중 한 가지 방식으로 치우치는 경향이 있다.
    - 해당 언어의 범주를 완전히 벗어나는 것이다. 범용 프로그램 변환 시스템은 일반적인 메타프로그래밍을 직접 구현한다. 
  - 대표적으로 java, python, go, lisp이 메타프로그래밍이 구현되어 있다.
- synchronocity-programming
  - thread
    - 이것을 이용해 한 프로세스 내에서 두 가지 혹은 그 이상의 일을 할 수 있게 한다.
    - 하나의 주소를 받아 특정 프로그램이 그 process를 사용하게 되지만, thread는 하나의 process 자원을 공유하면서 서로 교차하며 작동한다.
    - thread 간 서로 교차하면서 작동하고, 그 교차점이 빠르기떄문에 사용자는 동시에 진행되는 것처럼 느낀다.

## 07.04.2020

- javascript
  - `every()`
    - 함수의 반환값이 `false`가 되면 콜백함수의 실행이 멈추고 메서드는 `false`를 반환한다.
    - 모든 배열의 원소가 조건을 만족하는지 알고싶다면 사용한다.
  - `some()`
    - 함수의 반환값이 `true`일 때까지만 원소를 계속 반환한다.

- ssr
  - redux
    - 과정
      - universal router가 렌더링될 라우팅 경로를 확인하고 리소스를 가져온다.
      - 가져온 리소스를 스토어에 저장한다.
      - 리소스가 저장된 스토어와 필요한 추가 리소스를 컴포넌트의 props로 전달한다.
      - 컴포넌트를 렌더링한 결과를 html 코드로 반환한다.
      - 서버에서 받은 html 코드로 클라이언트 렌더링을 실행한다.
    - 단점
      - 리소스를 가져오는 로직과 api를 라우팅 경로마다 구현해야 한다.
      - 스토어를 사용하기 위해 액션과 리듀서를 구현해야 한다.
      - 렌더링 절차가 복잡하다.
      - 렌더링에 필요한 모든 리소스를 받을 때까지 렌더링을 실행할 수 없다.
    
    <img src="https://d2.naver.com/content/images/2019/01/helloworld-201811-apollo_02.png" width="500">
  
  - apollo
    - 과정
      - 라우팅 경로에 맞는 컴포넌트를 렌더링한다.
      - 컴포넌트를 렌더링할때 apollo client를 통해 컴포넌트 렌더링에 필요한 리소스를 받은 후 html 코드로 변환한다.
      - 서버에서 받은 html 코드로 클라이언트 렌더링을 실행한다.
    - 장점
      - 라우팅 경로에 상관없이 컴포넌트 별로 필요한 리소스만 가져올 수 있다.
      - 리소스를 가져오는데 시간이 오래 걸리는 컴포넌트는 리소스를 가져오지 않고 렌더링만 실행하고, 클라이언트 렌더링을 실행할 때 리소스를 가져오게 할 수 있다.
      - 라우팅 경로에 의존성이 없어져 재사용 가능한 컴포넌트 개발이 용이해진다.
      - 내부의 분기가 없는 하나의 라우터 코드로 클라이언트 렌더링과 서버 렌더링을 실행할 수 있다.
      - 별도의 액션과 리듀서가 없어도 필요한 리소스를 컴포넌트에서 사용할 수 있다.
    - 단점
      - 중첩된 객체와 객체 배열에 대해서도 스키마를 정의해야 한다. 정의되지 않은 리소스 타입을 요청하거나 반환하면 오류가 발생한다.
      - `react-apollo`를 사용할 때에는 `Content-Type` 요청 헤더의 mime 타입을 `application/graphql`로 설정해서 사용해야 한다. 서버에서도 graphql을 파싱할 수 있는 라이브러리를 사용해야 한다. 기본 제공하는 `application/json`을 사용하면 파싱 오류가 발생한다.
      - `variables` 객체의 속성이 순서가 다르면 별도의 쿼리로 인식하는 문제가 있다. 

    <img src="https://d2.naver.com/content/images/2019/01/helloworld-201811-apollo_03.png" width="500">

- parcel
  - 단점
    - assets 유형으로 번들을 생성하기 때문에 js 안에 css를 포함하도록 하려면 별도의 컴포넌트를 사용해야 한다.
    - 확장자에 따라 번들을 생성하므로 css 파일을 import 해도 `.css`, `.js`를 생성하는데 문제도 있다.
    - 인라인 형식으로 만들려면 styled-component와 같은 별도의 라이브러리를 사용해야 한다.