## 01.04.2020

- aws
  - code-star
    - 특징
      - 서버 구성, 빌드, 배포, 모니터링을 위한 통합 서비스이다.
      - 배포 환경의 서버 인프라 구성을 자동화하고자 한다면 적합하다.
      - 빌드 결과물을 생성하기 위해 jenkins 서버를 따로 운영한다면 좋은 대안이다.
      - 빌드를 위한 운영 비용을 줄이는데 좋다.
    - 과정
      - 프로세스 생성
        - ec2나 eb를 통해 용량 프로비저닝, 로드밸런싱, 크기조정부터 모니터링까지 배포를 자동으로 처리할 수 있다.
        - code-commit을 통해 안전한 git 저장소를 쉽게 호스팅할 수 있다. 소스코드에서 바이너리까지 모든 것을 안전하게 저장할 수 있고, 기존 git도구와 원활하게 연동할 수 있다.
      - 빌드
        - code-build를 통해 소스코드를 컴파일하는 단계부터 테스트 실행 후 소프트웨어 패키지를 배포한느 단계까지 마칠 수 있는 완전관리형 빌드 서비스이다.
      - 배포
        - code-pipeline
          - 코드 변경이 있을 때마다 사용자가 정의한 릴리즈 프로세스 모델에 따라 빌드, 테스트 및 배포가 가능하다.
          - 소스 저장소에 변경내역을 감지하는 것을 시작으로 배포하기까지의 일련의 흐름을 관리한다.
          - 애플리케이션을 짧은 주기로 지속적으로 통합하고 전달할 수 있도록 도와준다.
          - 기능과 업데이트를 신속하고 안정적으로 제공할 수 있다.
          - 지속적 전달과정에서 여러가지 테스트를 할 수 있는데, ui테스트, 로드테스트, 통합테스트, api안정성 테스트 등이 포함될 수 있다.
          - 온프레미스에서는 힘들었지만, 클라우드에서는 테스트용으로 여러개의 환경을 생성하고 복제하는 작업을 효율적인 비용으로 손쉽게 자동화할 수 있다.
      - 모니터링
        - cloud-watch를 이용해 지표를 수집 및 추적하고, 로그 파일을 통해 경보설정을 하고 aws 리소스 변경에 자동으로 대응이 가능하다.

## 02.04.2020

- push notification
  - app
    - `expo-permissions`을 호출하고, 푸시 api 엔드포인트를 상수로 선언한다.
    - 알림을 받기 위한 알림, 메시지를 상태로 선언한다.
    - 푸시알림 토큰을 서버에 등록하는 메서드를 만든다.
    - 서버에 토큰을 요청하기 전에 인가된 상태인지 확인하는 상태를`Permission.askAsync()`로 받아온다.
    - 인가되었다면 토큰을 `Notifications.getExpoPushTokenAsync()`로 받아온다.
    - 토큰이 적절하다면 엔드포인트를 사용해 등록을 위해 서버로 요청을 보낼 것이다.
    - 요청에는 토큰과 사용자를 객체에 담아 보낸다.
    - 토큰이 등록되면 애플리케이션에서 발생할 알림을 위한 event listener를 만든다.
    - 새로운 알림이 수신될 떄마다 event handler가 실행된다.
    - 나중에 렌더에서 사용하기 위해 콜백에 전달된 새로운 알림을 상태에 넘겨주면 된다.
    - 상태가 변경될때마다 렌더할 수 있도록 한다.
    - 보낼 메시지를 상태에 담아 보내는 코드도 작성한다.
  - server
    - 푸시알림을 보내주는 `expo-server-sdk`를 호출한다.
    - 앱에 등록된 토큰을 저장하기 위한 배열을 선언한다.
    - 서버에는 두 개의 엔드포인트가 필요하다.
      - 토큰을 등록하기 위한
      - 앱에서 메시지를 받아오기 위한
    - 토큰 등록함수를 작성한다.
    - 앱에서 받은 메시지를 푸시알림을 보내는 함수를 작성한다.
      - 토큰 배열을 순회하면서 토큰을 검증한다.
      - 검증된 토큰으로 메시지를 보낸다.
    - 메시지 배열을 받아오면 expo 서버로 전송한다.
    - expo 서버에 등록된 모든 기기에 푸시알림을 해준다.
    - `chunckPushNotifications()`, `sendPushNotificationsAsync()`를 통해 expo 서버에서 메시지 배열을 받는다.
    - `POST /token`로 토큰을 받아서 토큰을 수신했다는 응답을 반환한다.
    - `POST /message`로 메시지를 받아서 expo 서버로 전송해준다.

## 03.04.2020

- functional
  - 쓰기작업에서 side effect를 없애기 위해 함수 내에 사용하는 모든 변수값을 파라미터로 받고, 새로운 값을 만들어서 반환하는 순수함수를 사용한다.
  - 아래와 같은 3종류의 함수를 input/output으로 연결해 섞어쓰는 것을 composition이라고 한다.
    - generator: 생성자나 get 함수. input은 없고 output만 있는 것
    - function: input, output 모두 있는 것
    - consumer: set 함수. input은 있고 output은 없는 것
  - 데이터가 아닌 흐름에 집중해서 프로그램을 만드는 것이 좋다.
- reactive
  - 비동기 프로그램을 해야할 때 stream으로 연결하고 그것을 흘려보내는 것이 reactive이다.
  - stream 사이에는 다음과 같은 함수들이 있다.
    - observable: 데이터 생성자
    - subscriber: 데이터 처리자
    - operator: 파이프라인에서 데이터 변형자
  - 문자열을 가져오는 `getText()` 함수에 url을 넣어 어떤 데이터를 받을때 return으로 data가 아닌 stream을 준다.
  - stream을 먼저 연결한 뒤, 서버에서 데이터를 가져온다.
  - 데이터가 생기면 그때 stream을 통해 원하는 곳으로 흘려보낸다.

- react
  - ref
    - 포커스, 텍스트 선택영역, 애니메이션, 미디어 재생을 관리할 때 사용한다.
    - 서드파티 dom 라이브러리를 react와 같이 사용할 때 사용한다.
    - 선언적으로 해결할 수 있는 문제에는 `ref` 사용을 지양해야 한다.
    - 애플리케이션에 어떤 일이 일어나게 할 때 사용할 수 있다. 
    - 부모 컴포넌트에서 자식의 dom 노드에 접근하려는 경우 권장하지는 않지만 사용할 수는 있다. 자식의 dom 노드를 포커스 하는 일이나, 크기, 위치를 계산하는 일에 효과적이다.

- data mapper
  - crud 코딩을 상당량 줄일 수 있게 되고, 덩달아 버그도 줄일 수 있다.
  - crud 코드 작성에 소모되는 시간을 줄일 수 있다는 것은 비즈니스 로직 부분 코드를 작성하는데 더 많은 시간을 투자할 수 있다는 것을 의미한다.
  - 테이블이 변경될 때 객체의 변경을 최소화할 수 있다.
  - data mapper는 데이터베이스에서 메모리 위에 있는 개체를 분리하는 레이어이다.

- active record
  - 개체는 데이터와 행동 두 가지를 전달한다.
  - crud와 같이 복잡하지 않은 도메인 로직에서 좋은 선택으로, 단일 레코드 기반의 차이와 검증은 이 구조에서 작업이 수월하다.

## 04.04.2020

- typeorm
  - active record
    - 모델 그 자체에 쿼리 메서드를 지정하고, 모델의 메서드를 사용해 crud하는 방식이다.
    - `BaseEntity`를 갖고 있는 메서드와 static으로 만들어내는 커스텀 메서드를 이용할 수 있다.
    - entity를 직접 다룰 수 있도록 new 키워드를 이용해 새로운 인스턴스를 만들어 사용하는 것이 가능하다.
  - data mapper
    - 모델에 접근하지 않고 repository에서 데이터에 접근하는 것이 다르다.
    - 정의한 클래스를 generic 타입을 이용해 상속하게 한다.
    - `getRepository()`를 사용해 만들어진 모델을 사용한다.

## 06.02.2020

- 프로그래밍 추세
  - 재미/실시간성: 라이브방송, 실시간 댓글, 협업, 메신지 기능이 있다.
  - 독창성/완성도: 애니메이션, 무한스크롤, 벽돌
  - 동시성: 비동기 i/o, csp, stm, actor
  - 반응성/고가용성: elb, auto scaling, otp supervisor
  - 대용량/정확성/병렬성: map-reduce, clojure recuders
  - 복잡도: msa

- oop: 데이터를 먼저 디자인한 후, 데이터에 맞는 메서드를 디자인하는 방식으로 구성된다.
- fp: 함수를 먼저 만들고, 함수에 맞게 데이터셋을 구성하는 방식으로 구성된다.

- csp(Cloud Solution Provider)
  - ms의 클라우드 서비스를 파트너사의 서비스/솔루션과 결합해 제공하는 서비스
  - office 365, azure, dynamics 365 등이 해당된다.
    - dynamics 365: 클라우드 crm/erp 솔루션

- stm(Software Transaction Memory)
  - lock 기반 multi-thread 프로그래밍 대신 새로운 병렬 프로그래밍 모델로 주목받고 있다.
  - db에서 말하는 transaction의 개념을 프로그래밍 언어로 빌려온 것이다.
  - 프로그램 내에서 하나의 단위로 수행되어야 하는 일을 묶어주고, 그 일을 모두 수행하거나 전혀 수행하지 않는다.
  - stm에서는 중간상태가 노출되는 문제가 발생하지 않는다.

- erlang
  - 병행성 분야에서 주류언어에 속하며, db에서 map-reduce의 구현 혹은 dbms의 전체 구현을 위해 많이 사용된다.
  - 채팅, 메시징, 금융시스템, 게임서버와 같은 분야에 이용된다.
  - 실수와 정수형 타입에서 자동 형변환이 있지만 강타입에 동적타입을 따른다고 한다.
- elixir
  - erlang 가상머신인 beam 위에서 동작하는 함수형, 동시성 프로그래밍 언어이다.
  - erlang이 가진 분산처리, 장애 내구성, 실시간, 무정지 애플리케이션 등의 특징을 공유한다.

- meta-programming
  - 자신 혹은 다른 애플리케이션을 데이터로 취급해 프로그램을 작성/수정하는 것을 말한다.
  런타임에 수행해야할 작업의 일부를 컴파일 타임동안 수행하는 프로그램을 말하기도 한다.
  - 동작하는 방식은 아래의 종류가 있다.
    - 런타임 엔진 코드를 api를 통해 프로그램에 노출시키는 방식
    - 문자열 혹은 다른 형태로 된 명령을 동적으로 수행시키는 방식. 프로그램이 프로그램을 작성하게 할 수 있다. 한 언어가 이 두가지 방식을 취할 수도 있으나, 대개 언어들은 둘 중 한 가지 방식으로 치우치는 경향이 있다.
    - 해당 언어의 범주를 완전히 벗어나는 것이다. 범용 프로그램 변환 시스템은 일반적인 메타프로그래밍을 직접 구현한다. 
  - 대표적으로 java, python, go, lisp이 메타프로그래밍이 구현되어 있다.
- synchronocity-programming
  - thread
    - 이것을 이용해 한 프로세스 내에서 두 가지 혹은 그 이상의 일을 할 수 있게 한다.
    - 하나의 주소를 받아 특정 프로그램이 그 process를 사용하게 되지만, thread는 하나의 process 자원을 공유하면서 서로 교차하며 작동한다.
    - thread 간 서로 교차하면서 작동하고, 그 교차점이 빠르기떄문에 사용자는 동시에 진행되는 것처럼 느낀다.

## 07.04.2020

- javascript
  - `every()`
    - 함수의 반환값이 `false`가 되면 콜백함수의 실행이 멈추고 메서드는 `false`를 반환한다.
    - 모든 배열의 원소가 조건을 만족하는지 알고싶다면 사용한다.
  - `some()`
    - 함수의 반환값이 `true`일 때까지만 원소를 계속 반환한다.

- ssr
  - redux
    - 과정
      - universal router가 렌더링될 라우팅 경로를 확인하고 리소스를 가져온다.
      - 가져온 리소스를 스토어에 저장한다.
      - 리소스가 저장된 스토어와 필요한 추가 리소스를 컴포넌트의 props로 전달한다.
      - 컴포넌트를 렌더링한 결과를 html 코드로 반환한다.
      - 서버에서 받은 html 코드로 클라이언트 렌더링을 실행한다.
    - 단점
      - 리소스를 가져오는 로직과 api를 라우팅 경로마다 구현해야 한다.
      - 스토어를 사용하기 위해 액션과 리듀서를 구현해야 한다.
      - 렌더링 절차가 복잡하다.
      - 렌더링에 필요한 모든 리소스를 받을 때까지 렌더링을 실행할 수 없다.
    
    <img src="https://d2.naver.com/content/images/2019/01/helloworld-201811-apollo_02.png" width="500">
  
  - apollo
    - 과정
      - 라우팅 경로에 맞는 컴포넌트를 렌더링한다.
      - 컴포넌트를 렌더링할때 apollo client를 통해 컴포넌트 렌더링에 필요한 리소스를 받은 후 html 코드로 변환한다.
      - 서버에서 받은 html 코드로 클라이언트 렌더링을 실행한다.
    - 장점
      - 라우팅 경로에 상관없이 컴포넌트 별로 필요한 리소스만 가져올 수 있다.
      - 리소스를 가져오는데 시간이 오래 걸리는 컴포넌트는 리소스를 가져오지 않고 렌더링만 실행하고, 클라이언트 렌더링을 실행할 때 리소스를 가져오게 할 수 있다.
      - 라우팅 경로에 의존성이 없어져 재사용 가능한 컴포넌트 개발이 용이해진다.
      - 내부의 분기가 없는 하나의 라우터 코드로 클라이언트 렌더링과 서버 렌더링을 실행할 수 있다.
      - 별도의 액션과 리듀서가 없어도 필요한 리소스를 컴포넌트에서 사용할 수 있다.
    - 단점
      - 중첩된 객체와 객체 배열에 대해서도 스키마를 정의해야 한다. 정의되지 않은 리소스 타입을 요청하거나 반환하면 오류가 발생한다.
      - `react-apollo`를 사용할 때에는 `Content-Type` 요청 헤더의 mime 타입을 `application/graphql`로 설정해서 사용해야 한다. 서버에서도 graphql을 파싱할 수 있는 라이브러리를 사용해야 한다. 기본 제공하는 `application/json`을 사용하면 파싱 오류가 발생한다.
      - `variables` 객체의 속성이 순서가 다르면 별도의 쿼리로 인식하는 문제가 있다. 

    <img src="https://d2.naver.com/content/images/2019/01/helloworld-201811-apollo_03.png" width="500">

- parcel
  - 단점
    - assets 유형으로 번들을 생성하기 때문에 js 안에 css를 포함하도록 하려면 별도의 컴포넌트를 사용해야 한다.
    - 확장자에 따라 번들을 생성하므로 css 파일을 import 해도 `.css`, `.js`를 생성하는데 문제도 있다.
    - 인라인 형식으로 만들려면 styled-component와 같은 별도의 라이브러리를 사용해야 한다.

## 08.04.2020

- machine learning pipeline
  - load data: data pipeline을 통해 나온 저장소에서 적절하게 데이터를 가져오는 역할을 한다.
  - data analysis: 어떤 데이터가 중요한지, 어떤 특성을 가지고 있는지 전반적으로 살펴본다.
  - feature engineering: 데이터 전처리 단계이다.
  - data validation: 변형된 데이터에 대해 한 번 더 검증을 한다.
  - data split: 머신러닝, 딥러닝 훈련을 위해 데이터를 나눠준다.
  - build & train model: 머신러닝, 딥러닝 모델을 구축하고 훈련을 진행한다.
  - model validation: 모델이 쓸만한지 검증한다.
  - model serving: production 단계나 모델을 저장하는 저장소에 모델을 저장한다.

  <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FcIIJzL%2FbtqC0Le4GNw%2FiBkezVoGrMSIzSId7zRkiK%2Fimg.jpg" width="500">

- react
  - `useCallback()`
    - 현재 하위 컴포넌트에 전달하는 콜백함수를 inline 함수로 사용하고 있다거나, 컴포넌트 내에서 함수를 생성하고 있다면 새로운 함수 참조값을 계속해서 만들고 있는 것이다. 다시 말해 똑같은 모양의 함수를 계속해서 만들어 메모리를 할당하고 있다는 것을 의미한다.
    - 불필요한 함수의 재생성을 막아주는 것이 이것의 역할이다. 최적화에 아주 큰 도움이 된다.
    - 의존성 값이 변경되지 않은 한 메모리에 새로 할당하지 않고, 동일 참조값을 재사용한다.
    - `useEffect()`가 동작하는 원리와 같은 맥락으로 이해할 수 있다.
    - 인라인 함수보다 로컬 함수를 사용하는 것이 메모리 관리에서 더 낫지만, `useCallback()`을 사용하는 것만은 못하다.
    - 하지만, 로컬함수를 감싸고 있는 함수가 리렌더 될 때마다 이 역시 새로 만들어지게 된다는 것을 의미한다.
    - 의존성 배열이 비어있으면 컴포넌트가 최초 렌더링 될 때 한 번만 메모리에 할당된다.
    - 자식 컴포넌트에서 `useCallback()`으로 쓴 핸들러를 props로 물려주면 문제가 생길 수
  - `React.memo`
    - `useCallback()`을 사용하는 것만으로는 하위 컴포넌트의 리렌더를 막을 수가 없다. 
    - 클래스형 컴포넌트에서 `shouldComponentUpdate`를 기본으로 내장한 컴포넌트라고 생각하면 된다.
    - 얕은 비교 연산을 통해 참조값의 prop이 들어오면 리렌더를 방지한다.
    - hoc이므로 컴포넌트를 memo로 한 번 감싸주기만 하면 사용할 수 있다.
    - 또한 커스텀을 원한다면 두 번째 인자로 비교 함수를 넣어 사용할 수 있다.
    
## 09.04.2020

- web app performance
  - 아래의 두 가지는 수정된 렌더 트리를 다시 렌더링하는 과정에서 발생하는 것으로 웹앱의 성능을 떨어뜨리는 주요 원인이다.
  - repaint
    - 레이아웃에는 영향을 주지 않지만, 가시성에 영향을 주는 엘리먼트가 변경되면 발생한다.
      - `opacity`, `background-color`, `visibility`, `outline` 등이 있겠다.
    - 오페라에 따르면, 브라우저가 dom 트리에 있는 다른 모든 노드의 가시성을 확인해야 하므로 리페인트는 비용이 많이 든다고 한다.
  - reflow
    - 모든 엘리먼트의 위치와 길이 등을 다시 계산하는 것으로 문서의 일부 혹은 전체를 다시 렌더링한다.
    - 단일 엘리먼트 하나를 변경해도, 하위 엘리먼트나 상위 엘리먼트 드에 영향을 미칠 수 있다.
    - 리플로우가 트리거가 되는 경우
      - dom 엘리먼트 추가, 제거 혹은 변경
      - css 스타일 추가, 제거 혹은 변경
        - css 스타일을 직접 변경하거나, 클래스를 추가함으로서 레이아웃이 변경될 수 있다. 엘리먼트 길이를 변경하면, dom 트리에 있는 다른 노드에 영향을 줄 수 있다.
      - css 애니메이션과 트랜지션
        - 애니메이션의 모든 프레임에서 리플로우가 발생한다.
      - `offsetWidth`, `offsetHeight`의 사용
        - 위의 속성을 보면, 초기 리플로우가 트리거되어 수치가 계산된다.
      - 유저행동
        - 유저 인터렉션으로 발생하는 `hover` 효과, 필드에 텍스트 입력, 창 크기 조절, 글꼴크기 변경, 스타일시트 또는 글꼴 전환 등을 활성화해서 리플로우를 트리거할 수 있다.
  - 성능 저하를 최소화할 수 있는 방법
    - 클래스 변경을 통해 스타일을 변경할 경우, 최대한 말단 노드의 클래스를 변경한다.
    - 인라인 스타일을 사용하지 않는다.
      - 스타일 속성으 ㄹ통해 스타일을 설정하면, 리플로우가 발생한다.
      - 앨리먼트의 클래스가 변경될 때 엘리먼트는 하나의 리플로우만 발생시킨다.
      - 인라인 스타일은 html이 다운로드될 때, 레이아웃에 영향을 미치면서 추가 리플로우를 발생시킨다.
    - 애니메이션이 들어간 엘리먼트는 `position: fixed`, `position: absolute`로 지정한다.
      - `absolute`, `fixed` 위치인 엘리먼트는 다른 엘리먼트의 레이아웃에 영향을 미치지 않는다. 리페인트가 발생하긴 하지만, 훨씬 적은 비용이 든다.
    - 부드러운 애니메이션이 성능을 저하시킨다.
      - 한 번에 1px씩 움직이면 부드러워 보이지만 성능이 떨어지는 디바이스에서는 문제가 된다.
      - 1px마다 리플로우가 발생하므로, 4px씩 이동하면 리플로우 처리는 1/4만 필요하게 된다.
    - 레이아웃을 위한 table 태그는 피한다.
      - 테이블 태그는 점진적으로 렌더링되지 않고, 모두 불러와지고 계산된 다음에야 렌더링된다. 또한 작은 변경만으로도 테이블의 모든 다른 노드에 대한 리플로우가 발생한다.
      - 레이아웃 용도가 아닌 데이터 표시 용도의 테이블을 사용하더라도, `table-layout: fixed` 속성을 주는 것이 좋다. 그러면 열 너비가 머리글 행 내용을 기반으로 계산되기 때문이다.
    - css에서 js 표현식을 사용하지 않는다.
      - 문서가 리플로우될 때마다 js 표현식이 다시 계산된다.
    - css 하위 셀렉터를 최소화한다.
      - 사용하는 규칙이 적을수록 리플로우가 빠르다.
      - gulp-uncss, grunt-uncss같은 도구로 스타일 정의 및 파일 크기를 줄인다.
    - 숨겨진 엘리먼트를 변경한다.
      - `display: none`으로 숨겨진 엘리먼트는 변경될 때, 리페인트나 리플로우를 일으키지 않는다. 그렇기 때문에 엘리먼트를 표시하기 전에 엘리먼트를 변경한다.
    - js를 통해 스타일을 변경할 경우 아래와 같은 `.cssText` 속성을 사용하거나, 클래스를 변경한다.
      ```js
      let el = document.getElementById('reflow-test');

      el.style.padding = '8px';
      el.style.width = '320px';
      el.style.height = '240px';
      // 3 번의 리플로우 발생

      let el = document.getElementById('reflow-test');

      el.style.cssText = 'padding: 8px; width: 320px; height: 240px;';
      /* or */
      el.className = 'changed';
      // 1 번의 리플로우 발생

      /**
      * Style of `changed` class
      * .changed {
      *   padding: 8px;
      *   width: 320px;
      *   height: 240px;
      * }
      */
      ```

    - js를 통해 리스트를 추가하는 경우, dom fragment를 통해 추가한다.
      - 3개의 리스트를 추가하는 경우, 한 번에 하나씩 추가하면 최대 7개의 리플로우가 발생한다.
        - ul 태그가 추가될때 + li에 대해 3번 + 텍스트 노드에 대해 3번
    - 캐시를 활용해서 리플로우를 최소화한다.
      - 브라우저는 레이아웃 변경을 큐에 저장했다가 한 번에 실행함으로서 리플로우를 최소화하는데, `offset`, `scrollTop`과 같은 계산된 스타일 정보를 요청할 때마다 정확한 정보를 제공하기 위해 큐를 비우고, 모든 변경을 다시 적용한다.
      - 수치에 대한 스타일 정보를 아래와 같이 변수에 저장해 정보 요청 횟수를 줄임으로서 리플로우를 최소화한다.

      ```js
      // Bad practice
      for (let i = 0; i < len; i++) {
        el.style.top = `${ el.offsetTop + 10 }px`;
        el.style.left = `${ el.offsetLeft + 10 }px`;
      }

      // Good practice
      let top = el.offsetTop, left = el.offsetLeft, elStyle = el.style;

      for (let i = 0; i < len; i++) {
        top += 10;
        left += 10;
        elStyle.top = `${ top }px`;
        elStyle.left = `${ left }px`;
      }
      ```

## 10.04.2020

- react
	- `createContext()`
		- 컴포넌트 밖에서 컨텍스트를 생성해서 export가 가능하다.
		- 부모 컴포넌트에서 `.Provider` 안에 집어넣은 값들을 자식 컴포넌트에서 `.Consumer`에서 꺼내서 사용할 수 있다.
		
			```js
			// app.js
			import React, { createContext } from 'react'

			export const AppContext = createContext()
			const App = () => {
				return (
					<AppContext.Provider value={arr}>
					</AppContext>
				)
			}
			export default App

			// child.js
			import React, { createContext } from 'react'
			import AppContext from './app'
			
			const Child = () => (
				<AppContext.Consumer>
					{arr.map((el, idx) => (<div key={idx}>{el}</div>))}
				</AppContext.Consumer>
			)
			```
	- `useContext()`
		- 부모 컴포넌트에서 `createContext()`를 사용하는 것은 마찬가지로 하지만, 자식 컴포넌트에서 컨텍스트를 더 쉽게 가지고 올 수 있는 방법이다.
		- 훅을 사용해서 컴포넌트 리턴 블록이 지저분해지지 않게 도와준다.
		
			```js
			import React, { createContext, useContext } from 'react'
			import AppContext from './app'
			
			const Child = () => {
				const arr = useContext(AppContext)
			
				return (
					<AppContext.Consumer>
						{arr.map((el, idx) => (<div key={idx}>{el}</div>))}
					</AppContext.Consumer>
				)
			}
			```
		- 함수를 실행한 결과를 그대로 넘겨주어야 한다. 아래와 같이 넘겨준다면 에러가 발생한다.
			```js
			import React, { createContext, useContext } from 'react'
			const Context = createContext()

			const Children = () => {
			  const context0 = useContext(Context.Provider) // ERROR!!!
			  const context1 = useContext(Context.Consumer) // ERROR!!!
			  const context2 = useContext(Context) // OK
			}
			```

## 13.04.2020

- typescript
	- readonly
		- class에서 사용할 수 있는 `const` 키워드같은 것으로 해당 property에 새로운 값을 할당하려고 하면 에러가 발생한다.
	- implements
		- 어떤 interface를 이용해 클래스를 선언할 때 쓰는 키워드다.
		- 덕타이핑을 통해 만든 어떤 코드를 컴파일 타임에 에러를 잡아낼 수 있도록 도와준다.

## 14.04.2020

- oop
  - srp: Single Responsibility Principle. 단일 책임의 원칙.
    - 클래스는 한 가지 기능만 가지며, 한 가지 책임을 수행하는데 집중되어야 한다는 원칙이다.
    - 클래스를 여러가지로 분할해 유연하게 설계할 수 있는 장점이 있다.
    - 행동, 책임이 격리되어 사이드이펙트가 발생할 여지가 줄어들어, 그만큼 수정될 코드가 적어진다.
    - 너무 많은 분할로 인해 책임이 여러군데로 파편화된 경우가 생기기도 한다.
    - low coupling
      - 여러가지의 책임으로 나눌 때는 각 책임간의 결합도를 최소로 해야한다.
    - high cohesion
      - 하나에 여러가지 책임이 있는 것의 반대의 상황으로 하나의 책임이 여러군데 분산된 상황이다.
      - shotgun surgery: 하나의 수정사항이 여러군데 영향을 미친 경우 전부 하나로 모아주어 설계를 깔끔하게 유지하는 것을 말한다.
  - ocp: Open Close Principle. 개방폐쇄의 원칙.
    - 컴포넌트, 클래스, 모듈, 함수는 확장에 열려있고, 변경에는 닫혀있어야 함을 원칙으로 한다.
    - 변경에 대한 비용은 줄이면서 확장에 대해서는 가능한 극대화해야 한다는 것으로 코드를 추가하더라도 기존 구성은 변경하지 않으며, 확장에 대한 가능성을 열어줘야 한다는 의미이다.
    - 각 모듈간 호출, 의존에 대해서도 concrete class가 아닌 interface나 abstract class에 의존하도록 설계해야한다.

  - lsp: The Liskov Substitution Principle. 리스코프 치환의 원칙.
  - isp: Interface Segregation Principle. 인터페이스 분리의 원칙.
  - dip: Dependency Inversion Principle. 의존성 역전의 원칙.