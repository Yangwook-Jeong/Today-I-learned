## 02.09.2020

- css
	- position
		- static
			- 요소를 일반적인 문서 흐름에 따라 배치한다.
			- top, right, bottom ,left, z-index 속성이 아무런 영향을 주지 않는다.
		- relative
			- 요소를 일반적인 문서 흐름에 따라 배치한다.
			- 자기를 기준으로 top, right, bottom ,left의 값에 따라 오프셋을 적용한다.
			- 오프셋은 다른 요소에는 영향을 주지 않는다.
			- 페이지 레이아웃에서 요소가 차지하는 공간은 static일 때와 같다.
			- z-index의 값이 auto가 아니라면 새로운 stack context를 만든다.
		- absolute
			- 요소를 일반적인 문서 흐름에서 제거한다.
			- 페이지 레이아웃에 공간도 배정하지 않는다.
			- 대신 가장 가까운 위치 지정 조상 요소에 상대적으로 배치한다.
			- 최종위치는 top, right, bottom, left 값이 지정한다.
			- z-index의 값이 auto가 아니라면 새로운 stack context를 만든다.
		- fixed
			- 요소를 일반적인 문서 흐름에서 제거한다.
			- 페이지 레이아웃에 공간도 배정하지 않는다.
			- 대신 뷰포트의 컨테이닝 블럭을 기준으로 배치한다.
			- 조상 중 하나가 transform, perspective, filter 속성 중 어느 하나라도 none이 아니면 뷰포트 대신 그 조상을 컨테이닝 블럭으로 삼는다.
			- 이 값은 항상 새로운 stack context를 만든다.
		- sticky
			- 요소를 일반적인 문서흐름에 따라 배치한다.
			- 테이블 관련 요소를 포함해 가장 가까운 스크롤되는 조상과 표를 포함한 컨테이닝 블럭을 기준으로 top, right, bottom, left의 값에 따라 오프셋을 적용한다.
			- 이 값은 항상 새로운 stack context를 만든다.

- typescript
	- `<type>` vs. `as type`
		- `<type>`이 키워드가 더 깔끔해보이지만 대개 `as type` 키워드를 추천한다.
		- 해당 변수가 실제로 어떤 인스턴스가 아니더라도 `as` 키워드를 통해 타입 단언을 해줄 수 있기때문에 타입단언은 주의해야한다.
		- 실제로도 `as any`라는 치트키로 대부분의 컴파일 에러를 해결할 수 있다. 
		- 타입단언은 타입을 변경한다는 사실때문에 타입캐스팅과 비슷할 수도 있지만 다르다.
		- 타입 단언은 런타임에 영향을 미치지 않는다. 하지만 타입 캐스팅은 컴파일, 런타임 모두 타입을 벼녕시킨다.
		```ts
		(<Wizard>character).fireball()
		(character as Wizard).fireBall()
		```
	- type guard
		- 타입 단언을 좀 더 깔끔하게 할 수 있도록 도와준다.
		- 타입가드는 런타임에서 타입체크를 컴파일러에게 알려주는 기능을 한다.
		- `var is type`과 같은 문법을 사용해 선언하면 된다.
		```ts
		class Character {
			isWizard(): this is Wizard {
				return this instanceof Wizard
			}
			isWarrior(): this is Warrior {
				return this instanceof Warrior
			}
		}
		```

## 03.09.2020

- react
	- document.getElementById
		- 태그를 직접 다뤄야 하는 경우 유일한 id를 지정하면 getElementById 메서드로 직접 엘리먼트를 호출해 사용할 수 있다.
		```ts
		const handleSubmit = e => {
			e.preventDefault()

			const idRef = document.getElementById('id')
			const passwdRef = document.getElementById('passwd')

			const id = idRef.target.value
			const passwd = passwdRef.target.value
		}

		return (
			<form onSubmit={handleSubmit}>
				<label>
					id:
					<input id='id' type='text' />
				</label>
				<label>
					passwd:
					<input id='passwd' type='password' />
				</label>
				<button type='submit'>sign in</button>
			</form>
		)
		```
	- useRef
		- 간단한 컴포넌트라면 document.getElementById 메서드를 사용할 수 있지만 테이블처럼 반복 컴포넌트인 경우에는 아무래도 한계와 react스럽지 못한 점이 있다.
		```ts
		import React, { createRef, useState } from 'react'

		const User = () => {
			const [idRef, setIdRef] = useState(() => createRef())
			const [passwdRef, setPasswdRef] = useState(() => createRef())

			const handleSubmit = e => {
				e.preventDefault()

				const id = idRef.current.target.value
				const passwd = passwdRef.current.target.value
			}

			return (
				<form onSubmit={handleSubmit}>
					<label>
						id:
						<input ref={idRef} type='text' />
					</label>
					<label>
						passwd:
						<input ref={passwdRef} type='password' />
					</label>
					<button type='submit'>sign in</button>
				</form>
			)
		}
		```
	- useReference
		- createRef 함수로 생성한 state는 직접 엘리먼트를 지정할 일이 없으므로 useState의 2번째 값이 필요가 없다.
		- 따라서 커스텀 훅으로 분리하면 깔끔하게 작성할 수 있다.
		- 참고로 react에서는 기본 훅으로 useRef를 제공해주고 있다.
		```ts
		const useReference = () => {
			const [reference, setReference] = useState(() => createRef())

			return reference
		}
		```
	- forwardRef
		- 하위 컴포넌트의 커스텀 함수를 상위 컴포넌트에서 사용할 수 있도록 해준다.
		- ref 속성은 react에만 있는 속성이기때문에 아래처럼 작성하면 원하는 동작을 하지 않는다.
			```ts
			const User = () => {
				(...)
				return (
					<form>
						<LabelInput text='id: ' type='text' ref={idRef} />
						<LabelInput text='passwd: ' type='password' ref={passwdRef} />
					</form>
				) 
			}
			const LabeledInput = ({ text, type, ref }) => {
				return (
					<label>
						{text}
						<input type={type} ref={ref} />
					</label>
				)
			}
			```
		- 여러가지 방법이 있지만 기본 지원 함수를 이용하는 것이 가장 깔끔한 방법이다.
			```ts
			const User = () => {
				(...)
				return (
					<form>
						<LabelInput text='id: ' type='text' ref={idRef} />
						<LabelInput text='passwd: ' type='password' ref={passwdRef} />
					</form>
				)
			}
			const LabeledInput = forwardRef(({ text, type }, ref) => {
				return (
					<label>
						{text}
						<input type={type} ref={ref} />
					</label>
				)
			})
			```

## 04.09.2020

- memoization
	- 반복되는 결과를 메모리에 저장해서 다음에 같은 결과가 나올때 빨리 실행하는 기법을 말한다.
	- 재귀를 쓸때 같이 사용할 수 있다.
	- 클로저와 커링을 이용해 캐싱을 한다.
	- 메모아이지된 함수는 순수함수이다. 순수함수는 몇번 호출되던 같은 값을 반환한다.
		```ts
		const add = num => num + 10
		add(9) // 19

		const memoizedAdd = () => {
			let cache = {}
			return num => {
				if (num in cache) {
					return cache[num] // fetching from cache
				} else {
					let result = num + 10 // calculating result
					cache[num] = result
					return result
				}
			}
		}

		const newAdd = momoizedAdd()
		newAdd(9) // using caculated
		newAdd(9) // using cached
		```
	- 메모아이즈 함수는 아래와 같이 쓸 수 있다.
		```ts
		const add = n => n + 10

		const memoize = fn => {
			let cache = {}
			return (...args) => {
				let n = args[0] // taking 1 arg
				if (n in cache) {
					return cache[n]
				} else {
					let result = fn(n)
					cache[n] = result
					return result
				}
			}
		}

		const memoizedAdd = memoize(add)
		memoizedAdd(3) // using caculated
		memoizedAdd(3) // using cached
		memoizedAdd(4) // using caculated
		memoizedAdd(4) // using cached
		```
	- 메모아이즈 함수는 어떤 함수든 똑같이 래핑할 수 있다. `lodash.memoize(fn, [resolver])`로 간단하게 사용할 수도 있다.
	- 재귀함수를 메모아이징할 수도 있다. 팩토리얼같은 경우에는 이전에 한 계산을 저장하므로 연산속도가 빨라질 수 있다.
		```ts
		const factorial = memoize(
			x => {
				if (x === 0) {
					return 1
				} else {
					return x * factorial(x - 1)
				}
			}
		)
		factorial(5) // using caculated
		factorial(5) // using cached
		factorial(4) // using cached
		```
	- 메모아이징이 어떤 면에서는 캐싱과 같다. 사실상 캐싱의 한 종류이기도 하다. 반면 캐싱은 일반적으로 http 캐싱같은 테크닉을 말한다.
	- 어느 경우에나 사용할 수 있지만 실제로는 제약이 아래와 같이 있다.
  	- 메모아이징 하는 함수는 항상 순수함수여야한다.
  	- 메모리공간을 소모하는 것과 연산속도를 끌어올리는 것 사이의 트레이드-오프이다. 캐싱된 값을 자주 사용하는 것이 제한된 인풋 범위를 가진 함수에 중요하다.
  	- api 호출을 메모아이징해야할 것처럼 보이지만 브라우저에서는 알아서 캐싱하기때문에 불필요하다.
  	- 무거운 연산작업을 하는데 가장 적합하다. 참고로 팩토리얼이나 피보나치는 실제로 사용하는 예가 아니다.
  	- react/redux를 사용중이라면 reselect를 사용하면 메모아이징된 셀렉터를 사용할 수 있다.

## 07.09.2020

- react
	- `useImperativeHandle`
		- 부모 컴포넌트에서 자식 컴포넌트의 정보를 제공받는 방법이다.
		- 자식 컴포넌트에 ref를 걸어 함수를 호출할 수 있다.
		- ref를 걸 수 있도록 자식 컴포넌트는 forwardRef로 한 번 감싸줘야 한다.
		- forwardRef로 감싼 자식은 props, ref 두 개의 파라미터만 받을 수 있다.
			```ts
			import React, { forwardRef, useImperativeHandle, useRef } from 'react'

			const Child = forwardRef((props, ref) => {
				const alertFoo = () => alert('Foo')

				useImperativeHandle(ref, () => ({ alertFoo }))

				return (
					<div>Foo</div>
				)
			})

			const App = () => {
				const ref = useRef()

				const onClick = () => ref.current.alertFoo()

				return (
					<div>
						<Child ref={ref} />
						<button onClick={onClick}>Foo</button>
					</div>
				)
			}
			```

- nodejs
  - stream
    - 대용량 파일의 경우 파일 전체를 모두 로드하기 전에 메모리 버퍼를 절약하기 위해 다른 행동을 하기 위해 만들어졌다.
    - 기본적으로 읽기 스트림은 data, end, error 이벤트를 가진 `EventEmitter`이다.
    - 파일이 전체로 로드될때까지 기다릴 필요없이 일부를 쓰거나 어떤 처리를 아래와 같이 할 수 있다.
			```ts
			import fs from 'fs'
			import request from 'request'

			const stream = request('http://i.imgur.com/dmetFjf.jpg')
			const writeStream = fs.createWriteStream('test.jpg')

			stream.on('data', data => writeStream.write(data))
			stream.on('end', () => writeStream.end())
			stream.on('error', err => writeStream.close())
			```
		- pipe는 입력을 출력으로 리디렉션할 수 있게 해주는 또 다른 컨셉이다. 위의 코드를 아래ㅗ아 같이 표현할 수 있다.
  		```ts
			import fs from 'fs'
			import request from 'request'

			const stream = request('http://i.imgur.com/dmetFjf.jpg')
			const writeStream = fs.createWriteStream('test.jpg')
			stream.pipe(writeStream)
			```

		- pipe가 하는 일은 pipe로 stream간에 있는 read와 write 이벤트를 연결해주는 것이다. 여러개의 pipe를 서로 연결할 수도 있다.
			```ts
			import gzip from 'zlib'

			stream.pipe(gzip.createGzip()).pipe(writeStream)
			```
		- data 이벤트에 기반한 스트림이 갖는 문제는 stream을 읽는 타이밍이나 한 번에 얼마나 많은 데이터를 읽을지 제어할 수 없다는 점이다.
		- data 이벤트가 걸리면 핸들러는 버퍼에 데이터를 쓰거나 디스크에 정상적으로 써야한다.
		- 이런 상황은 매우 느리거나 제한된 쓰기 i/o를 가진 경우에 문제가 된다.
		- readable stream은 이전 stream 인터페이스와 더불어 readable 이벤트가 추가되었다.
		- 이 이벤트를 통해 읽는 타이밍이나 얼마나 한번에 많이 읽을지 제어할 수 있게 도와준다.
  		```ts
			const stream = fs.createReadStream('./testimg.jpg')
			const writeStream = fs.createWriteStream('./output.jpg')

			stream.on('readable', () => {
				const data = stream.read()
				writeStream.write(data)
			})
			stream.on('end', () => writeStream.end())
			```
		- readable 이벤트가 걸리면 `stream.read()`로 데이터를 읽는 것을 제어할 수 있다.
		- 데이터를 읽을 수 없다면 readable 이벤트는 다시 이벤트 루프에 들어갔다 다시 걸리게 된다.
		- readable stream은 물론 하위 호환성을 갖기때문에 data 이벤트 역시 받을 수 있고, 이 경우 stream은 readable 이벤트를 사용하지 않는다.
		- writable stream은 새로운 drain 이벤트를 사용한다.
		- 이 이벤트는 버퍼에 있는 모든 데이터가 쓰여졌을 때 걸리게 된다. 
		- 이를 통해 버퍼가 비워졌을 때 데이터를 쓸 수 있도록 타이밍을 제어할 수 있다.
  		```ts
			const stream = fs.createReadStream('./input.mp4')
			const writeStream = fs.createWriteStream('./output.mp4')

			const writable = true
			const doRead = () => {
				const data = stream.read()
				writable = writeStream.write(data)
			}

			stream.on('readable', () => {
				if (writable) {
					doRead()
				} else {
					writeStream.removeAllListeners('drain')
					writeStream.once('drain', doRead)
				}
			})
			stream.on('end', () => writeStream.end())
			```
		- 단순히 완료되면 콜백을 던지는 것과 달리 중간중간 결과를 이벤트 방식으로 던져주는 것을 배경으로 탄생했다.
		- 대용량의 데이터를 전달해야 하는 경우에 노드의 이벤트 루프 기반의 stream의 효용이 가장 크게 드러날 수 있다.