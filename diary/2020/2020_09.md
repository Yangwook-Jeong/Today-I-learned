## 02.09.2020

- css
	- position
		- static
			- 요소를 일반적인 문서 흐름에 따라 배치한다.
			- top, right, bottom ,left, z-index 속성이 아무런 영향을 주지 않는다.
		- relative
			- 요소를 일반적인 문서 흐름에 따라 배치한다.
			- 자기를 기준으로 top, right, bottom ,left의 값에 따라 오프셋을 적용한다.
			- 오프셋은 다른 요소에는 영향을 주지 않는다.
			- 페이지 레이아웃에서 요소가 차지하는 공간은 static일 때와 같다.
			- z-index의 값이 auto가 아니라면 새로운 stack context를 만든다.
		- absolute
			- 요소를 일반적인 문서 흐름에서 제거한다.
			- 페이지 레이아웃에 공간도 배정하지 않는다.
			- 대신 가장 가까운 위치 지정 조상 요소에 상대적으로 배치한다.
			- 최종위치는 top, right, bottom, left 값이 지정한다.
			- z-index의 값이 auto가 아니라면 새로운 stack context를 만든다.
		- fixed
			- 요소를 일반적인 문서 흐름에서 제거한다.
			- 페이지 레이아웃에 공간도 배정하지 않는다.
			- 대신 뷰포트의 컨테이닝 블럭을 기준으로 배치한다.
			- 조상 중 하나가 transform, perspective, filter 속성 중 어느 하나라도 none이 아니면 뷰포트 대신 그 조상을 컨테이닝 블럭으로 삼는다.
			- 이 값은 항상 새로운 stack context를 만든다.
		- sticky
			- 요소를 일반적인 문서흐름에 따라 배치한다.
			- 테이블 관련 요소를 포함해 가장 가까운 스크롤되는 조상과 표를 포함한 컨테이닝 블럭을 기준으로 top, right, bottom, left의 값에 따라 오프셋을 적용한다.
			- 이 값은 항상 새로운 stack context를 만든다.

- typescript
	- `<type>` vs. `as type`
		- `<type>`이 키워드가 더 깔끔해보이지만 대개 `as type` 키워드를 추천한다.
		- 해당 변수가 실제로 어떤 인스턴스가 아니더라도 `as` 키워드를 통해 타입 단언을 해줄 수 있기때문에 타입단언은 주의해야한다.
		- 실제로도 `as any`라는 치트키로 대부분의 컴파일 에러를 해결할 수 있다. 
		- 타입단언은 타입을 변경한다는 사실때문에 타입캐스팅과 비슷할 수도 있지만 다르다.
		- 타입 단언은 런타임에 영향을 미치지 않는다. 하지만 타입 캐스팅은 컴파일, 런타임 모두 타입을 벼녕시킨다.
		```ts
		(<Wizard>character).fireball()
		(character as Wizard).fireBall()
		```
	- type guard
		- 타입 단언을 좀 더 깔끔하게 할 수 있도록 도와준다.
		- 타입가드는 런타임에서 타입체크를 컴파일러에게 알려주는 기능을 한다.
		- `var is type`과 같은 문법을 사용해 선언하면 된다.
		```ts
		class Character {
			isWizard(): this is Wizard {
				return this instanceof Wizard
			}
			isWarrior(): this is Warrior {
				return this instanceof Warrior
			}
		}
		```

## 03.09.2020

- react
	- document.getElementById
		- 태그를 직접 다뤄야 하는 경우 유일한 id를 지정하면 getElementById 메서드로 직접 엘리먼트를 호출해 사용할 수 있다.
		```ts
		const handleSubmit = e => {
			e.preventDefault()

			const idRef = document.getElementById('id')
			const passwdRef = document.getElementById('passwd')

			const id = idRef.target.value
			const passwd = passwdRef.target.value
		}

		return (
			<form onSubmit={handleSubmit}>
				<label>
					id:
					<input id='id' type='text' />
				</label>
				<label>
					passwd:
					<input id='passwd' type='password' />
				</label>
				<button type='submit'>sign in</button>
			</form>
		)
		```
	- useRef
		- 간단한 컴포넌트라면 document.getElementById 메서드를 사용할 수 있지만 테이블처럼 반복 컴포넌트인 경우에는 아무래도 한계와 react스럽지 못한 점이 있다.
		```ts
		import React, { createRef, useState } from 'react'

		const User = () => {
			const [idRef, setIdRef] = useState(() => createRef())
			const [passwdRef, setPasswdRef] = useState(() => createRef())

			const handleSubmit = e => {
				e.preventDefault()

				const id = idRef.current.target.value
				const passwd = passwdRef.current.target.value
			}

			return (
				<form onSubmit={handleSubmit}>
					<label>
						id:
						<input ref={idRef} type='text' />
					</label>
					<label>
						passwd:
						<input ref={passwdRef} type='password' />
					</label>
					<button type='submit'>sign in</button>
				</form>
			)
		}
		```
	- useReference
		- createRef 함수로 생성한 state는 직접 엘리먼트를 지정할 일이 없으므로 useState의 2번째 값이 필요가 없다.
		- 따라서 커스텀 훅으로 분리하면 깔끔하게 작성할 수 있다.
		- 참고로 react에서는 기본 훅으로 useRef를 제공해주고 있다.
		```ts
		const useReference = () => {
			const [reference, setReference] = useState(() => createRef())

			return reference
		}
		```
	- forwardRef
		- 하위 컴포넌트의 커스텀 함수를 상위 컴포넌트에서 사용할 수 있도록 해준다.
		- ref 속성은 react에만 있는 속성이기때문에 아래처럼 작성하면 원하는 동작을 하지 않는다.
			```ts
			const User = () => {
				(...)
				return (
					<form>
						<LabelInput text='id: ' type='text' ref={idRef} />
						<LabelInput text='passwd: ' type='password' ref={passwdRef} />
					</form>
				) 
			}
			const LabeledInput = ({ text, type, ref }) => {
				return (
					<label>
						{text}
						<input type={type} ref={ref} />
					</label>
				)
			}
			```
		- 여러가지 방법이 있지만 기본 지원 함수를 이용하는 것이 가장 깔끔한 방법이다.
			```ts
			const User = () => {
				(...)
				return (
					<form>
						<LabelInput text='id: ' type='text' ref={idRef} />
						<LabelInput text='passwd: ' type='password' ref={passwdRef} />
					</form>
				)
			}
			const LabeledInput = forwardRef(({ text, type }, ref) => {
				return (
					<label>
						{text}
						<input type={type} ref={ref} />
					</label>
				)
			})
			```

## 04.09.2020

- memoization
	- 반복되는 결과를 메모리에 저장해서 다음에 같은 결과가 나올때 빨리 실행하는 기법을 말한다.
	- 재귀를 쓸때 같이 사용할 수 있다.
	- 클로저와 커링을 이용해 캐싱을 한다.
	- 메모아이지된 함수는 순수함수이다. 순수함수는 몇번 호출되던 같은 값을 반환한다.
		```ts
		const add = num => num + 10
		add(9) // 19

		const memoizedAdd = () => {
			let cache = {}
			return num => {
				if (num in cache) {
					return cache[num] // fetching from cache
				} else {
					let result = num + 10 // calculating result
					cache[num] = result
					return result
				}
			}
		}

		const newAdd = momoizedAdd()
		newAdd(9) // using caculated
		newAdd(9) // using cached
		```
	- 메모아이즈 함수는 아래와 같이 쓸 수 있다.
		```ts
		const add = n => n + 10

		const memoize = fn => {
			let cache = {}
			return (...args) => {
				let n = args[0] // taking 1 arg
				if (n in cache) {
					return cache[n]
				} else {
					let result = fn(n)
					cache[n] = result
					return result
				}
			}
		}

		const memoizedAdd = memoize(add)
		memoizedAdd(3) // using caculated
		memoizedAdd(3) // using cached
		memoizedAdd(4) // using caculated
		memoizedAdd(4) // using cached
		```
	- 메모아이즈 함수는 어떤 함수든 똑같이 래핑할 수 있다. `lodash.memoize(fn, [resolver])`로 간단하게 사용할 수도 있다.
	- 재귀함수를 메모아이징할 수도 있다. 팩토리얼같은 경우에는 이전에 한 계산을 저장하므로 연산속도가 빨라질 수 있다.
		```ts
		const factorial = memoize(
			x => {
				if (x === 0) {
					return 1
				} else {
					return x * factorial(x - 1)
				}
			}
		)
		factorial(5) // using caculated
		factorial(5) // using cached
		factorial(4) // using cached
		```
	- 메모아이징이 어떤 면에서는 캐싱과 같다. 사실상 캐싱의 한 종류이기도 하다. 반면 캐싱은 일반적으로 http 캐싱같은 테크닉을 말한다.
	- 어느 경우에나 사용할 수 있지만 실제로는 제약이 아래와 같이 있다.
  	- 메모아이징 하는 함수는 항상 순수함수여야한다.
  	- 메모리공간을 소모하는 것과 연산속도를 끌어올리는 것 사이의 트레이드-오프이다. 캐싱된 값을 자주 사용하는 것이 제한된 인풋 범위를 가진 함수에 중요하다.
  	- api 호출을 메모아이징해야할 것처럼 보이지만 브라우저에서는 알아서 캐싱하기때문에 불필요하다.
  	- 무거운 연산작업을 하는데 가장 적합하다. 참고로 팩토리얼이나 피보나치는 실제로 사용하는 예가 아니다.
  	- react/redux를 사용중이라면 reselect를 사용하면 메모아이징된 셀렉터를 사용할 수 있다.

## 07.09.2020

- react
	- `useImperativeHandle`
		- 부모 컴포넌트에서 자식 컴포넌트의 정보를 제공받는 방법이다.
		- 자식 컴포넌트에 ref를 걸어 함수를 호출할 수 있다.
		- ref를 걸 수 있도록 자식 컴포넌트는 forwardRef로 한 번 감싸줘야 한다.
		- forwardRef로 감싼 자식은 props, ref 두 개의 파라미터만 받을 수 있다.
			```ts
			import React, { forwardRef, useImperativeHandle, useRef } from 'react'

			const Child = forwardRef((props, ref) => {
				const alertFoo = () => alert('Foo')

				useImperativeHandle(ref, () => ({ alertFoo }))

				return (
					<div>Foo</div>
				)
			})

			const App = () => {
				const ref = useRef()

				const onClick = () => ref.current.alertFoo()

				return (
					<div>
						<Child ref={ref} />
						<button onClick={onClick}>Foo</button>
					</div>
				)
			}
			```

- nodejs
  - stream
    - 대용량 파일의 경우 파일 전체를 모두 로드하기 전에 메모리 버퍼를 절약하기 위해 다른 행동을 하기 위해 만들어졌다.
    - 기본적으로 읽기 스트림은 data, end, error 이벤트를 가진 `EventEmitter`이다.
    - 파일이 전체로 로드될때까지 기다릴 필요없이 일부를 쓰거나 어떤 처리를 아래와 같이 할 수 있다.
			```ts
			import fs from 'fs'
			import request from 'request'

			const stream = request('http://i.imgur.com/dmetFjf.jpg')
			const writeStream = fs.createWriteStream('test.jpg')

			stream.on('data', data => writeStream.write(data))
			stream.on('end', () => writeStream.end())
			stream.on('error', err => writeStream.close())
			```
		- pipe는 입력을 출력으로 리디렉션할 수 있게 해주는 또 다른 컨셉이다. 위의 코드를 아래ㅗ아 같이 표현할 수 있다.
  		```ts
			import fs from 'fs'
			import request from 'request'

			const stream = request('http://i.imgur.com/dmetFjf.jpg')
			const writeStream = fs.createWriteStream('test.jpg')
			stream.pipe(writeStream)
			```

		- pipe가 하는 일은 pipe로 stream간에 있는 read와 write 이벤트를 연결해주는 것이다. 여러개의 pipe를 서로 연결할 수도 있다.
			```ts
			import gzip from 'zlib'

			stream.pipe(gzip.createGzip()).pipe(writeStream)
			```
		- data 이벤트에 기반한 스트림이 갖는 문제는 stream을 읽는 타이밍이나 한 번에 얼마나 많은 데이터를 읽을지 제어할 수 없다는 점이다.
		- data 이벤트가 걸리면 핸들러는 버퍼에 데이터를 쓰거나 디스크에 정상적으로 써야한다.
		- 이런 상황은 매우 느리거나 제한된 쓰기 i/o를 가진 경우에 문제가 된다.
		- readable stream은 이전 stream 인터페이스와 더불어 readable 이벤트가 추가되었다.
		- 이 이벤트를 통해 읽는 타이밍이나 얼마나 한번에 많이 읽을지 제어할 수 있게 도와준다.
  		```ts
			const stream = fs.createReadStream('./testimg.jpg')
			const writeStream = fs.createWriteStream('./output.jpg')

			stream.on('readable', () => {
				const data = stream.read()
				writeStream.write(data)
			})
			stream.on('end', () => writeStream.end())
			```
		- readable 이벤트가 걸리면 `stream.read()`로 데이터를 읽는 것을 제어할 수 있다.
		- 데이터를 읽을 수 없다면 readable 이벤트는 다시 이벤트 루프에 들어갔다 다시 걸리게 된다.
		- readable stream은 물론 하위 호환성을 갖기때문에 data 이벤트 역시 받을 수 있고, 이 경우 stream은 readable 이벤트를 사용하지 않는다.
		- writable stream은 새로운 drain 이벤트를 사용한다.
		- 이 이벤트는 버퍼에 있는 모든 데이터가 쓰여졌을 때 걸리게 된다. 
		- 이를 통해 버퍼가 비워졌을 때 데이터를 쓸 수 있도록 타이밍을 제어할 수 있다.
  		```ts
			const stream = fs.createReadStream('./input.mp4')
			const writeStream = fs.createWriteStream('./output.mp4')

			const writable = true
			const doRead = () => {
				const data = stream.read()
				writable = writeStream.write(data)
			}

			stream.on('readable', () => {
				if (writable) {
					doRead()
				} else {
					writeStream.removeAllListeners('drain')
					writeStream.once('drain', doRead)
				}
			})
			stream.on('end', () => writeStream.end())
			```
		- 단순히 완료되면 콜백을 던지는 것과 달리 중간중간 결과를 이벤트 방식으로 던져주는 것을 배경으로 탄생했다.
		- 대용량의 데이터를 전달해야 하는 경우에 노드의 이벤트 루프 기반의 stream의 효용이 가장 크게 드러날 수 있다.

## 08.09.2020

- nodejs
  - net
    - `Socket` 객체를 사용해 소켓서버와 소켓 객체 둘 다 생성이 가능하다.
    - 생성된 서버와 클라이언트는 서로 데이터를 읽고 쓸 수 있다.
    - duplex 스트림을 구성하기 때문에 writable, readable 스트림이 제공하는 모든 기능을 제공한다.
    - `write()` 함수를 사용해 클라이언트나 서버에 쓰기 스트림을 보낼 수 있다.
    - 클라이언트나 서버에서 스트림 데이터를 위한 데이터 이벤트 핸들러를 사용할 수도 있다.
    - 소켓 클라이언트에서 Socket 객체는 `net.conntec()`나 `net.createConnection()` 호출 시점에 내부적으로 생성된다.
    - 모든 메서드들은 Socket 객체를 반환한다.
    - Socket 객체를 새엇ㅇ하는 방법으로는 `options` 전달인자를 사용해 소켓 연결을 정의하는 것이다. `options`에는 소켓 연결을 정의한 속성들으 들어있다.
    - 다른 방식으로는 `port`, `host` 값을 직접 전달인자로 받는 것이다.
    - 또한 Socket 객체 생성시 사용할 유닉스 소켓의 파일 시스템 위치를 `path`로 전달받는 것이다.
    - Socket 객체가 생성되면 서버에 연결된 기간동안 다양한 이벤트들을 발생시킨다.
			```ts
			import net from 'net'

			const client = net.connect({
				port: 8080,
				host: 'localhost'
			}, () => client.write('Foo\n'))
			
			client.on('data', data => client.end())
			client.on('end', () => console.log('disconnected'))
			```

## 09.09.2020

- react hooks
  - `handleCheckbox`는 체크박스를 모두 체크해야 다음 버튼이 활성화될 수 있도록 처리하는 훅이다.
		```ts
		const labels = ['check1', 'check2', 'check3']
		
		const App: React.FC = () => {
			const [checkList, setCheckList] = useState([false, false, false])
			const handleCheckClick = (index: number) => {
				setCheckList(checks => checks.map((c, i) => i === index ? !c: c))
			}
			const isAllChecked = checkList.every(x => x)

			return (
				<Fragment>
					<ul>
						{labels.map((label, key) => (
							<li key={key}>
								<label>
									<input 
										type='checkbox'
										checked={checkList[key]}
										onClick={() => handleCheckClick(key)}
									/>
								</label>
							</li>
						))}
					</ul>
					<p>
        		<button disabled={!isAllChecked}>다음</button>
					</p>
				</Fragment>
			)
		}
		```
	- 체크박스가 나열된 부분을 컴포넌트로 분할해 재사용할 수 있게 훅을 만들 수 있다.
	- 우선 `<Check />`와 같은 컴포넌트를 만들어 분리할 수 있다.
	- 커스텀 훅은 컴포넌트 분할과는 달리 컴포넌트 로직 자체를 분할하거나 재사용할 수 있다.
		```ts
		// useChecks.tsx
		type UserChecksResult = [boolean, () => JSX.Element];
		const useChecks = (labels: readonly string[]): UseChecksResult => {
			const [checkList, setCheckList] = useState(() => labels.map(() => false))
			const handleCheckClick = (index: number) => {
				setCheckList(checks => checks.map((c, i) => i === index ? !c : c))
			}
			const isAllChecked = checkList.every(x => x)
			const renderChecks = () => {
				<Checks checkList={checkList} labels={labels} onCheck={handleCheckClick}>
			}

			return [isAllChecked, renderChecks]
		}

		// App.tsx
		const App: React.FC = () => {
			const [isAllChecked, renderChecks] = useChecks(labels)

			return (
				<Fragment>
					{renderChecks()}
					<p>
						<button disabled={!isAllChecked}>next</button>
					</p>
				</Fragment>
			)
		}
		```

- co-routine
  - 협력형 멀티태스킹
    - 루틴에는 메인루틴과 서브루틴이 있다.
    - 서브루틴은 루틴에 진입하는 지점과 루틴을 빠져나오는 지점이 명확하다.
    - 메인루틴이 서브루틴을 호출하면 서브루틴의 맨 처음부분에 진입해 `return`을 만나거나 서브루틴의 닫는 괄호를 만나면 서브루틴을 빠져나온다.
    - 진입점과 탈출점 사이에 쓰레드는 블락되어있다.
			```kt
			fun main() {
				val addedValue = plusOne(value)
			}

			fun plusOne(value: Int) {
				val one = 1
				val addedValue = value + one
				
				return addedValue
			}
			```
		- 아래와 같은 함수가 있다면 함수에 진입할 수 있는 진입점도 여러개이고, 함수를 빠져나갈 수 있는 탈출점도 여러개이다. 
		- 코루틴은 다시 말해 `return`이나 마지막 닫는 괄호를 만나지 않더라도 언제든지 중간에 나갈 수 있고, 언제든지 나갔던 그 지점으로 돌아올 수 있다.
			```kt
			fun drawPerson() {
				startCoroutine {
					drawHead()
					drawBody()
					drawLegs()
				}
			}

			suspend fun drawHead() {
				delay(2000)
			}
			suspend fun drawBody() {
				delay(5000)
			}
			suspend fun drawLegs() {
				delay(3000)
			}
			```
		- 쓰레드는 메인함수가 `drawPerson()`을 호출하면 하나의 코루틴 블럭이 생성된다. `drawPerson()`은 언제든 진입, 탈출할 자격이 주어진다.
		- 코루틴 함수가 실행되는 과정에서 `suspend` 키워드를 가진 함수를 만나면 더 이상 아래 코드를 실행하지 않고 코루틴 블락을 탈출한다.
		- 메인 쓰레드의 다른 코드들이 실행되지만 `drawHead()`는 어디선가 계속 돌고 있다.
		- 다른 코드들도 실행되다가도 `drawHead()`가 끝나면 다시 코루틴으로 진입해서 아까 멈춘 부분 아래부터 다시 실행한다.

## 11.09.2020

- scrum
  - feature
    - 작은 주기인 스프린트로 개발 및 검토를 하며 효율적인 협업 방법을 제공한다.
    - 비즈니스 요구를 충족시키는데 초점을 맞추기 위해 작은 목표를 짧은 주기로 점진적이며 경험적으로 제품을 지속적으로 개발하는 관리 프레임워크이다.
    - 사람들이 효과적으로 성취감을 충족하며 협업할 수 있게 해서 복잡하고 정교한 제품을 생산할 수 있다.
    - 솔루션에 포함할 기능, 개선점에 우선순위를 부여한다.
    - 개발 주기는 1~4주 정도로 하고 개발주기마다 실제 동작할 수 있는 결과를 제공하는 것이 중요하다.
    - 개발 주기마다 적용할 기능이나 개선에 대한 목록을 제공해야한다.
    - 보고하는 자리가 아닌 공유하는 자리이다.
  - role
    - 제품책임자
      - 제품 요구사항 관리와 설명을 한다.
      - 제품 백로그의 우선순위를 관리한다.
    - 스크럼 마스터
      - 팀을 보호하고 장애요소를 해결한다.
      - 일일 스크럼 회의를 진행한다.
      - 모니터링 및 트래킹을 한다.
  - term
    - 제품 백로그: 과거 요구사항 명세처럼 업무 범위를 구체화하기 위한 개발자 입장이 아닌 사용자가 사용하는 관점에서 어떤 가치를 제공할 것인지를 설명한다.
    - 사용자 스토리: po는 이 기능이 누구에게 어떤 가치를 제공하는지 설명하고 개발자는 그 기능의 가치를 제공하기 위한 기술적인 역할과 책임을 가진다.
  	- 스프린트: 계획, 개발, 리뷰 등 최소 단위의 사이클이다.

## 14.09.2020

- keras
  - 최소한의 모듈 방식으로 확장 가능성에 초점을 둔 라이브러리이다.
  - tf, theano, mxnet 등을 백엔드로 더욱 추상화된 api를 제공한다.
  - 일반 사용사례에 최적화된 간단하고 일관적인 인터페이스를 제공한다.
  - 구성 요소의 설정에 의해 연결되는 식으로 거의 제한 없이 모델링할 수 있다.
  - 연구를 위한 새로운 아이디어를 표현하기 위해 사용자 정의 설계 블록을 작성하면 새로운 layer, metrics, 손실함수를 생성하고 최첨단 모델을 개발할 수 있다.
  - usage
    - 사용할 패키지 호출
      ```py
			from keras.utils import np_utils
			from keras.datasets import mnist
			from keras.models import Sequential
			from keras.layers import Dense, Activation
			```
    - 데이터셋 생성: 원본 데이터를 불러오거나 시뮬레이션을 통해 데이터를 생성한다. 데이터로부터 훈련, 검증, 시험셋을 생성한다. 이때 딥러닝 모델의 학습 및 평가를 할 수 있도록 포맷변환을 해준다.
      ```py
			(x_train, y_train), (x_test, y_test) = mnist.load_data()
			x_train = x_train.reshape(60000, 786).astype('float32') / 255
			x_test = x_test.reshape(10000, 786).astype('float32') / 255
			y_train = np_utils.to_categorical(y_train)
			y_test = np_utils.to_categorical(y_test)
			```
    - 모델 구성: 시퀀스 모델을 생성한 뒤 필요한 레이어를 추가해 구성한다. 좀 더 복잡한 모델이 필요할 때는 케라스 함수 api를 사용한다.
      ```py
			model = Sequential()
			model.add(Dense(units=64, input_dim=28*28, activation='relu'))
			model.add(Dense(units=10, activation='softmax'))
			```
    - 모델 학습과정 설정: 학습하기 전에 학습에 대한 설정을 한다. 손실 함수나 최적화방법을 정의한다. 케라스에서는 `compile()`을 사용한다.
			```py
			model.compile(loss='categorical_crossentropy', optimizer='sgd', metrics=['accuracy'])
			```
		- 모델 학습: 훈련셋을 이용해 구성한 모델로 학습시킨다. 케라스에서는 `fit()`을 사용한다.
			```py
			hist = model.fit(x_train, y_train, epchs=5, batch_size=32)
			```
    - 학습과정 측정: 모델 학습시 훈련, 검증셋의 손실 및 정확도를 측정한다. 반복횟수에 따른 손실 및 정확도 추이를 보면서 학습 상황을 판단한다.
			```py
			print(hist.history['loss'])
			print(hist.history['acc'])
			```
		- 모델 평가: 준비된 시험셋으로 학습한 모델을 평가한다. 케라스에서는 `evaluate()`를 사용한다.
			```py
			loss_and_metrics = model.evalute(x_test, y_test, batch_size=32)
			print(loss_and_metrics)
			```
		- 모델 사용: 임의의 입력으로 모델의 출력을 얻는다. 케라스에서는 `predict()`를 사용한다.
			```py
			xhat = x_test[0:1]
			yhat = model.predict(xhat)
			print(yhat)
			```