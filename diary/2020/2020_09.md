## 02.09.2020

- css
	- position
		- static
			- 요소를 일반적인 문서 흐름에 따라 배치한다.
			- top, right, bottom ,left, z-index 속성이 아무런 영향을 주지 않는다.
		- relative
			- 요소를 일반적인 문서 흐름에 따라 배치한다.
			- 자기를 기준으로 top, right, bottom ,left의 값에 따라 오프셋을 적용한다.
			- 오프셋은 다른 요소에는 영향을 주지 않는다.
			- 페이지 레이아웃에서 요소가 차지하는 공간은 static일 때와 같다.
			- z-index의 값이 auto가 아니라면 새로운 stack context를 만든다.
		- absolute
			- 요소를 일반적인 문서 흐름에서 제거한다.
			- 페이지 레이아웃에 공간도 배정하지 않는다.
			- 대신 가장 가까운 위치 지정 조상 요소에 상대적으로 배치한다.
			- 최종위치는 top, right, bottom, left 값이 지정한다.
			- z-index의 값이 auto가 아니라면 새로운 stack context를 만든다.
		- fixed
			- 요소를 일반적인 문서 흐름에서 제거한다.
			- 페이지 레이아웃에 공간도 배정하지 않는다.
			- 대신 뷰포트의 컨테이닝 블럭을 기준으로 배치한다.
			- 조상 중 하나가 transform, perspective, filter 속성 중 어느 하나라도 none이 아니면 뷰포트 대신 그 조상을 컨테이닝 블럭으로 삼는다.
			- 이 값은 항상 새로운 stack context를 만든다.
		- sticky
			- 요소를 일반적인 문서흐름에 따라 배치한다.
			- 테이블 관련 요소를 포함해 가장 가까운 스크롤되는 조상과 표를 포함한 컨테이닝 블럭을 기준으로 top, right, bottom, left의 값에 따라 오프셋을 적용한다.
			- 이 값은 항상 새로운 stack context를 만든다.

- typescript
	- `<type>` vs. `as type`
		- `<type>`이 키워드가 더 깔끔해보이지만 대개 `as type` 키워드를 추천한다.
		- 해당 변수가 실제로 어떤 인스턴스가 아니더라도 `as` 키워드를 통해 타입 단언을 해줄 수 있기때문에 타입단언은 주의해야한다.
		- 실제로도 `as any`라는 치트키로 대부분의 컴파일 에러를 해결할 수 있다. 
		- 타입단언은 타입을 변경한다는 사실때문에 타입캐스팅과 비슷할 수도 있지만 다르다.
		- 타입 단언은 런타임에 영향을 미치지 않는다. 하지만 타입 캐스팅은 컴파일, 런타임 모두 타입을 벼녕시킨다.
		```ts
		(<Wizard>character).fireball()
		(character as Wizard).fireBall()
		```
	- type guard
		- 타입 단언을 좀 더 깔끔하게 할 수 있도록 도와준다.
		- 타입가드는 런타임에서 타입체크를 컴파일러에게 알려주는 기능을 한다.
		- `var is type`과 같은 문법을 사용해 선언하면 된다.
		```ts
		class Character {
			isWizard(): this is Wizard {
				return this instanceof Wizard
			}
			isWarrior(): this is Warrior {
				return this instanceof Warrior
			}
		}
		```

## 03.09.2020

- react
	- document.getElementById
		- 태그를 직접 다뤄야 하는 경우 유일한 id를 지정하면 getElementById 메서드로 직접 엘리먼트를 호출해 사용할 수 있다.
		```ts
		const handleSubmit = e => {
			e.preventDefault()

			const idRef = document.getElementById('id')
			const passwdRef = document.getElementById('passwd')

			const id = idRef.target.value
			const passwd = passwdRef.target.value
		}

		return (
			<form onSubmit={handleSubmit}>
				<label>
					id:
					<input id='id' type='text' />
				</label>
				<label>
					passwd:
					<input id='passwd' type='password' />
				</label>
				<button type='submit'>sign in</button>
			</form>
		)
		```
	- useRef
		- 간단한 컴포넌트라면 document.getElementById 메서드를 사용할 수 있지만 테이블처럼 반복 컴포넌트인 경우에는 아무래도 한계와 react스럽지 못한 점이 있다.
		```ts
		import React, { createRef, useState } from 'react'

		const User = () => {
			const [idRef, setIdRef] = useState(() => createRef())
			const [passwdRef, setPasswdRef] = useState(() => createRef())

			const handleSubmit = e => {
				e.preventDefault()

				const id = idRef.current.target.value
				const passwd = passwdRef.current.target.value
			}

			return (
				<form onSubmit={handleSubmit}>
					<label>
						id:
						<input ref={idRef} type='text' />
					</label>
					<label>
						passwd:
						<input ref={passwdRef} type='password' />
					</label>
					<button type='submit'>sign in</button>
				</form>
			)
		}
		```
	- useReference
		- createRef 함수로 생성한 state는 직접 엘리먼트를 지정할 일이 없으므로 useState의 2번째 값이 필요가 없다.
		- 따라서 커스텀 훅으로 분리하면 깔끔하게 작성할 수 있다.
		- 참고로 react에서는 기본 훅으로 useRef를 제공해주고 있다.
		```ts
		const useReference = () => {
			const [reference, setReference] = useState(() => createRef())

			return reference
		}
		```
	- forwardRef
		- 하위 컴포넌트의 커스텀 함수를 상위 컴포넌트에서 사용할 수 있도록 해준다.
		- ref 속성은 react에만 있는 속성이기때문에 아래처럼 작성하면 원하는 동작을 하지 않는다.
			```ts
			const User = () => {
				(...)
				return (
					<form>
						<LabelInput text='id: ' type='text' ref={idRef} />
						<LabelInput text='passwd: ' type='password' ref={passwdRef} />
					</form>
				) 
			}
			const LabeledInput = ({ text, type, ref }) => {
				return (
					<label>
						{text}
						<input type={type} ref={ref} />
					</label>
				)
			}
			```
		- 여러가지 방법이 있지만 기본 지원 함수를 이용하는 것이 가장 깔끔한 방법이다.
			```ts
			const User = () => {
				(...)
				return (
					<form>
						<LabelInput text='id: ' type='text' ref={idRef} />
						<LabelInput text='passwd: ' type='password' ref={passwdRef} />
					</form>
				)
			}
			const LabeledInput = forwardRef(({ text, type }, ref) => {
				return (
					<label>
						{text}
						<input type={type} ref={ref} />
					</label>
				)
			})
			```