# 오늘 배운 것을 정리하는 공간

## 01.01.2019

- sql 다중 행 연산자: 하나 이상의 값을 요구하며 단일행 비교연산자(`<`, `>`, `=`)와 결합해 사용할 수 있다.

  - `IN`: 하나의 컬럼이 여러개의 `=` 조건을 가지는 경우에 사용한다.
  - `ANY`, `SOME`: 비교하는 값들 중 하나라도 만족한다면 행을 반환한다.
  - `ALL`: 비교하는 값들 중 모든 값을 만족한다면 행을 반환한다.
  - `EXISTS`: 데이터 존재여부를 참, 거짓으로 반환한다.

## 01.02.2019

- concurrently: 패키지 파일에 서버를 여러개 띄울 수 있도록 해주는 패키지다. 글로벌 설치해서 사용하도록 한다. `concurrently \"`하고 서버실행 명령어를 입력한다.
- travis: 세팅을 노드로 해두면 `npm test`가 기본적으로 실행된다. db를 사용한다면 db생성하는 명령이 필요하며 `services`에 설정할 수 있다. `before_install`에 등록한 명령으로 테스트 db를 생성한 뒤 의존성모듈성 전부 설치 후 모카 테스트를 순서대로 실행한다. 테스트 후 리액트 빌드 작업을 해야하는데 노드 서버에서는 빌드 파일을 정적 파일로 사용하기 때문이다. 그리고 빈스톡은 깃 헤드파일을 기준으로 체크아웃해서 배포한다. 따라서 빌드한 리액트 코드를 깃에 추가해줘야 코드를 배포할 수 있다. aws 빈스톡으로 보내려면 트라비스의 배포 제공자를 설정하면 된다.
- beanstalk: 도커 컨테이너를 기반으로 앱을 배포하고 관리하는 툴이다. 빈스톡에서 배포를 하면 깃이나 S3에 소스코드가 올라간다. 그리고 공짜다.
- 웹서버: 정적 파일을 node서버에서 처리하는 것보다 nginx나 apache서버에서 처리하는 것이 훨씬 성능이 좋다고 한다.
- hooking: 이미 작성된 코드의 특정 지점을 가로채서 동작방식에 변화를 주는 기술을 말한다. 대상코드 소스를 수정하지 않고 원하는 동작을 해야하기 때문에 하기가 어렵다.

- 개발 방법론:

  - TDD(Test Driven Development):
    - 테스트 간에 의존이 없어야 한다.
    - 시나리오를 먼저 작성하는 것이 중요하다.
    - 스토리를 먼저 정의하고 테스트 스펙을 정의한다.
    - 프로그램의 가장 하위부분에 집중한다. 프로그램의 가장 안쪽에서 사용자에 가까운 바깥쪽으로 만들어 나가는 방식이라서 인사이드 아웃 방식이라고 부른다.
    - 개발자를 위한 방식이다.
  - BDD(Behavior Driven Development):
    - 테스트 케이스를 작성하는데 좀 더 자연어에 가깝게 작성한 것을 말한다.
    - 초심자가 TDD를 더 빨리 익힐 수 있게 하자는 취지에서 탄생했다.
    - 사용자에 가까운 바깥쪽부터 안쪽으로 만들어 나가는 방식이라서 아웃사이드 인 방식이라고 부른다.
    - 최종목표를 미리 명확하게 해서 시스템 모듈이 잘게 분산되는 것을 막는다.
    - 책임관계자와 함께 하기 위한 방식이다.
    - 종류:
    - spec: 자연어로 앱 구현을 묘사하는 테스트 유형이다.
    - story: 보다 상위 수준 행동에 중점을 둔 테스트 유형이다. 구체적인 구현이 아닌 보다 추상적인 묘사를 한다.
  - DDD(Domain Driven Development): 데이터 중심의 접근법에서 벗어나 순수한 도메인의 모델과 로직에 집중하는 것을 말한다.

- mocha: 커스텀 가능한 범위가 넓어 큰 프로젝트에 적합하다.
  - `.describe()`: 큰 카테고리를 정의할 때 사용한다. 예를 들어 성공케이스와 실패케이스.
  - `.it()`: 서브 카테고리를 정의할 때 사용한다.
- jest: 커스텀이 필요없어 작은 프로젝트에 적합하다.

- 테스트 기법:

  - unit test: 개별 유닛(모듈, 함수, 클래스)을 나머지 앱과 분리해 테스트한다. 주로 객체지향 프로그래밍에서는 주로 클래스나 메서드가 테스트 대상이다. test double이 사용되고 테스트 대상의 범위가 좁기떄문에 테스트 케이스가 실패하면 어디서 어떤 문제가 발생했는지 파악하기가 쉽다. 일반적으로 단위테스팅은 GUI 계층에 적용하기 어렵다.
  - functional test: 사용자의 관점에서 앱을 테스트한다. acceptance test와 비슷하지만 필수적으로 자동화 된다. E2E(End to End) test라고도 부른다.
  - integration test: 두 개 이상의 유닛간의 통합을 테스트한다.
  - acceptance test: 소프트웨어가 승인 기준에 만족하는지 검사하는 blackbox test이다. 테스트 케이스는 사용자가 작성한다.
  - 하위 테스트 종류:
    - blackbox test: 유닛의 공용 인터페이스만 사용해서 테스트 되는데 이것은 고장나기 쉽다.
    - whitebox test: 유닛의 내부 구현방식까지 다루는 이 테스트는 더더욱 고장나기 쉽다. 여기에 훨씬 많은 시간과 노력이 들어간다.

- coverage: 100줄의 코드가 있다면 80줄의 코드가 테스트되고 있다면 커버리지가 80%란 개념이다. 테스트가 얼마나 충분한가를 나타내는 지표 중에 하나라고 볼 수 있다. 커버리지를 100% 달성하길 바라는 것은 자원 낭비이다.

  - code coverage: 코드가 실행되는 정도
  - case coverage: 테스트 스위트가 커버하는 케이스의 수

- test double:
  - 테스트 대상 코드를 격리한다.
  - 테스트 속도를 개선한다.
  - 예측 불가능한 실행요소를 제거한다.
  - 특수한 상황을 시뮬레이션한다.
  - 감춰진 정보를 얻어낸다.
  - 종류: 구분하기가 다소 모호한 부분이다.
    - dummy: 가장 기본적인 유형이다. 구현이 포함되지 않았고 다른 곳에 이용되지 않는 경우 주로 사용한다.
    - stub: 원래의 구현을 최대한 단순한 것으로 대체하는 것을 말한다. 마치 실제로 dummy객체가 동작하는 것처럼 보이게 만들어놓은 객체이다. dummy보다 한단계 발전한 형태이다. 테스트 신뢰도 또한 높은편이다.
    - fake: 실제 로직같은 코드를 말하는데 이렇게 만들어진 객체를 fake객체라고 말한다. 모양만으로 stub과 fake를 구분짓기는 어렵다.
    - spy: 테스트에서 특정객체가 사용됐는지 호출여부를 감시해서 기록했다가 요청이 들어오면 해당정보를 전달해주는 객체이다.
    - mocking:
      - 실제 구현 코드를 대신하는 모의 객체를 말한다.
      - test double과 mock객체가 거의 동등한 의미로 사용되는 경우가 많다.

## 03.01.2019

- proxy:

  - forward proxy: 컨텐츠와 클라이언트를 직접 연결시키는게 아니라 프록시서버가 연결 요청을을 받아서 클라이언트에게 전달한다. 캐싱기능이 있어 자주 사용하는 컨텐츠라면 성능향상을 가져올 수 있고 정해진 사이트만 연결하게 설정할 수도 있다.

     <img src="https://www.lesstif.com/download/attachments/21430345/image2014-7-16%200%3A54%3A40.png?version=1&modificationDate=1405440454000&api=v2" width="500">

  출처: [lesstif](https://www.lesstif.com/pages/viewpage.action?pageId=21430345)

  - reverse proxy: 프록시서버가 요청을 받아서 내부서버에서 데이터를 받은 후에 클라이언트에게 전달한다.

     <img src="https://akal.co.kr/wordpress/wp-content/uploads/2016/05/diagram002.png" width="500">

  출처: [아칼](https://akal.co.kr/?p=1173)

- 우분투 원격 접속:

  - telnet 설치 후 putty로 접속:
    <img src="https://t1.daumcdn.net/cfile/tistory/27E05433596EF9EE2A" width="500">

  - openSSH로 접속:
    <img src="https://t1.daumcdn.net/cfile/tistory/2113FD4F596F07211A" width="500">

- 우분투에서 서버 돌리는 방법:

  - node.js: 그 자체가 웹서버 역할을 수행할 수 있다.
  - apache/nginx 위에 node.js: 두 가지 이상의 언어를 사용해야 하는 경우에는 웹서버 위에 node.js를 실행하도록 처리할 필요가 있다.

- web server:
  - apache: 요청 하나당 프로세스가 처리하는 구조이다. 요청이 많을수록 성능저하가 올 수 있다. 프로세스가 블로킹되면 요청을 처리하지 못하고 처리가 완료될 때까지 대기하는 일이 발생한다. 웹서버가 정적파일로만 구성됐을 경우 keepAlive를 활성화 시켰을 시에는 50%정도의 성능 향상을 보인다고 한다. 아파치서버 안에서 여러 웹서버들을 컨테이너화 시켜놓을 수 있다.
    - 안정성, 확장성, 호환성이 우세하다.
  - nginx: 보안과 속도를 최적화시키려는 목적으로 탄생한 웹서버이다. 규모가 작고 정적데이터 처리가 많은 서비스에 적합하다. evnet driven방식의 웹서버라서 리소스 소모가 적다. 모듈 개발이 어렵고 다양한 모듈이 없다는 것이 단점이다.
    - 성능이 우세하다.
- daemon: 머신에서 항상 실행되는 백그라운드 프로세스이다.
- load balancing: 부하 분산을 위해 가상 ip를 통해 여러 서버에 접속하도록 분배하는 기능을 말한다.

- SSH(Secue Shell Protocal):
  - 데이터전송: 깃헙에 푸쉬할때 SSH를 활용해서 데이터를 전송하게 된다.
  - 원격제어: AWS 인스턴스에 접속해서 머신에 명령을 내릴때 SSH를 통한 접속을 해야한다. FTP나 telnet은 정보를 직접 네트워크를 통해 넘기는데 그렇게 되면 누구나 이 정보에 접근이 가능해져 보안이 약해진다. 하지만 SSH는 보안적으로 안전한 채널을 구성한 뒤에 통신을 해서 보안이 뛰어나다.
    - private key: 외부에 절대 노출돼서는 안되는 키이다. 본인의 컴퓨터 내부에 저장하게 되어있다. 복호화가 가능하다.
    - public key: 공개돼도 비교적 안전한 키이다. 메시지를 전송하기 전 암호화를 한다. 암호화는 가능하지만 복호화는 불가능하다.
    - 둘의 관계: public key를 먼저 다른 컴퓨터와 통신하고 그 컴퓨터에 복사해 저장한다. 클라이언트에서 요청을 하고 응답할때 클라이언트의 public key와 쌍을 이루는 서버의 private key를 비교해서 한쌍의 키인지 검사를 한다. 이것이 검증되면 두 컴퓨터 사이에 암호화된 채널이 형성되어 메시지를 암호화, 복호화하며 데이터를 주고받을 수 있게 된다.
- SSL(Secure Socket Layer): 이제는 TLS(Transport Layer Security)라는 이름으로 바뀌었다. 브라우저에 자물쇠표시가 되어있는 경우 해당 웹사이트는 SSL이라는 보안 프로토콜을 사용한다는 것을 나타낸다. 넷스케이프에서 웹서버와 웹브라우저 간의 보안을 위해 만들어졌다.

- node.js 서버 배포 방법:

  - jenkins:
  - travis: 프로덕션용으로 좋다.
  - docker:
  - beanstalk:
  - code deploy:

- 웹페이지:

  - static page: 서버는 사용자의 요청에 일치하는 저장된 페이지를 보낸다. 사용자는 서버에 있는 데이터가 변경되지 않는 한 고정된 페이지를 보게된다.
    - 장점: 빠르고 비용이 적게 든다. 웹서버만 구축하면 된다.
    - 단점: 서비스가 한정적이고 관리가 힘들다. CRUD를 수동으로 해야 한다.
  - dynamic page: 서버에 있는 데이터를 스크립트로 가공후 생성된 페이지를 보낸다. 사용자는 상황, 시간, 요청에 따라 달라지느 페이지를 보게된다.
    - 장점: 서비스가 다양하고 관리가 쉽다. CRUD 작업이 용이하다.
    - 단점: 상대적으로 느리고 추가비용이 든다. 웹서버 외에 추가적인 앱서버를 필요로 한다.

  <img src="http://i0.wp.com/lh3.googleusercontent.com/-mFaOm0EGIvA/VqeJYe_b_yI/AAAAAAAAADA/FDiCN9Zp_hg/w720-o/static-vs-dynamic-web-inside.png?w=734&ssl=1" width="500">

## 04.01.2019

- linux:

  - `wget`: url에 있는 파일을 다운로드할 수 있는 명령어다. 5단계까지 하위 폴더의 모든 파일을 다운로드할 수 있다. 이미지 url은 single/double quote로 감싸주는게 올바른 표혀이다.
    - `--recursive/-r`: 하위폴더를 포함해서 존재하는 모든 파일을 다운로드한다.
    - `-l`: level. 5단계에서 더 아래로 들어가기 위해서 사용한다.
    - `-np`: no-parent. recursive옵션을 주고 실행할때 부모 디렉토리의 파일을 다운받지 말라는 뜻이다.
    - `--reject *.*`: `*.*`를 제외하고 다운로드할 수 있다.
    - `-P DIR_NAME`: 특정 디렉토리에 파일을 받고싶을 때 사용한다.
  - `nohup`(No Hang Up): 백그라운드 명령을 할 수 있다.
  - `apt`(Advanced Packaging Tool): 패키지 관리 명령어이다. `apt-get`, `aptitude`과 같은 의미로 사용한다.
  - `sudo`(Superuser):

- RPM(RPM Package Manager <= Red Hat Package Manager): 리눅스 레드햇 계열에서 사용하는 프로그램관리 명령어이다. 필요한 라이브러리를 개별적으로 설치해야 하기때문에 의존성 라이브러리를 설치하는데 어려움이 많다. 온라인 저장소에 접속하는게 불가능하며 소프트웨어 업데이트가 불가능하다.
- Yum(Yellow dog Updater and Modifier): rpm의 불편함을 개선하고자 등장한 명령어이다. 온라인 접속을 통해 의존성 라이브러리의 업데이트 자동확인이 주목적이다.

- ubuntu서버에 파일 전송방법:

  - putty의 pscp를 이용한 업로드
  - node서버에서 multer 등을 통해 업로드
  - FTP서버를 통해 업로드
    - os 방화벽 설정에서 ftp허용 후 콘솔에서 업로드:
      - `ftp 서버주소`를 입력한다.
      - 사용자id로 로그인한다
      - `put 파일주소`: 우분투의 현재 위치에 저장한다.
      - `get 파일주소`: os로 파일을 가져온다.
      - `quit`: 종료 명령어.
    - filezilla같은 FTP프로그램을 사용해야한다.

- scp(Secure Copy): 로컬에서 원격서버로 파일을 복사해 올리거나 내려받을때 사용하는 유닉스계열 유틸이다. scp를 통해 파일을 복사할때 계정 패스워드 또는 키파일 인증이 필요하다.

  - 파일 업로드: `$ scp 보낼파일 서버사용자계정@서버주소:복사될경로`
  - 파일 다운로드: `$ scp 서버사용자계정@서버주소:가져올파일경로 복사될경로`

- FTP(File Transfer Protocol): 원격서버에 필요한 파일을 올리기 위한 도구이다.
- telnet: 원격서버를 마치 직접 콘솔에서 사용하는 것처럼 작업하게 해주는 도구이다.

- tomcat: 아파치 재단의 오픈소스 프로젝트이다. 동적 웹을 만들기 위한 웹서버이며, jsp, asp, php 등은 톰캣에 전달된다. db 등 서비스가 가능해진다.

- UUID(Universally Unique Identifier):
- GUID(Globally Unique Identifier):

- 도커를 사용하기 위해서는 bios에서 가상화 옵션을 활성화시켜줘야 한다.

- python:

  - 멀티라인: `"""` 혹은 `'''`으로 감싸 입력한다.
  - 문자열을 encode하면 byte형이 되고 byte형을 decode하면 문자열이 된다.
  - function:

  ```py
  def 함수명(파라미터):
    실행될 코드
    return 결과

  def square(x):
    return x * x

  square(5)
  # 25
  ```

  - module: `from 파일명 import (함수명, 함수명)`을 사용하고 모든 함수를 가져올떄는 `*`를 사용한다.

  ```py
  # test.py
  print(__name__) # __main__
  import test # test
  ```

  - sys: 이 모듈을 통해 실행시 인자값을 받을 수 있다.

  ```py
  # test.py
  import sys

  var1 = sys.argv[1]
  var2 = sys.argv[2]
  var3 = sys.argv[3]

  print "var1 = " + var1 # var1 = 1
  print "var2 = " + var2 # var2 = 2
  print "var3 = " + var3 # var3 = 3
  print sys.argv[0] # test.py
  ```

## 05.01.2019

- python:

  - docstring: 모듈, 함수, 클래스, 메소드 정의 바로 밑에 오는 문자열 리터럴이다. 해당 객체의 `__doc__` 속성으로 변환되며 접근할 수 있다. `'''`, `"""` 혹은 `***` 내부에 작성할 수 있다.

  ```py
  class Class:
  ***
  문서화 내용
  ***

    def function(param):
    '''
    문서화 내용
    :param param: 파라미터
    '''
  ```

  - shebang: sharp(#) + bang(!)의 합성어이다. 유닉스계열(linux, mac) 스크립트(bash 등) 최상단에서 파일을 해석해줄 인터프리터의 절대경로를 지정한다. 일반적으로 `/usr/bin/env`파일을 이용한다. python을 입력할 필요없이 실행하려면 `$ chmod +x 파일명`으로 권한을 부여한 다음 파일명을 입력해 실행시킨다. 여러사람이 한 파일으 공유할떄는 `env`를 이용해 작성하는 것이 좋다.

  ```py
  #!인터프리터절대경로
  #!/usr/bin/env 언어이름
  ```

## 06.01.2019

- python:

  - default value:
    - 정의된 함수가 처음 작동할때 값 그대로이며 실행을 여러번 해도 바뀌지 않는다.
    - 값을 `None`으로 하고 `None`인 경우에만 값을 할당하는 식으로 예상치 못한 결과를 피할 수 있다.
  - position arg unpacking: 리스트, 튜플같이 인덱스가 존재하는 객체에 `*`표시를 붙여 인자로 입력하면 함수의 정의된 위치에 맞게 입력된다. 하지만 인자의 수와 입력하는 객체의 수가 다르면 에러가 발생한다. 변수 대신 바로 입력도 가능하고 정의할때도 가능하다.

  ```py
  def function(a, b, c):
    return b, a, c

  p = [1, 2, 3]
  function(*p) # (2, 1, 3)
  ```

## 07.01.2019

- docker: 도커를 개발환경으로 사용하면 개발=테스트=운영이 동일한 환경에서 실행되는 놀라운 상황을 볼 수 있다.
  - 과정:
    - 소스복사
    - 패키지 설치
    - 서버 실행

## 08.01.2019

- grid computing: 하나의 작업을 동시에 여러대의 컴퓨터가 분할해 처리하는 기술.
- LXC(LinuX Containers): 전가상화(full virtualization)나 반가상화(paravirtualization)처럼 os 위에 가상머신이 따로 돌아가는게 아니라 os영역에서 공유 라이브러리를 가지고 유저가 생성하는 프로세스 단위로 성능 분리를 하는 기술.
- image: 어떤 디스크의 내용을 통째로 파일로 옮겨놓은 것을 말한다. 도커에서는 분리된 환경을 image라고 한다.
- snapshot: 특정시점의 코드를 스냅샷이라고 해서 관리할 수가 있다. 클라우드 서버나 볼륨을 사진 찍듯 그대로 저장해 백업하는데 사용한다.
- instance: 클라우드 상의 가상 서버를 말한다.
- server:
  - cache server: 자주 요청하는 컨텐츠는 사용자와 가까운 위치에 저장시킬 수 있어 빠르게 데이터를 응답할 수 있다.
  - woker server:
- docker: 기본적으로 root권한이 필요하다.

  - root 권한 설정:
    - `sudo usermod -aG docker [사용자명]`: 사용자에게 권한을 준다.
    - `sudo usermod -aG docker $USER`: 현재 접속중인 사용자에게 권한을 준다.
  - image 만드는 방법: 사실 둘다 같은 방법이다.

    - Dockerfile 작성
      - Dockerfile instructor의 수에 따라 layer 갯수가 결정된다.
      - `FROM [언어 || 플랫폼 || os]`: 언어, 플랫폼 혹은 os에서 시작한다. `FROM scratch`는 맨 땅에서 시작한다는 뜻으로 쓴다.
      - `COPY [파일명] [디렉토리명]`: 파일을 어디 디렉토리에 복사한다.
      - `CMD [실행할 명령]`: 이미지를 구동하는 컨테이너가 실행할 명령이다.
      - `MAINTAINER [이름] [<메일주소>]`: 도커파일을 생성, 관리하는 사람을 입력한다.
      - `RUN`: 직접 쉘 명령어를 실행하는 명령어이다.
      - `EXPOSE [포트]`: 가상머신에 오픈할 포트를 지정한다.
      - `docker build`: Dockerfile을 참조해서 이미지를 만들어주는 명령이다.
        - 빌드 과정에서 캐시를 사용해서 매우 빠르게 빌드를 할 수 있다. 중간에 빌드가 실패하더라도 성공했던 명령어까지는 시간 소모 없이 빠르게 진행하도록 설계되었다. 필요하다면 중간 이미지에 접근하거나 직접 중간 이미지로부터 다른 이미지를 생성하는 것도 가능하다.
        - 도커 생태계에 있는 오픈소스 앱들은 아에 도커파일을 프로젝트에 포함하고 있다.
        - 빌드 도중에는 키보드 입력을 할 수 없기 때문에 (y/n)을 물어보는 것을 방지하려면 `-y` 옵션을 추가해야 한다.
    - container에서 `docker commit`을 통해 image 생성

      - container: 이미지를 사용해 생성되고 실행된다. 여기에는 앱이 필요로 하는 최소한의 구동환경만 담으면 된다.

        - 격리된 운영환경
        - 앱 개발환경:
          - 운영환경과 동일한 환경에서 개발할 수 있다. 왜 로컬에서는 잘되는데 서버에서는 안되지라고 할 수 없게 돼버린다.
          - 컴퓨터의 os나 환경이 업그레이드 되어도 기존 개발환경을 유지해 사용할 수 있다. 가상화 기술을 쓰는 것보다 자원이 적게 든다.
          - 서로 다른 개발환경을 사용하는 두 개 이상의 프로젝트를 동시에 수행할 수 있다.
          - 만든지 오래된 앱을 유지보수할 때 어떤 환경이었는지를 기억해낼 필요가 없어진다.
        - `docker run [이미지] [경로]`: 컨테이너를 실행한다.
        - `docker restart [컨테이너 id]`: 종료된 컨테이너를 다시 살린다.
        - `docker attach [컨테이너 id]`: 재시작한 다음에는 컨테이너 안으로 들어가지 않는다. 그래서 컨테이너 안으로 다시 들어가기 위한 명령어이다.
        - `docker ps`: 동작중인 컨테이너를 확인할 수 있다.
        - `docker ps -a`: 정지된 컨테이너를 확인할 수 있다.
        - `docker rm [컨테이너 id], [컨테이너 id]`: 컨테이너를 삭제한다.
        - `` docker rm `docker ps -a -q` ``: 컨테이너를 모두 삭제한다.

        <img src="https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/docker-image.png" width="500">

    - image: 앱이 필요로 하는 것이 매우 단순하거나 의존성 관계를 잘 알고 있으면 구성하기 쉽다. 해당 이미지에서 종료상태를 포함한 파생된 컨테이너가 하나라도 있다면 이미지는 삭제할 수가 없다.
      - `docker images`: 이미지를 확인할 수 있다.
      - `docker rmi [이미지 id]`: 이미지를 삭제한다.
      - `docker rmi -f [이미지 id]`: 컨테이너를 삭제하기 전에 이미지를 삭제한다. `-f`는 강제 삭제 명령어다.
      - `docker commit [ID] [image name]`: 수정사항을 기반으로 새로운 이미지를 만들기 위해 버전관리를 한다.

  - 실제 서비스에서 돌리려면:
    - 생성된 이미지 관리: 다른 docker시스템에 배포하기 위한 방법을 알아야한다.
    - 실제서비스를 container에 올리고 관리하는 방법: 서버에 웹서버를 몇개 띄울지 결정하고 관리하는 방법을 알아야한다.
    - docker host와 guest간 통신관리: docker가 설치된 실제 서버와 그 위에 돌아가는 container들 사이에 오가는 통신을 이해해야 한다. 포트 바인딩 = 포트 포워딩.
    - docker API: api를 알아야 한다.
  - `docker version`: Client와 Server정보가 나온다. 도커는 하나의 실행파일이지만 실제로 클라이언트와 서버 역할을 각각 할 수가 있다. 도커 클라이언트가 도커 서버로 명령을 전송하고 결과를 받아 터미널에 출력한다.

  <img src="https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-2/docker-host.png" width="500">

  - 배포:

    - 기존은 ftp, ansible 등 다양한 배포툴로 배포 방식을 정의하는 것이 불가능했다.
    - 컨테이너를 사용하면 어떤 언어, 프레임워크던 간에 배포방식이 동일해지고 과정도 단순해진다. 그저 이미지를 다운받고 컨테이너를 실행하면 끝난다. 서버에서 컨테이너를 실행하는 방법을 안다면 배포하는 방법 또한 알고 있는 것이다.
    - 업데이트도 배포와 큰 차이가 없다. 최신 이미지를 기반으로 새 컨테이너를 만들고 이전 컨테이너를 중지, 삭제하면 된다. 그냥 통째로 바꾸면 끝난다. 컨테이너를 중지하지 않고 컨테이너 내부에 접속해 소스를 업데이트하는 방법도 가능하지만 컨테이너의 장점을 살릴 수 없는 잘못된 패턴이다. 무중단을 고려한 로드밸런서와 2대 이상의 컨테이너를 사용해야 한다.

    <img src="https://subicura.com/assets/article_images/2017-02-10-docker-guide-for-beginners-create-image-and-deploy/docker-update.png" width="500">
