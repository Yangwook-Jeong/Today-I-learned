# 오늘 배운 것을 정리하는 공간

## 10.07.2019

- cache
  - 특징
    - 정적파일은 자동으로 cache처리 되지만 동적렌더링이 필요한 api에서는 cache기능이 활성화되지 않아있다
    - 유저 입장에서 빠른속도로 데이터를 받아올 수 있다.
  - redis
  - memcached
  - http
    - 특징
      - api같이 언제 바뀔지 모른느 데이터의 cache는 쉽지 않지만 이 방식을 이용하면 서버에서 새로운 데이터를 먼저 확인하고 줄 수 있어 api에서도 충분히 적용가능하다.
      - 다른방식보다 먼저 사용해보는게 좋다.
      - db 부하를 줄일 수 있고 response 데이터를 받아오지 않아 속도개선이 좋다.
    - 종류
      - cache control + expire
        - `Cache-Control: public, max-age=31536000`
        - `max-age`동안 브라우저가 cache를 해도 무방하다고 알려주는 방식이다.
        - api의 경우 언제 새로운 데이터가 포함될지 모르니 이 방식을 사용할 수 없다.
      - last modified
        - `Last-Modified: Mon, 03 Jan 2011 17:45:57 GMT`
        - api의 내용이 마지막으로 변경된 시간을 response로 주면 브라우저에서는 request header에 약간의 정보를 아래와 같이 추가해서 보낸다.
        - `If-Modified-Since: Mon, 03 Jan 2011 17:45:57 GMT`
        - api 핸들러에서 마지막으로 변경된 시간을 체크해서 아직 안바뀐 경우 304를 주면 브라우저는 이전 cache데이터를 사용한다.
        - 만약 db에서 마지막 변경시간을 관리하고 있을시 이 방식을 사용하기에 적합하다.
      - etag
        - `ETag: "15f0fff99ed5aae4edffdd6496d7131f"`
        - last-modified방식과 거의 동일하다.
        - 시간 대신 hash값을 사용한다는 점이 다르다.
        - response데이터의 md5 hash를 보통 사용한다.
        - response에 etag header를 추가하면 아래와 같이 request header에 추가된다.
        - `If-None-Match: "15f0fff99ed5aae4edffdd6496d7131f"`
        - 동일한 etag를 가지고 있을시 304를 리턴한다.
        - db부하를 줄일 순 없지만 reponse시간을 줄이는데 도움을 준다.

## 19.07.2019

- OAuth2.0

  - authorization request
    - client가 resource owner에게 사용허가를 요청한다.
  - authorization grant
    - 사용자가 허락을 했을때 일어나는 과정이다.
    - client app은 resource server에 접근이 가능해진다.
  - authorization grant & client credentials
    - client는 authorization server에 접속해 인증을 요청한다.
    - resource owner는 client에게 아이디와 패스워드를 알려주지 않는다.
    - client와 authorization server의 통신 간에는 아이디와 패스워드가 전혀 언급되지 않는다.
  - access token
    - 사용자의 아이디와 비밀번호 대신 authorization server는 client에게 access token을 발급한다.
    - token을 이용해 client는 resource server에 제한적으로 접근할 권한을 받는다.
  - access token
    - client는 access token을 이용해 resource server의 api를 불러올 수 있다.
    - 지정된 api만 허락되며 권한을 벗어난 동작은 허용되지 않는다.
    - 모든 동작이 가능한 아이디, 패스워드에 비해 훨씬 안전하다.
  - protected resource
    - access token을 통해 resource server로부터 데이터를 받아온다.
    - 이 데이터는 client에서 적절히 목적에 맞게 사용된다.

  ![](https://wiki.changwoo.pe.kr/_media/research:oauth20:oauth_2.0_and_the_google_api_client_for_python.jpg?w=640&tok=28707f)

  - 1.0과의 차이점
    - 인증절차 간소화
      - 1.0은 디지털 서명 기반이었지만, 2.0은 https에 맡김으로서 복잡한 디지털서명 로직을 구현하지 않아서 구현 난이도가 보다 낮다.
    - 용어변경
      - resource owner는 1.0의 user이다.
      - resource server는 1.0의 protected resource이다.
      - authorization server는 1.0의 service provider이다.
      - client는 1.0의 service provider이다.
    - resource server와 authorization server의 분리
      - 커다란 서비스는 인증서버를 분리하거나 다중화할 수 있어야 한다.
      - authorization server의 역할을 명확히 한다.
    - 다양한 인증방식
      - authorization code grant
        - 일반적인 웹사이트에서 소셜로그인과 같은 인증을 받을때 사용한다.
      - implicit grant
        - public client인 브라우저 기반의 앱 혹은 모바일 앱에서 바로 resource server에 접근할 수 있는 방식이다.
      - resource onwer password credentials grant
        - client에 아이디, 패스워드를 받아 아이디, 패스워드로 직접 access token을 받아오는 방식이다.
        - client가 신용이 없을 때는 사용하기 위험하다는 단점이 있다.
      - client credentials grant
        - 앱이 credential client일때 아이디와 비밀키를 가지고 인증하는 방식이다.
      - device code grant
        - 브라우저가 없거나 입력이 제한된 장치에서 사용한다.
      - refresh token grant
        - 기존에 저장해둔 refresh token이 존재하는 경우 access token을 재발급 받을 필요가 있을 때 사용하며 기존 token은 만료된다.
