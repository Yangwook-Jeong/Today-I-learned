# 오늘 배운 것을 정리하는 공간

## 01.01.2019

- sql 다중 행 연산자: 하나 이상의 값을 요구하며 단일행 비교연산자(`<`, `>`, `=`)와 결합해 사용할 수 있다.

  - `IN`: 하나의 컬럼이 여러개의 `=` 조건을 가지는 경우에 사용한다.
  - `ANY`, `SOME`: 비교하는 값들 중 하나라도 만족한다면 행을 반환한다.
  - `ALL`: 비교하는 값들 중 모든 값을 만족한다면 행을 반환한다.
  - `EXISTS`: 데이터 존재여부를 참, 거짓으로 반환한다.

## 01.02.2019

- concurrently: 패키지 파일에 서버를 여러개 띄울 수 있도록 해주는 패키지다. 글로벌 설치해서 사용하도록 한다. `concurrently \"`하고 서버실행 명령어를 입력한다.
- travis: 세팅을 노드로 해두면 `npm test`가 기본적으로 실행된다. db를 사용한다면 db생성하는 명령이 필요하며 `services`에 설정할 수 있다. `before_install`에 등록한 명령으로 테스트 db를 생성한 뒤 의존성모듈성 전부 설치 후 모카 테스트를 순서대로 실행한다. 테스트 후 리액트 빌드 작업을 해야하는데 노드 서버에서는 빌드 파일을 정적 파일로 사용하기 때문이다. 그리고 빈스톡은 깃 헤드파일을 기준으로 체크아웃해서 배포한다. 따라서 빌드한 리액트 코드를 깃에 추가해줘야 코드를 배포할 수 있다. aws 빈스톡으로 보내려면 트라비스의 배포 제공자를 설정하면 된다.
- beanstalk: 도커 컨테이너를 기반으로 앱을 배포하고 관리하는 툴이다. 빈스톡에서 배포를 하면 깃이나 S3에 소스코드가 올라간다. 그리고 공짜다.
- 웹서버: 정적 파일을 node서버에서 처리하는 것보다 nginx나 apache서버에서 처리하는 것이 훨씬 성능이 좋다고 한다.
- hooking: 이미 작성된 코드의 특정 지점을 가로채서 동작방식에 변화를 주는 기술을 말한다. 대상코드 소스를 수정하지 않고 원하는 동작을 해야하기 때문에 하기가 어렵다.

- 개발 방법론:

  - TDD(Test Driven Development):
    - 테스트 간에 의존이 없어야 한다.
    - 시나리오를 먼저 작성하는 것이 중요하다.
    - 스토리를 먼저 정의하고 테스트 스펙을 정의한다.
    - 프로그램의 가장 하위부분에 집중한다. 프로그램의 가장 안쪽에서 사용자에 가까운 바깥쪽으로 만들어 나가는 방식이라서 인사이드 아웃 방식이라고 부른다.
    - 개발자를 위한 방식이다.
  - BDD(Behavior Driven Development):
    - 테스트 케이스를 작성하는데 좀 더 자연어에 가깝게 작성한 것을 말한다.
    - 초심자가 TDD를 더 빨리 익힐 수 있게 하자는 취지에서 탄생했다.
    - 사용자에 가까운 바깥쪽부터 안쪽으로 만들어 나가는 방식이라서 아웃사이드 인 방식이라고 부른다.
    - 최종목표를 미리 명확하게 해서 시스템 모듈이 잘게 분산되는 것을 막는다.
    - 책임관계자와 함께 하기 위한 방식이다.
    - 종류:
    - spec: 자연어로 앱 구현을 묘사하는 테스트 유형이다.
    - story: 보다 상위 수준 행동에 중점을 둔 테스트 유형이다. 구체적인 구현이 아닌 보다 추상적인 묘사를 한다.
  - DDD(Domain Driven Development): 데이터 중심의 접근법에서 벗어나 순수한 도메인의 모델과 로직에 집중하는 것을 말한다.

- mocha: 커스텀 가능한 범위가 넓어 큰 프로젝트에 적합하다.
  - `.describe()`: 큰 카테고리를 정의할 때 사용한다. 예를 들어 성공케이스와 실패케이스.
  - `.it()`: 서브 카테고리를 정의할 때 사용한다.
- jest: 커스텀이 필요없어 작은 프로젝트에 적합하다.

- 테스트 기법:

  - unit test: 개별 유닛(모듈, 함수, 클래스)을 나머지 앱과 분리해 테스트한다. 주로 객체지향 프로그래밍에서는 주로 클래스나 메서드가 테스트 대상이다. test double이 사용되고 테스트 대상의 범위가 좁기떄문에 테스트 케이스가 실패하면 어디서 어떤 문제가 발생했는지 파악하기가 쉽다. 일반적으로 단위테스팅은 GUI 계층에 적용하기 어렵다.
  - functional test: 사용자의 관점에서 앱을 테스트한다. acceptance test와 비슷하지만 필수적으로 자동화 된다. E2E(End to End) test라고도 부른다.
  - integration test: 두 개 이상의 유닛간의 통합을 테스트한다.
  - acceptance test: 소프트웨어가 승인 기준에 만족하는지 검사하는 blackbox test이다. 테스트 케이스는 사용자가 작성한다.
  - 하위 테스트 종류:
    - blackbox test: 유닛의 공용 인터페이스만 사용해서 테스트 되는데 이것은 고장나기 쉽다.
    - whitebox test: 유닛의 내부 구현방식까지 다루는 이 테스트는 더더욱 고장나기 쉽다. 여기에 훨씬 많은 시간과 노력이 들어간다.

- coverage: 100줄의 코드가 있다면 80줄의 코드가 테스트되고 있다면 커버리지가 80%란 개념이다. 테스트가 얼마나 충분한가를 나타내는 지표 중에 하나라고 볼 수 있다. 커버리지를 100% 달성하길 바라는 것은 자원 낭비이다.

  - code coverage: 코드가 실행되는 정도
  - case coverage: 테스트 스위트가 커버하는 케이스의 수

- test double:
  - 테스트 대상 코드를 격리한다.
  - 테스트 속도를 개선한다.
  - 예측 불가능한 실행요소를 제거한다.
  - 특수한 상황을 시뮬레이션한다.
  - 감춰진 정보를 얻어낸다.
  - 종류: 구분하기가 다소 모호한 부분이다.
    - dummy: 가장 기본적인 유형이다. 구현이 포함되지 않았고 다른 곳에 이용되지 않는 경우 주로 사용한다.
    - stub: 원래의 구현을 최대한 단순한 것으로 대체하는 것을 말한다. 마치 실제로 dummy객체가 동작하는 것처럼 보이게 만들어놓은 객체이다. dummy보다 한단계 발전한 형태이다. 테스트 신뢰도 또한 높은편이다.
    - fake: 실제 로직같은 코드를 말하는데 이렇게 만들어진 객체를 fake객체라고 말한다. 모양만으로 stub과 fake를 구분짓기는 어렵다.
    - spy: 테스트에서 특정객체가 사용됐는지 호출여부를 감시해서 기록했다가 요청이 들어오면 해당정보를 전달해주는 객체이다.
    - mocking:
      - 실제 구현 코드를 대신하는 모의 객체를 말한다.
      - test double과 mock객체가 거의 동등한 의미로 사용되는 경우가 많다.

## 03.01.2019

- proxy:

  - forward proxy: 컨텐츠와 클라이언트를 직접 연결시키는게 아니라 프록시서버가 연결 요청을을 받아서 클라이언트에게 전달한다. 캐싱기능이 있어 자주 사용하는 컨텐츠라면 성능향상을 가져올 수 있고 정해진 사이트만 연결하게 설정할 수도 있다.

     <img src="https://www.lesstif.com/download/attachments/21430345/image2014-7-16%200%3A54%3A40.png?version=1&modificationDate=1405440454000&api=v2" width="500">

  출처: [lesstif](https://www.lesstif.com/pages/viewpage.action?pageId=21430345)

  - reverse proxy: 프록시서버가 요청을 받아서 내부서버에서 데이터를 받은 후에 클라이언트에게 전달한다.

     <img src="https://akal.co.kr/wordpress/wp-content/uploads/2016/05/diagram002.png" width="500">

  출처: [아칼](https://akal.co.kr/?p=1173)

- 우분투 원격 접속:

  - telnet 설치 후 putty로 접속:
    <img src="https://t1.daumcdn.net/cfile/tistory/27E05433596EF9EE2A" width="500">

  - openSSH로 접속:
    <img src="https://t1.daumcdn.net/cfile/tistory/2113FD4F596F07211A" width="500">

- 우분투에서 서버 돌리는 방법:

  - node.js: 그 자체가 웹서버 역할을 수행할 수 있다.
  - apache/nginx 위에 node.js: 두 가지 이상의 언어를 사용해야 하는 경우에는 웹서버 위에 node.js를 실행하도록 처리할 필요가 있다.

- web server:
  - apache: 요청 하나당 프로세스가 처리하는 구조이다. 요청이 많을수록 성능저하가 올 수 있다. 프로세스가 블로킹되면 요청을 처리하지 못하고 처리가 완료될 때까지 대기하는 일이 발생한다. 웹서버가 정적파일로만 구성됐을 경우 keepAlive를 활성화 시켰을 시에는 50%정도의 성능 향상을 보인다고 한다. 아파치서버 안에서 여러 웹서버들을 컨테이너화 시켜놓을 수 있다.
    - 안정성, 확장성, 호환성이 우세하다.
  - nginx: 보안과 속도를 최적화시키려는 목적으로 탄생한 웹서버이다. 규모가 작고 정적데이터 처리가 많은 서비스에 적합하다. evnet driven방식의 웹서버라서 리소스 소모가 적다. 모듈 개발이 어렵고 다양한 모듈이 없다는 것이 단점이다.
    - 성능이 우세하다.
- daemon: 머신에서 항상 실행되는 백그라운드 프로세스이다.
- load balancing: 부하 분산을 위해 가상 ip를 통해 여러 서버에 접속하도록 분배하는 기능을 말한다.

- SSH(Secue Shell Protocal):
  - 데이터전송: 깃헙에 푸쉬할때 SSH를 활용해서 데이터를 전송하게 된다.
  - 원격제어: AWS 인스턴스에 접속해서 머신에 명령을 내릴때 SSH를 통한 접속을 해야한다. FTP나 telnet은 정보를 직접 네트워크를 통해 넘기는데 그렇게 되면 누구나 이 정보에 접근이 가능해져 보안이 약해진다. 하지만 SSH는 보안적으로 안전한 채널을 구성한 뒤에 통신을 해서 보안이 뛰어나다.
    - private key: 외부에 절대 노출돼서는 안되는 키이다. 본인의 컴퓨터 내부에 저장하게 되어있다. 복호화가 가능하다.
    - public key: 공개돼도 비교적 안전한 키이다. 메시지를 전송하기 전 암호화를 한다. 암호화는 가능하지만 복호화는 불가능하다.
    - 둘의 관계: public key를 먼저 다른 컴퓨터와 통신하고 그 컴퓨터에 복사해 저장한다. 클라이언트에서 요청을 하고 응답할때 클라이언트의 public key와 쌍을 이루는 서버의 private key를 비교해서 한쌍의 키인지 검사를 한다. 이것이 검증되면 두 컴퓨터 사이에 암호화된 채널이 형성되어 메시지를 암호화, 복호화하며 데이터를 주고받을 수 있게 된다.
- SSL(Secure Socket Layer): 이제는 TLS(Transport Layer Security)라는 이름으로 바뀌었다. 브라우저에 자물쇠표시가 되어있는 경우 해당 웹사이트는 SSL이라는 보안 프로토콜을 사용한다는 것을 나타낸다. 넷스케이프에서 웹서버와 웹브라우저 간의 보안을 위해 만들어졌다.

- node.js 서버 배포 방법:

  - jenkins:
  - travis: 프로덕션용으로 좋다.
  - docker:
  - beanstalk:
  - code deploy:

- 웹페이지:

  - static page: 서버는 사용자의 요청에 일치하는 저장된 페이지를 보낸다. 사용자는 서버에 있는 데이터가 변경되지 않는 한 고정된 페이지를 보게된다.
    - 장점: 빠르고 비용이 적게 든다. 웹서버만 구축하면 된다.
    - 단점: 서비스가 한정적이고 관리가 힘들다. CRUD를 수동으로 해야 한다.
  - dynamic page: 서버에 있는 데이터를 스크립트로 가공후 생성된 페이지를 보낸다. 사용자는 상황, 시간, 요청에 따라 달라지느 페이지를 보게된다.
    - 장점: 서비스가 다양하고 관리가 쉽다. CRUD 작업이 용이하다.
    - 단점: 상대적으로 느리고 추가비용이 든다. 웹서버 외에 추가적인 앱서버를 필요로 한다.

  <img src="http://i0.wp.com/lh3.googleusercontent.com/-mFaOm0EGIvA/VqeJYe_b_yI/AAAAAAAAADA/FDiCN9Zp_hg/w720-o/static-vs-dynamic-web-inside.png?w=734&ssl=1" width="500">

## 04.01.2019

- linux:

  - `wget`: url에 있는 파일을 다운로드할 수 있는 명령어다. 5단계까지 하위 폴더의 모든 파일을 다운로드할 수 있다. 이미지 url은 single/double quote로 감싸주는게 올바른 표혀이다.
    - `--recursive/-r`: 하위폴더를 포함해서 존재하는 모든 파일을 다운로드한다.
    - `-l`: level. 5단계에서 더 아래로 들어가기 위해서 사용한다.
    - `-np`: no-parent. recursive옵션을 주고 실행할때 부모 디렉토리의 파일을 다운받지 말라는 뜻이다.
    - `--reject *.*`: `*.*`를 제외하고 다운로드할 수 있다.
    - `-P DIR_NAME`: 특정 디렉토리에 파일을 받고싶을 때 사용한다.
  - `nohup`(No Hang Up): 백그라운드 명령을 할 수 있다.
  - `apt`(Advanced Packaging Tool): 패키지 관리 명령어이다. `apt-get`, `aptitude`과 같은 의미로 사용한다.
  - `sudo`(Superuser):

- RPM(RPM Package Manager <= Red Hat Package Manager): 리눅스 레드햇 계열에서 사용하는 프로그램관리 명령어이다. 필요한 라이브러리를 개별적으로 설치해야 하기때문에 의존성 라이브러리를 설치하는데 어려움이 많다. 온라인 저장소에 접속하는게 불가능하며 소프트웨어 업데이트가 불가능하다.
- Yum(Yellow dog Updater and Modifier): rpm의 불편함을 개선하고자 등장한 명령어이다. 온라인 접속을 통해 의존성 라이브러리의 업데이트 자동확인이 주목적이다.

- ubuntu서버에 파일 전송방법:

  - putty의 pscp를 이용한 업로드
  - node서버에서 multer 등을 통해 업로드
  - FTP서버를 통해 업로드
    - os 방화벽 설정에서 ftp허용 후 콘솔에서 업로드:
      - `ftp 서버주소`를 입력한다.
      - 사용자id로 로그인한다
      - `put 파일주소`: 우분투의 현재 위치에 저장한다.
      - `get 파일주소`: os로 파일을 가져온다.
      - `quit`: 종료 명령어.
    - filezilla같은 FTP프로그램을 사용해야한다.

- scp(Secure Copy): 로컬에서 원격서버로 파일을 복사해 올리거나 내려받을때 사용하는 유닉스계열 유틸이다. scp를 통해 파일을 복사할때 계정 패스워드 또는 키파일 인증이 필요하다.

  - 파일 업로드: `$ scp 보낼파일 서버사용자계정@서버주소:복사될경로`
  - 파일 다운로드: `$ scp 서버사용자계정@서버주소:가져올파일경로 복사될경로`

- FTP(File Transfer Protocol): 원격서버에 필요한 파일을 올리기 위한 도구이다.
- telnet: 원격서버를 마치 직접 콘솔에서 사용하는 것처럼 작업하게 해주는 도구이다.

- tomcat: 아파치 재단의 오픈소스 프로젝트이다. 동적 웹을 만들기 위한 웹서버이며, jsp, asp, php 등은 톰캣에 전달된다. db 등 서비스가 가능해진다.

- UUID(Universally Unique Identifier):
- GUID(Globally Unique Identifier):

- 도커를 사용하기 위해서는 bios에서 가상화 옵션을 활성화시켜줘야 한다.

- python:

  - 멀티라인: `"""` 혹은 `'''`으로 감싸 입력한다.
  - 문자열을 encode하면 byte형이 되고 byte형을 decode하면 문자열이 된다.
  - function:

  ```py
  def 함수명(파라미터):
    실행될 코드
    return 결과

  def square(x):
    return x * x

  square(5)
  # 25
  ```

  - module: `from 파일명 import (함수명, 함수명)`을 사용하고 모든 함수를 가져올떄는 `*`를 사용한다.

  ```py
  # test.py
  print(__name__) # __main__
  import test # test
  ```

  - sys: 이 모듈을 통해 실행시 인자값을 받을 수 있다.

  ```py
  # test.py
  import sys

  var1 = sys.argv[1]
  var2 = sys.argv[2]
  var3 = sys.argv[3]

  print "var1 = " + var1 # var1 = 1
  print "var2 = " + var2 # var2 = 2
  print "var3 = " + var3 # var3 = 3
  print sys.argv[0] # test.py
  ```

## 05.01.2019

- python:

  - docstring: 모듈, 함수, 클래스, 메소드 정의 바로 밑에 오는 문자열 리터럴이다. 해당 객체의 `__doc__` 속성으로 변환되며 접근할 수 있다. `'''`, `"""` 혹은 `***` 내부에 작성할 수 있다.

  ```py
  class Class:
  ***
  문서화 내용
  ***

    def function(param):
    '''
    문서화 내용
    :param param: 파라미터
    '''
  ```

  - shebang: sharp(#) + bang(!)의 합성어이다. 유닉스계열(linux, mac) 스크립트(bash 등) 최상단에서 파일을 해석해줄 인터프리터의 절대경로를 지정한다. 일반적으로 `/usr/bin/env`파일을 이용한다. python을 입력할 필요없이 실행하려면 `$ chmod +x 파일명`으로 권한을 부여한 다음 파일명을 입력해 실행시킨다. 여러사람이 한 파일으 공유할떄는 `env`를 이용해 작성하는 것이 좋다.

  ```py
  #!인터프리터절대경로
  #!/usr/bin/env 언어이름
  ```

## 06.01.2019

- python:

  - default value:
    - 정의된 함수가 처음 작동할때 값 그대로이며 실행을 여러번 해도 바뀌지 않는다.
    - 값을 `None`으로 하고 `None`인 경우에만 값을 할당하는 식으로 예상치 못한 결과를 피할 수 있다.
  - position arg unpacking: 리스트, 튜플같이 인덱스가 존재하는 객체에 `*`표시를 붙여 인자로 입력하면 함수의 정의된 위치에 맞게 입력된다. 하지만 인자의 수와 입력하는 객체의 수가 다르면 에러가 발생한다. 변수 대신 바로 입력도 가능하고 정의할때도 가능하다.

  ```py
  def function(a, b, c):
    return b, a, c

  p = [1, 2, 3]
  function(*p) # (2, 1, 3)
  ```

## 07.01.2019

- docker: 도커를 개발환경으로 사용하면 개발=테스트=운영이 동일한 환경에서 실행되는 놀라운 상황을 볼 수 있다.
  - 과정:
    - 소스복사
    - 패키지 설치
    - 서버 실행

## 08.01.2019

- grid computing: 하나의 작업을 동시에 여러대의 컴퓨터가 분할해 처리하는 기술.
- LXC(LinuX Containers): 전가상화(full virtualization)나 반가상화(paravirtualization)처럼 os 위에 가상머신이 따로 돌아가는게 아니라 os영역에서 공유 라이브러리를 가지고 유저가 생성하는 프로세스 단위로 성능 분리를 하는 기술.
- image: 어떤 디스크의 내용을 통째로 파일로 옮겨놓은 것을 말한다. 도커에서는 분리된 환경을 image라고 한다.
- snapshot: 특정시점의 코드를 스냅샷이라고 해서 관리할 수가 있다. 클라우드 서버나 볼륨을 사진 찍듯 그대로 저장해 백업하는데 사용한다.
- instance: 클라우드 상의 가상 서버를 말한다.
- server:
  - cache server: 자주 요청하는 컨텐츠는 사용자와 가까운 위치에 저장시킬 수 있어 빠르게 데이터를 응답할 수 있다.
  - woker server:
- docker: 기본적으로 root권한이 필요하다.

  - root 권한 설정:
    - `sudo usermod -aG docker [사용자명]`: 사용자에게 권한을 준다.
    - `sudo usermod -aG docker $USER`: 현재 접속중인 사용자에게 권한을 준다.
  - image 만드는 방법: 사실 둘다 같은 방법이다.

    - Dockerfile 작성
      - Dockerfile instructor의 수에 따라 layer 갯수가 결정된다.
      - `FROM [언어 || 플랫폼 || os]`: 언어, 플랫폼 혹은 os에서 시작한다. `FROM scratch`는 맨 땅에서 시작한다는 뜻으로 쓴다.
      - `COPY [파일명] [디렉토리명]`: 파일을 어디 디렉토리에 복사한다.
      - `CMD [실행할 명령]`: 이미지를 구동하는 컨테이너가 실행할 명령이다.
      - `MAINTAINER [이름] [<메일주소>]`: 도커파일을 생성, 관리하는 사람을 입력한다.
      - `RUN`: 직접 쉘 명령어를 실행하는 명령어이다.
      - `EXPOSE [포트]`: 가상머신에 오픈할 포트를 지정한다.
      - `docker build`: Dockerfile을 참조해서 이미지를 만들어주는 명령이다.
        - 빌드 과정에서 캐시를 사용해서 매우 빠르게 빌드를 할 수 있다. 중간에 빌드가 실패하더라도 성공했던 명령어까지는 시간 소모 없이 빠르게 진행하도록 설계되었다. 필요하다면 중간 이미지에 접근하거나 직접 중간 이미지로부터 다른 이미지를 생성하는 것도 가능하다.
        - 도커 생태계에 있는 오픈소스 앱들은 아에 도커파일을 프로젝트에 포함하고 있다.
        - 빌드 도중에는 키보드 입력을 할 수 없기 때문에 (y/n)을 물어보는 것을 방지하려면 `-y` 옵션을 추가해야 한다.
    - container에서 `docker commit`을 통해 image 생성

      - container: 이미지를 사용해 생성되고 실행된다. 여기에는 앱이 필요로 하는 최소한의 구동환경만 담으면 된다.

        - 격리된 운영환경
        - 앱 개발환경:
          - 운영환경과 동일한 환경에서 개발할 수 있다. 왜 로컬에서는 잘되는데 서버에서는 안되지라고 할 수 없게 돼버린다.
          - 컴퓨터의 os나 환경이 업그레이드 되어도 기존 개발환경을 유지해 사용할 수 있다. 가상화 기술을 쓰는 것보다 자원이 적게 든다.
          - 서로 다른 개발환경을 사용하는 두 개 이상의 프로젝트를 동시에 수행할 수 있다.
          - 만든지 오래된 앱을 유지보수할 때 어떤 환경이었는지를 기억해낼 필요가 없어진다.
        - `docker run [이미지] [경로]`: 컨테이너를 실행한다.
        - `docker restart [컨테이너 id]`: 종료된 컨테이너를 다시 살린다.
        - `docker attach [컨테이너 id]`: 재시작한 다음에는 컨테이너 안으로 들어가지 않는다. 그래서 컨테이너 안으로 다시 들어가기 위한 명령어이다.
        - `docker ps`: 동작중인 컨테이너를 확인할 수 있다.
        - `docker ps -a`: 정지된 컨테이너를 확인할 수 있다.
        - `docker rm [컨테이너 id], [컨테이너 id]`: 컨테이너를 삭제한다.
        - `` docker rm `docker ps -a -q` ``: 컨테이너를 모두 삭제한다.

        <img src="https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-1/docker-image.png" width="500">

    - image: 앱이 필요로 하는 것이 매우 단순하거나 의존성 관계를 잘 알고 있으면 구성하기 쉽다. 해당 이미지에서 종료상태를 포함한 파생된 컨테이너가 하나라도 있다면 이미지는 삭제할 수가 없다.
      - `docker images`: 이미지를 확인할 수 있다.
      - `docker rmi [이미지 id]`: 이미지를 삭제한다.
      - `docker rmi -f [이미지 id]`: 컨테이너를 삭제하기 전에 이미지를 삭제한다. `-f`는 강제 삭제 명령어다.
      - `docker commit [ID] [image name]`: 수정사항을 기반으로 새로운 이미지를 만들기 위해 버전관리를 한다.

  - 실제 서비스에서 돌리려면:
    - 생성된 이미지 관리: 다른 docker시스템에 배포하기 위한 방법을 알아야한다.
    - 실제서비스를 container에 올리고 관리하는 방법: 서버에 웹서버를 몇개 띄울지 결정하고 관리하는 방법을 알아야한다.
    - docker host와 guest간 통신관리: docker가 설치된 실제 서버와 그 위에 돌아가는 container들 사이에 오가는 통신을 이해해야 한다. 포트 바인딩 = 포트 포워딩.
    - docker API: api를 알아야 한다.
  - `docker version`: Client와 Server정보가 나온다. 도커는 하나의 실행파일이지만 실제로 클라이언트와 서버 역할을 각각 할 수가 있다. 도커 클라이언트가 도커 서버로 명령을 전송하고 결과를 받아 터미널에 출력한다.

  <img src="https://subicura.com/assets/article_images/2017-01-19-docker-guide-for-beginners-2/docker-host.png" width="500">

  - 배포:

    - 기존은 ftp, ansible 등 다양한 배포툴로 배포 방식을 정의하는 것이 불가능했다.
    - 컨테이너를 사용하면 어떤 언어, 프레임워크던 간에 배포방식이 동일해지고 과정도 단순해진다. 그저 이미지를 다운받고 컨테이너를 실행하면 끝난다. 서버에서 컨테이너를 실행하는 방법을 안다면 배포하는 방법 또한 알고 있는 것이다.
    - 업데이트도 배포와 큰 차이가 없다. 최신 이미지를 기반으로 새 컨테이너를 만들고 이전 컨테이너를 중지, 삭제하면 된다. 그냥 통째로 바꾸면 끝난다. 컨테이너를 중지하지 않고 컨테이너 내부에 접속해 소스를 업데이트하는 방법도 가능하지만 컨테이너의 장점을 살릴 수 없는 잘못된 패턴이다. 무중단을 고려한 로드밸런서와 2대 이상의 컨테이너를 사용해야 한다.

    <img src="https://subicura.com/assets/article_images/2017-02-10-docker-guide-for-beginners-create-image-and-deploy/docker-update.png" width="500">

- python:
  - args:
    - keyword arg unpacking: dictionary타입 변수에 `**` 표시를 해서 대입한다.
  - type system:
    - 동적타입 언어: 자료형을 실행시점(런타임)에 결정한다.
    - 강타입 언어: 자료형이 맞지 않을시에 에러 발생, 암묵적 변환을 지원하지 않는다.
  - scope: local, enclosed, global, built-in 순서대로 가장 가까운 변수를 우선적으로 사용한다.
    - local: 가장 가까운 함수안 범위이다.
    - enclosed: 함수 안에 함수가 정의될 수 있는데, 가장 가까운 함수가 아닌 두번째 이상 가까운 함수범위이다.
    - global: 함수 바깥 변수 또는 import된 모듈을 말한다. 변수를 글로벌로 쓰고싶으면 `global` 키워드를 사용한다.
    - built-in: 파이썬에 내장되어 있는 함수 또는 속성이다.

## 09.01.2019

- docker compose: cli로 컨테이너를 실행하려면 따로 따로 명령어를 입력해야 하지만, `.yml`파일로 정리하기 편하게 작업할 수 있다. 컨테이너 대신에 서비스라고 부르더라. 한 서비스에는 여러개의 컨테이너를 띄울 수 있다.

  - `Dockerfile-dev`: `Dockerfile`과 같고 서버 구성을 문서화했다.
  - `docker-compose build`: `docker build`와 같고 도커 이미지를 만든다.
  - `docker-compose.yml`: `docker run`의 옵션들과 같고 이미지에 변수들을 붙인다.
  - `docker-compose up`: `docker run`과 같고 이미지를 실제로 실행한다.

- node-gyp: 네이티브 애드온을 컴파일하기 위한 크로스 플랫폼 커맨드라인 툴이다.
- create-react-app: 빌드하고 나면 정적파일이 생겨 배포할 준비가 된다. 깃헙페이지에도 사용할 수가 있다.
- build automation:

  - docker: 개발환경을 이미지로 만들어서 어디서든 똑같은 개발환경을 유지할 수 있다.
  - travis ci: 테스트 후 깃으로 자동적으로 배포할 수 있다.

- servers: 4개 정도로 서버를 나눠 만들 수 있다. 물론 aws 인스턴스를 이용해서 만든다.
  - web: ec2, lightsail. 서버 구동할 때 정적 파일은 노드가 처리하는 것보다 nginx나 apache가 처리하는 것이 훨씬 성능이 좋다.
  - back up: s3
  - database: rds
  - image: s3

## 10.01.2019

- deployment: 단순히 로컬 소스를 운영서버로 복사하는 것을 말한다. ftp로 파일을 복사하는 방식은 가장 기본이면서 그럭저럭 동작한다. 배포중 서비스가 잠깐 멈춘다면 새벽에 배포하면 된다. 배포가 탄탄해지면 서비스 개발에 집중할 수 있고 하루에 몇번이고 배포가 가능하다.

## 11.01.2019

- shell script:

  - `set -[optios]`: 스크립트 전체가 아닌 일부분에서만 어떤 기능을 사용한다. 반대로 기능을 없애려면 `set +[option]`을 한다.
  - 파일검사 연산자:
    - `-x`: 읽어들인 부분 중에서 실제 실행을 한 부분을 보여준다.
    - `-e`: 실행문의 결과를 검사하기 위한 옵션이다. `-x`에 의해 출력되는 실행문들의 실행결과가 0이 아닌 값, 즉 실패를 반환했을 떄 쉘스크립트를 종료시킨다.
    - `-v`: 쉘스크립트를 수행하기 위해 읽은 부분을 출력해준다.
  - \`(back quarter): 명령의 결과를 저장하기 위해 파일명이나 디렉토리명 뒤에 입력한다.

- docker:

  - `build`:
    - `-p <호스트 포트>:<컨테이너 포트>`: 호스트와 컨테이너의 포트를 연결한다.
    - `-t <저장소 이름/<이미지 이름>:<태그>`: 이미지에 태그를 붙여준다
  - `run`:

    - `-d`: detached, daemon 모드라고 부르며 컨테이너가 백그라운드로 실행된다.
    - `-p`: 호스트에 연결된 컨테이너의 특정포트를 외부에 노출한다.
      - `<호스트 포트>:<컨테이너 포트>`:
      - `<IP 주소>:<호스트 포트>:<컨테이너 포트>`: 호스트에 네트워크 인터페이스가 여러개이거나 ip주소가 여러개일때 사용한다.
      - `<IP 주소>::<컨테이너 포트>`: 호스트 포트를 설정하지 않으면 호스트의 포트 번호가 무작위로 설정된다.
      - `<컨테이너 포트>`: 컨테이너 포트만 설정하면 호스트의 포트 번호가 무작위로 설정된다.

      ```sh
      # 컨테이너에 호스트의 특정 포트를 바인딩
      # 호스트의 80번 포트를 내부 컨테이너의 80번 포트로 바인딩
      $docker run -i -t --name avilosserver -p 80:80 centos:7

      # 호스트의 특정 IP사용하여 포트를 바인딩할 경우
      # 호스트의 192.168.10.5 아이피주소의 8080포트를 내부 컨테이너의 80포트로 바인딩
      $docker run -i -t -p 192.168.10.5:8080:80 centos:7

      # 복수의 포트를 바인딩 처리
      # 외부 7777 포트를 컨테이너의 77번 포트로 바인딩하며 외부 8080 포트를 컨테이너의 80 포트로 바인딩
      $docker run -i -t -p 7777:77 -p 192.168.10.5:8080:80 centos:7

      # 80번 포트를 내부 컨테이너로 바인딩
      $docker run -i -t -p 80:80 --name centos1 centos:7
      ```

  - Dockerfile:
    - `COPY <호스트 파일> <이미지내부 파일>`: 이미지 생성시 호스트의 파일을 이미지 내부로 복사할 수 있는 명령어이다.
      - 도커파일이 존재하는 경로보다 하위경로에 위치하는 파일만 복사 가능하다. 즉, 부모경로의 참조는 안된다.
      - 별도의 디렉토리를 만들어 그 안에 새로 만들어낼 이미지의 필요한 파일들을 전부 다 넣어놓고 그 디렉토리를 git으로 관리하면 아주 좋은 모델이 된다.
    - `ADD <호스트 파일> <이미지내부 파일>`: `COPY`와 유사하지만 몇가지 추가기능이 있다. `호스트 파일`에 대신 url을 입력할 수 있고 압축파일을 입력하는 경우 자동으로 압축을 해제하면서 복사된다.
    - `WORKDIR`: 생성할 컨테이너 내의 현재 경로를 나타낸다. 어떤 작업들을 수행하기 이전에 기본디렉토리같은 개념이 된다.
    - `CMD`: 도커파일이 이미지로 생성되고 컨테이너로 만들어지며 실행되는 첫명령어를 가리킨다. 따라서 도커파일 내부에는 단 하나의 `CMD`명령어만 존재한다. 만일 여러개의 명령을 사용하면 맨 마지막에 있는 명령만 동작할 것이다.
    - `ENDPOINT`: 컨테이너를 실행할때 어떤 프로그램이 실행되야 하는지에 대한 부분을 조정할 수 있다. 도커파일에서는 최소한 `ENDPOINT`와 `CMD` 둘 중 하나의 명령을 가지고 있어야 한다. 데몬프로세스처럼 실행가능한 형태로 만들때 사용한다.
    - `USER`: 컨테이너 내에서 명령이 실행될떄 필요한 사용자를 설정해주는 명령이다.
    - `VOLUME <컨테이너 파일>`: 실행중인 컨테이너 내의 디렉토리와 호스트의 디렉토리를 연결시켜주는 혹은 공유할 수 있는 명령어이다. `docker run -v <호스트 파일>:<컨테이너 파일> <이미지 이름>`으로 사용할 수 있다.

- 도커를 이용한 배포가 갖는 특징:

  - 확장성:
    - 이미지만 만들어놓으면 컨테이너는 그냥 띄우기만 하면 된다.
    - 다른 서버로 서비스를 옮기거나 새로운 서버에 서비스를 하나 더 띄우는건 `docker run`하나로 끝낼 수 있다.
    - 개발서버를 띄우기도 편하고 테스트서버를 띄우기도 간편하다.
  - 표준성:
    - 도커를 사용하지 않을경우 언어별로 서비스들의 배포 방식이 다르다.
    - 컨테이너라는 표준으로 서버를 배포하므로 모든 서비스의 배포과정이 동일해진다.
  - 이미지:
    - 이미지에너 컨테이너를 만들기 때문에 이미지를 만드는 과정은 필수다.
    - 이미지를 저장할 곳이 필요하다.
  - 설정:
    - 보통 환경변수로 제어한다.
    - 하나의 이미지가 환경변수에 따라 동적으로 설정파일을 생성하도록 만들어야 한다.
  - 공유자원:
    - 컨테이너는 삭제 후 새로 만들면 모든 데이터가 초기화된다.
    - 업로드 파일을 외부 스토리지와 링크하여 쓰거나 s3같은 별도 저장소가 필요하다.
    - 세션, 캐시를 파일로 사용한다면 외부로 분리시켜야 한다.

- hadoop: 빅데이터를 저장, 처리, 분석하는 오픈소스 프레임워크이다. java, scala를 사용해서 프로그램한다.

  - distributed: 수십만 대의 컴퓨터에 자료 분산 저장 및 처리를 한다.
  - scalable: 용량이 증대되는대로 컴퓨터도 추가된다.
  - fault-tolerant: 하나 이상의 컴퓨터가 고장나는 경우에도 시스템이 정상적으로 동작한다.

- d3.js: 오픈소스 데이터 시각화 라이브러리. d3(Data Driven Document)의 줄임말이다. 빅데이터를 보여주는 문서를 조작할 수 있고 시각화 전문툴은 아니지만 개인이 사용하기에는 적합할 수도 있다.

- 개발과정:
  - 기능별로 브랜치를 만든다.
  - 메인 개발소스를 master로 두고 바로 push 할 수 없게 각 브랜치를 pr을 보내고 코드리뷰 후에 merge한다.
  - master가 테스트서버에 배포되고 테스트가 끝나면 수동으로 master브랜치를 production브랜치로 머지한다.
  - production 브랜치가 push되면 바로 운영서버로 배포한다.

## 12.01.2019

- python:
  - `dir()`: 내장함수나 객체가 가진 변수나 함수리스트를 보여준다. import한 모듈, 언더스코어로 이름지어진 기능을 하는 속성들을 볼 수 있다.
    - `__name__`: 함수의 명칭을 string으로 리턴한다.
    - `__doc__`: 함수의 docstring을 출력한다.
  - exception: 정상적인 프로그램 흐름을 중단시키는 에러를 가리킨다.
    - `except`: 에러를 예외로 보도록 하는 코드블럭이다. 인자로는 `ValueError:`, `TypeError:` 혹은 둘 다(`()`를 사용해서) 올 수 있다.
      - `as`: `as` 뒤에 변수를 입력해 에러정보를 얻어낼 수 있다.
    - `raise`: 발생시키고자 하는 에러메시지를 콘솔에 출력할 수 있다.
    - `finally`: 예외가 발생하건 않건 무조건적으로 처리하는 블럭이다.

## 13.01.2019

- python:
  - 예외처리되지 않는 에러:
    - `IndentationError`:
    - `SyntaxError`:
  - 코딩스타일: 파이썬은 EAFP 스타일을 권장하며 철학이다.
    - EAFP(It's Easier to Ask Forgiveness than Permission): 허락보다 용서구하는 것이 쉽다. 예외처리를 활용해 검사를 수행하지 않고 일단 실행하고 예외처리를 진행하는 스타일이다.
    - LBYL(Look Before You Leap): 뛰기 전에 봐라. 실행하기 전에 에러가 날만한 요소를 조건절로 검사하고 수행하는 스타일이다.
  - os별 처리: 콘솔에서 아무키나 누르는 것과 같은 단일키 누르기를 감지하려면 운영체제별 모듈을 사용해야 한다.
    - windows: msvcrt
    - unix: sys, tty, termios
  - list 표현식: list, set, dictionary안에 for문이나 if문을 사용해 컬렉션 내부 원소를 구성시킬 수 있다.
  - set 표현식: 리스트와 표현방법이 같지만 `{}`를 이용한다.
  - dictionary 표현식: 키-밸류를 이용하고 `{}`를 이용하는 것 말고는 위와 방법은 동일하다.

## 15.01.2019

- storing fuction:

  - variable: `let fn = function doSth() {}`
  - object: `let obj = { doSth: function() {} }`
  - array: `arr.push(function doSth() {})`

- Travis CI & AWS CodeDeploy로 배포 자동화 구축:

  - travis ci 연동하기
    - github 저장소중 원하는 프로젝트명을 찾아 상태바를 활성화시킨다.
    - `.travis.yml`파일 생성후 설정한다.
    - travis ci 라벨을 추가한다.
  - code deploy 연동하기
    - 사용자를 새로 하나 생성한다.
    - aws 액세스 유형선택에서 프로그래밍 방식 액세스를 체크한다.
    - code deploy와 s3(빌드 파일 백업용) 권한을 할당받는다.
    - 액세스키와 비밀키가 생성되면 파일로 키를 다운받는다.
  - s3 버킷 생성하기
    - 빌드된 파일을 보관할 s3 버킷을 생성한다.
  - aws iam role 설정하기
    - 액세스키, 비밀키를 사용해 원하는 기능을 수행시킬 iam role을 추가한다.
      - 역할만들기를 누른후 사용사례에서 ec2, code deploy를 선택한다.
      - 권한을 연결시킨다.
  - ec2에 code deploy 연동하기
    - code deploy role을 추가한다.
    - code deploy agent를 설치한다.
    - ec2 인스턴스가 부팅되면 자동으로 code deploy agent가 실행될 수 있게 쉘스크립트를 작성한다.
  - travis ci와 s3 연동하기
  - code deploy로 스크립트 실행하기

- EC2에 서비스 배포:

  - ec2 인스턴스에 git설치 후 프로젝트를 클론한다.
  - 쉘스크립트를 작성한다.
    - 깃에서 코드를 풀한다.
    - 가져온 코드를 빌드한다.
    - 현재 앱이 구동중이면 프로세스를 죽이고 새로 빌드한 파일로 다시 실행한다.
  - 외부에서 서비스 접속이 가능하도록 ec2 대시보드에서 설정을 한다.
    - 보안그룹 - 현재 프로젝트의 인스턴스 - 인바운드 탭에서 사용자 지정에 포트를 추가한다.
    - 설정을 마치면 퍼블릭 dns에 url이 생긴다.

- linux:

  - `pgrep`: process id만 추출하는 명령어이다.
    - `-f`: 프로세스 이름으로 찾는 옵션이다.

- docker: go로 제작된 컨테이너 기반 가상화 도구이다.

  - `exec [옵션] [컨테이너 id] [명령]`: 외부에서 컨테이너 안의 명령을 실행한다.

    - `-d`: 명령을 백그라운드로 실행한다.
    - `-i`: 컨테이너와 연결되어 있지 않더라도 표준입력을 유지한다.
    - `-t`: 배쉬를 사용하려면 이 옵션을 설정해야 한다. 설정하지 않으면 명령을 입력할 수는 있지만 쉘이 표시되지 않는다.
    - `-it`: stdin 표준 입출력을 열고 가상 tty를 통해 접속하겠다는 의미이다.
    - 명령자리에 `/bin/bash`를 준다면 배쉬 쉘을 볼 수 있다.
    - `exec`명령을 활용하면 `exit` 또는 ctrl+d로 빠져나오더라도 컨테이너가 종료되지 않는다.
    - 배쉬 쉘을 이용하지 않더라도 컨테이너 내에 패키지를 `apt-get`, `yum`등의 명령을 사용해 설치할 수가 있다.

      ```sh
      $sudo docker exec [컨테이너 id] apt-get update
      $sudo docker exec [컨테이너 id] apt-get install -y redis-server
      ```

  - `attach [컨테이너 id]`: 현재 실행중인 컨테이너에 접속한다.
    - ctrl+p -> ctrl+q를 누르면 컨테이너는 종료되지 않고 그냥 빠져나올 수가 있다.
    - `exit` 또는 ctrl+d로 빠져나오면 컨테이너가 종료된다.
  - `run [옵션] [이미지 이름] [명령]`:

    - `--name [이름]`: 컨테이너 이름을 마음대로 정할 수가 있다. 하지만 `[a-zA-Z0-9][a-zA-Z0-9_.-]`만 입력이 가능하다.

  - `start [컨테이너 id]`: 컨테이너를 구동시킨다.
  - `restart [컨테이너 id]`: 컨테이너를 재시작한다.
  - `stop [컨테이너 id]`: 컨테이너를 종료한다.

## 16.01.2019

- sql:

  - 집계함수: `WHERE`절에서는 사용할 수가 없고 `GROUP BY`를 사용하지 않는 경우에는 일반 컬럼과 사용할 수 없다.
    - `COUNT`: `*`을 사용할 경우 `NULL`을 포함한 행의 갯수를 출력한다. 다른 함수들은 `*`을 사용하지 않는다.
    - `VARIANCE`: 분산을 계산한다.
    - `STDDEV`: 표준편차를 계산한다.
  - `GROUP BY`: 결과물을 정렬하고 상대적으로 느리다.

  ```sql
  SELECT [COLUMN_NAME] FROM [TABLE_NAME] GROUP BY [COLUMN_NAME]
  ```

  - `DISTINCT`: 하나의 컬럼만을 조회할때 사용한다. 집계함수가 걸린 컬럼과 다른 컬럼을 `SELECT`하는 쿼리는 불가능하다. 결과물을 정렬하지 않고 상대적으로 빠르다.

  ```sql
  SELECT DISTINCT [COLUMN_NAME] FROM [TABLE_NAME]
  ```

  - `HAVING`: `GROUP BY`절에서는 조건문을 `WHERE`를 쓰지 않는다.

- docker:

  - `tag [이미지 이름] [계정]/[이미지 이름]:[버전]`: 커밋한다.
  - `push [계정]/[이미지 이름]:[버전]`: 푸시한다.

- blockchain: 클래스마다 생성자는 하나만 존재해야 한다. 블록의 모든 내용을 가져와 해시로 특정 블록의 해시를 얻는다. 해시 값을 문자열해서 해시한다.

  - 요소: index, timestamp, data, hash, previousHash

    <img src="https://t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/RDD/image/FFPB76V-yOhL0MwGyDKGe6OB_Dc.png" width="500">

- mysql

  - migration: mysql migration toolkit 혹은 workbench를 사용해서 할 수가 있다.
  - error 2002 (hy000)
    - 원인:
      - mysql 데몬이 죽어있다.
      - my.cnf파일 자체가 깨졌을 경우에 해당 메시지가 나타난다.
    - 참고:
      - mysql.sock파일은 원래 비어있는 파일이고 mysql이 실행되면 자동으로 생성된다.
    - 해결책:
      - 완전 삭제 후 재설치를 한다.

- graph: 정점과 간선의 집합을 말한다.
  - directed graph(digraph): 방향성이 있는 그래프를 말한다.
    - outdegree: 나가는 간선의 갯수를 말한다.
    - indegree: 들어오는 간선의 갯수를 말한다.
  - undirected graph: 방향성이 없는 그래프를 말한다.
    - degree: 각 정점에 연결된 edge의 갯수를 말한다.

## 17.01.2019

- data type:

  - array:

    - 2차원 배열은 수학에서 말하는 행렬(matrix)를 나타내는데 효과적이다. 5\*5의 배열을 아래와 같이 만들 수 있다.
    - 인덱스로 해당 원소에 접근할 수가 있다.

    ```js
    let twoDimension = new Array(5);
    for (let i = 0; i < twoDimension.length; i++) {
      twoDimension[i] = new Array(5);
    }
    ```

  - linked list:
    - 각각의 원소들은 자기 자신 다음에 어떤 원소인지만 기억하고 있다.
    - 논리적 저장순서와 물리적 저장순서가 일치하지 않는다.
    - tree 구조의 근간이 되는 자료구조이다.
  - tree: 무언가를 저장하고 꺼내는 사공서 벗어나는 자료구조이다.
  - heap:

    - 좌우를 순서대로 차곡차곡 채운 배열에 기반한 완전이진트리 구조의 형식을 하고 있다.

      - 최대힙: 부모의 키값이 자식의 키값보다 크거나 같다.
      - 최소힙: 부모의 키값이 자식의 키값보다 작거나 같다.

      <img src="https://gmlwjd9405.github.io/images/data-structure-heap/types-of-heap.png" width="500">

    - 구현을 쉽게 하기 위해 배열의 첫번쨰 인덱스인 0은 사용하지 않는다.
    - 특정 위치의 노드 번호는 새로운 노드가 추가되어도 변하지 않는다.

  - graph:

    - 연결되어 있는 객체간의 관계를 표현할 수 있는 자료구조이다. 지도, 지하철의 최단경로, 전기회로의 소자, 도로 등을 표현한다.
    - 여러개의 고립된 부분그래프로 구성될 수가 있다.
    - 오일러경로: 그래프의 모든 정점에 연결된 간선의 개수가 짝수일 때만 경로가 존재한다.
    - 2개 이상의 경로, 다시말해 노드 사이에 양방향 경로를 가질 수 있다.
    - 루트, 부모-자식의 관계까 없다.
    - 순환 혹은 비순환이며, 방향그래프와 무방향 그래프가 있다.
    - weighted graph: 간선에 비용이 할당된 그래프를 말하며 네트워크라고도 한다. 도시간의 연결, 도로의 길이, 회로소자의 용량, 통신망의 사용료 등을 구현할 수 있다.
    - 탐색방법: 공통적으로 어떤 노드를 방문했는지 여부를 반드시 검사해야한다.
      - DFS(Depth First Search):

        - 넓게 탐색하기 전에 깊게 탐색하는 방법이다.
        - 모든 노드를 방문하고자 하는 경우에 선택한다.
        - 보다 간단하다.
        - 보다 느리다.
        - 자기 자신을 호출하는 순환알고리즘의 형태를 가진다.
        - 후입선출 원칙을 가진 자료구조인 스택을 사용한다.
        - 탐색과정:

          1. 시작노드를 방문한다. 방문한 노드는 방문했다고 표시한다.
          2. a와 인접한 노드들을 차례로 순회한다. 인접한 노드가 없다면 종료한다.
          3. a와 이웃한 노드 b를 방문했다면, a와 인접한 다른 노드를 방문하기 전에 b의 이웃노드를 전부 방문해야 한다.
          4. b의 분기를 완벽히 탐색했다면 a에 인접한 노드 중 아직 방문하지 않은 노드를 찾는다.

          <img src="https://gmlwjd9405.github.io/images/algorithm-dfs-vs-bfs/dfs-example.png" width="500">

      - BFS(Breadth First Search):
        - 깊게 탐색하기 전에 넓게 탐색하는 방법이다.
        - 두 노드 사이의 최단경로 혹은 임의의 경로를 찾고싶을 때 사용한다.
        - 보다 복잡하다.
        - 보다 빠르다.
        - 재귀적으로 동작하지 않는다.
        - 직관적이지 않은 면이 있다.
        - 선입선출 원칙을 가진 자료구조인 큐를 사용한다.
        - prim, dijkstra알고리즘과 유사하다.
        - 탐색과정:
          1. 시작노드를 방문한다. 
          2. 큐에 방문한 노드를 삽입한다.
          3. 초기 상태의 큐에는 시작노드만을 저장한다. a의 이웃노드를 모두 방문한 다음에 이웃의 이웃들을 방문한다.
          4. 큐에서 꺼낸 노드와 인접한 노드를 모두 차례로 방문한다.
          5. 인접한 노드가 없다면 큐의 앞에서 노드를 꺼낸다.
          6. 큐가 소진될 때까지 계속한다. 

          <img src="https://gmlwjd9405.github.io/images/algorithm-dfs-vs-bfs/bfs-example.png" width="500">

- cmake: c 프로젝트를 빌드하기 위한 `Makefile`을 보다 편리하고 쉽게 작성하게 해주는 툴이다.
- python 함수이름: 소문자로 쓰고 가독성을 위해 언더스코어(_)를 사용한다.

## 18.01.2019

- git:
  - `commit.template`: 어떤 파일을 작성하고 예를들어 `$HOME/.gitmessage.txt`라고 만든다. 다음과 같은 명령을 한다.
   
  ```sh
  $ git config --global commit.template $HOME/.gitmessage.txt
  $ git commit
  ```

  그러면 커밋할때 텍스트파일의 내용을 편집기에 자동으로 채워준다. 팀커밋 할떄 메시지 규칙이 있다면 그 규칙에 맞게 템플릿 파일을 만들 수 있다.

- linux: 
  - POSIX(Portable Operating System Interface uniX): 유닉스의 애플리케이션 프로그래밍 인터페이스라는 규격이다.  정규표현식도 POSIX의 일부이다. 하지만 현재는 더 빠른 알고리즘을 쓰는 PCRE로 갈아탔다고 한다.

## 19.01.2019

- devops:
  - 지속적 통합:
  - 지속적 전달:
  - 마이크로 서비스:
  - 코드형 인프라:
  - 모니터링 및 로깅:
  - 커뮤니케이션 및 협업:

## 20.01.2019

- docker:
  - `run` 옵션:
    - `-e`: 컨테이너에 환경변수를 지정한다. 
    - `-p`: 호스트에 연결된 컨테이너의 특정포트를 외부에 노출한다.
    - `-w`: 컨테이너 안의 프로세스가 실행될 디렉토리를 설정한다.

- python:
  - iterable 객체: 반복 가능한 객체를 말한다.
    - list, dict, set, str, bytes, tuple, range는 iterable하다.
  - iterator 객체: 값을 차례대로 꺼낼 수 있는 객체를 말한다.
    - iterable한 객체를 내장함수나 iterable객체의 메소드로 객체를 생성할 수가 있다.
    - `iter()` 함수를 이용해 iterator 객체를 만들 수 있다.
  - generator: iterator를 생성해주는 함수이며 함수 안에 `yield` 키워드를 사용한다. set, dictionary의 표현식 내부도 generator이다.
    - `yield from`: python 3.3 이상부터 사용 가능한 기능이다. `for`문 대신 iterable한 객체를 `yield`할 때 사용한다.

    ```py
    # python 3.3 미만 버전
    def generator():
      a = [1, 2, 3]
      for i in a:
          yield i

    gen = generator()
    list(gen) # [1, 2, 3]
    
    # python 3.3 이상 버전
    def generator():
      a = [1, 2, 3]
      yield from a

    gen = generator()
    list(gen) # [1, 2, 3]
    ```
 
  - itertools: 반복가능한 데이터를 처리하는데 유용한 함수와 제너레이터를 포함하는 모듈이다.
  - class: 
    - 특징:
      - 객체의 구조와 행동을 정의한다. 
      - 객체의 클래스는 초기화를 통해 제어한다.
      - 복잡한 문제를 다루기 쉽도록 만든다.
    - 정의: 
      - 대부분 네이밍할때 단어 사이에 `__`를 넣는다면 클래스는 CamelCase를 사용한다.
      - `class` 키워드를 사용해 새로운 클래스를 작성한다.
    - 생성:
    
    ```py
    # 기본 클래스 생성
    class Example:
      pass
    
    e = Example() # 변수에 할당한다. new 키워드는 따로 없다.
    type(e) # <class 'Example'>

    # 클래스 메소드 작성  
    class Example:
      def number(self): 
        return '1'

    e = Example()
    e.number() # '1'
    ```

      - 메소드 첫번쨰 파라미터명은 관례적으로 `self`라는 이름을 사용한다.
      - 호출시 호출한 객체 자신이 전달되기때문에 `self`가 유래됐다.
      - 이것을 이용해 클래스에서 바로 메소드로 접근하면서 `Example`의 객체 `e`를 파라미터로 전달함으로서 같은 값을 리턴한다.

    ```py
    Example.number(e) # '1'
    ```   

## 21.01.2019

- pgsql: 
  - 컬럼에 배열을 바로 사용할 수 있다.
  - json 타입을 지원한다.
  - join을 중첩루프로 돌려서 코어를 하나밖에 못쓰는 mysql보다 성능이 좋다.
- ERD(Entity Relationship Diagram): 개체 관계 모델을 말한다. 테이블관 관계를 도식화해서 나타낸 다이어그램이다.
  - 작업순서:
    - entity를 그리고 배치한다.
    - entity간 관계를 설정한다.
    - 관계명과 참여도, 필수여부를 설정한다.

## 22.01.2019

- 정적페이지 
  - 호스팅: netlify, github page
  - 생성기: gatsby, jekyll 

- sequelize:
  - `association`을 설정하면 `include`옵션을 통해서 `left join`을 할 수가 있다.
  
## 23.01.2019

- sql:
  - 다대다(N:M)관계: 고객테이블, 상품테이블이 있다고 가정할때 한명의 고객은 여러개의 상품을 살 수 있다. 그리고 하나의 상품도 여러 고객에게 팔릴 수 있다. 위와 같은 경우를 다대다라고 한다. 따라서 각 테이블의 `PK`가 없게 된다. 물리적으로는 관계가 성립하지만 논리적으로는 성립하지 않아 이 문제를 해결하기 위해 중간에 `고객_상품`테이블을 만들어 두 테이블을 이어줘야 한다.
  - 기본키: 선자연키 후인조키 전략이 좋아보인다. 
    - 자연키: 비즈니스 모델에서 자연스럽게 나오는 속성으로 기본키를 정하는 것을 말한다.
    - 인조키: dbms에서 본다면 mysql의 `auto increment`라고 볼 수 있다.
  - 외래키: 
    - 식별관계: 부모테이블의 기본키로 지정된 컬럼을 참조하는 __자식테이블의 기본키 컬럼이 `PK`이다.__
    - 비식별관계: 부모테이블의 기본키로 지정된 컬럼을 참조하는 __자식테이블의 기본키 컬럼이 `PK`가 아니다.__

  <img src="http://tcpschool.com/lectures/img_mysql_relationship.png" width="500">
  
  - 용어:
    - 열(column) = 필드(field) = 속성(attribute)
    - 행(row) = 튜플(tuple) = 레코드(record)

- javascript:
  - class: 같은 이름의 class를 여러개 사용할 수 있다.
  - id: 같은 이름의 id를 한 문서에 단 하나만 가질 수 있다.

## 24.01.2019

- javascript:
  - NaN(Not a Number): 숫자가 아니다.
  - 배열메소드:
    - `push([배열값])`
    - `splice([기준인덱스], [삭제할 배열수], [추가할 배열])`

## 25.01.2019

- javascript: 
  - 배열 메서드:
    - `reduce()`: `map()`, `filter()`, `find()`로 구현할 수 있는 문제들은 모두 구현할 수있는 유연한 메서드이다.
      - `reduce(callbackFunction(accumulator, currentValue[, currentIndex, array]){...}[, initialValue])`
      - accumulator: 직전의 콜백이 리턴한 계산값
      - currentValue: 현재 콜백, 배열의 요소값
      - currentIndex: 현재 콜백이 진행되고 있는 시점의 배열의 인덱스값
      - array: 작업을 수행하는 배열 자체
      - initialValue: 콜백의 첫번째 호출에서 첫번쨰 인수로 사용되는 값

    - `indexOf()`: 
      - `indexOf(searchValue[, fromIndex])`
      - searchValue: 필수요소이며 찾으려는 문자열을 넣는다.
      - fromIndex: 선택요소이며 검색을 시작할 인덱스값이다. 입력하지 않으면 처음부터 검색한다.
      - 대소문자를 구별한다.
      - 찾으려는 문자열이 없으면 -1을 반환한다.

    - `filter()`: 배열의 요소들을 걸러내는 것이 목적이다.
      - `filter(callback(element[, index[, array]])[, thisArg])`
      - element: 처리할 현재 요소값
      - index: 처리할 현재 요소의 인덱스값
      - array: filter를 호출한 배열 자체
      - thisArg: 콜백을 실행할 때 `this`로 사용하는 값

    - `map()`: 배열의 요소를 일괄적으로 변경하는데 효과적이다.
      - `map(callback(currentValue[, index[, array]])[, thisArg])`
      - currentValue: 처리할 현재 요소값
      - index: 처리할 현재 요소의 인덱스값
      - array: forEach를 호출한 배열 자체
      - thisArg: 콜백을 실행할 때 `this`로 사용하는 값

    - `find()`: `filter()`와 비슷하지만 단 하나의 요소만 리턴한다.
      - find(callback(element[, index, array])[, thisArg])
      - element: 처리할 현재 요소값
      - index: 처리할 현재 요소의 인덱스값
      - array: find를 호출한 배열 자체
      - thisArg: 콜백을 실행할 때 `this`로 사용하는 값

    - `forEach()`: 
      - `forEach(callback(currentValue[, index, array])[, thisArg])`
      - currentValue: 처리할 현재 요소값
      - index: 처리할 현재 요소의 인덱스값
      - array: forEach를 호출한 배열 자체
      - thisArg: 콜백을 실행할 때 `this`로 사용하는 값

    ```js
    // for문
    let arr = [3, 9, 4, 2, 7, 6];
    for (let i = 0; i < arr.length; i++) {
      if (arr[i] % 2 == 0) {
        console.log(arr[i]);
      }
    }
    // [4, 2, 6]

    // forEach()
    let arr = [3, 9, 4, 2, 7, 6];
    arr.forEach((n) => {
      if (n % 2 == 0) {
        console.log(n);
      }
    });
    // [4, 2, 6]
    ```

      - for문을 사용할때는 배열의 인덱스를 저장하기 위한 임시변수 `i`를 사용하면서 가독성이 떨어지게 된다.
      - 요서 접근방법이 `arr[i]`와 `n`으로 다르다.

    - `Object.keys(obj)`:
      - obj: 처리될 객체 

      ```js
      let obj = { a: 1, b: 2, c: 3 }
      let arr = Object.keys(obj)
      
      console.log(arr) // ['a', 'b', 'c']
      ```

  - jsDoc: python의 docstring이나 java의 javadoc과 비슷하다. `/**`을 입력하면 자동으로 vscode에서 생성해준다. 아래와 같이 파라미터나 생성자를 작성한다. 
  
  ```js
  /**
   * Example
   * @param {integer} example - example
   */
  ```

## 26.01.2019

- aws:
  - lightsail 
    - 인스턴스 새로 생성하기:
    - 우분투 16.04로 설정하기
    - 인스턴스 방화벽에서 열고싶은 포트 설정하기
    - 계정 - SSH키 - 보안키 다운로드
    - PuTTY generator에서 pem파일을 ppk로 바꾸기
    - Connection - Data - Login details에 유저이름 입력하기
    - Connection - SSH - Auth에서 ppk파일 선택하기
    - Session에서 호스트네임(ip주소) 입력하기
    - 세팅 저장후 인스턴스 접속하기

- linux:
  - chmod(change mode): 파일 권한을 변경한다.
    - 700: 사용자가 읽기/쓰기/실행을 할 수 있다.
    - 600: 사용자가 읽기/쓰기를 할 수 있다.
    - 755: 사용자가 읽기/쓰기/실행을 할 수 있고, 그룹이 읽기/실행을 할 수 있으며, 외부에서 읽기/실행을 할 수가 있다.
    - 644: 사용자가 읽기/쓰기를 할 수 있고, 그룹이 읽기를 할 수 있으며, 외부에서 읽기를 할 수가 있다.
   - chown(change owner): 소유권을 변경한다. 
     - `[현재유저이름]:[바꿀유저이름] /home/[현재유저이름]`   
     - `-R`: 하위 디렉토리의 모든 권한을 변경한다.

## 28.01.2019

- UML(Unified Modeling Language): 프로그램 설계를 표현하기 위해 주로 그림으로 된 표기법을 의미한다. 모델링 언어일뿐 방법론은 아니다. 
- Amazon EBS(Elasic Block Store): 클라우드 스토리지의 한종류이다. VM과 데이터를 주고받을때 S3보다 훨씬 빠르고, 비싸다. 사용한 만큼 비용을 지불하는 방식이 아닌 생성 전에 볼륨의 크기를 정해줘야 하는 불편함이 있다.
- mysql:
  - config 파일: 
    - 5.6 이하: `/etc/mysql/my.cnf`
    - 5.7 이상: `/etc/mysql/mysql.conf.d/mysqld.cnf`
- javascript:
  - arrow function: `return`을 `=>`가 함축하고 있다. 

## 30.01.2019

- docker 이미지배포과정:
  - 작성된 Dockerfile을 빌드한다.
  - 이미지가 된다.
  - 이미지를 도커헙에 업로드한다.

- docker 컨테이너간 연결과정:
  - db 컨테이너를 실행시킨다.
  - 웹서버 컨테이너를 실행시킬때 `-p 80:80 --link [컨테이너 이름]:[별명] [이미지 이름]`으로 옵션을 준다.
  - 웹서버 컨테이너 안에서 `[db컨테이너의 별명]:[포트번호]`를 입력하면 db 컨테이너의 db에 접속할 수 있다.

- 우분투에서 node.js, npm 업그레이드
  - node.js:
    - `node -v`: 노드버전을 확인한다.
    - `sudo npm cache clean -f`: 강제로 캐시를 삭제한다.
    - `sudo npm i -g n`: n모듈을 설치한다.
    - `sudo n stable`: node.js를 설치한다.
  - npm:
    - `npm -v`:npm버전을 확인한다.
    - `sudo npm i -g npm`: npm으로 npm을 설치한다.

- linux: 
  - 삭제:
    - `rm [파일명]`: 파일을 삭제한다.
    - `rm -r [디렉토리명]`: 디렉토리를 삭제한다.
      - `-f`: 강제 옵션
      - `-rf`: 디렉토리 강제 옵션 
      - `*`: 현재 디렉토리

## 31.01.2019

- 개발자로서 회사 선택기준:
  - 코드 리뷰를 해주는 곳인지 확인한다.
  - 사수가 있는지 없는지 확인한다.

- airbnb style javascript:
  - 객체 메서드는 줄여서 적는다.

  ```js
  // bad
  const atom = {
    addValue: function (value) {
      return atom.value + value;
    },
  };

  // good
  const atom = {
    addValue(value) {
      return atom.value + value;
    },
  };
  ```

  - 기본 매개변수는 항상 뒤에 위치한다.

  ```js
  // bad
  function handleThings(opts = {}, name) {
    // ...
  }

  // good
  function handleThings(name, opts = {}) {
    // ...
  }
  ```

- web hook: 특정한 이벤트가 발생하면 트리거로 웹훅이 동작하고 지정한 액션이 일어난다.