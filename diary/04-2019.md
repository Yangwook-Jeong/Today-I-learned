## 01.04.2019

- javascript

  - class: 함수를 클래스로서 사용한다.

  ```js
  function Person() {}
  ```

  - object: new키워드를 사용해서 각각의 이름의 새로운 인스턴스를 만들 수 있다.

  ```js
  function Person() {}
  var person1 = new Person();
  var person2 = new Person(); // var1, var2는 인스턴스이다.
  ```

  - constructor
    - 객체 인스턴스가 생성되는 순간 호출된다.
    - 생성자는 해당 클래스의 메서드이다.
    - 자바스크립트에서는 함수 자체가 객체의 생성자 역할을 하기 때문에 생성자 메서드를 따로 정의할 필요가 없다.
    - 클래스 안에 선언된 모든 내역은 인스턴스화되는 그 시간에 실행된다.

  ```js
  function Person() {
    alert('Person instatiated'); // Person이 인스턴스화됐을때 alert를 보여준다.
  }

  var person1 = new Person();
  var person2 = new Person();
  ```

  - property
  - 클래스 안에 있는 변수들을 말한다.
  - 객체의 모든 인스턴스는 그 인스턴스의 속성을 갖는다.
  - 속성의 상속이 바르게 이루어지려면 해당 클래스의 프로토타입이 선언되어있어야 한다.
  - 클래스 내에 속성은 현재 객체를 가리키는 this키워드로 이뤄진다.

  ```js
  function Person(gender) {
    this.gender = gender;
    alert('Person instantiated');
  }

  var person1 = new Person('Male');
  var person2 = new Person('Female');

  alert('person1 is a ' + person1.gender); // person1 is a Male
  ```

  - method: 속성에 접근하는 것과 비슷하지만 끝에 ()를 추가하면 사용할 수 있다.

    ```js
    function Person(gender) {
      this.gender = gender;
    }

    Person.prototype.sayGender = function() {
      alert(this.gender);
    };

    var person1 = new Person('Male');
    var genderTeller = person1.sayGender;

    person1.sayGender(); // 'Male'
    genderTeller(); // undefined
    alert(genderTeller === person1.sayGender); // true
    alert(genderTeller === Person.prototype.sayGender); // true
    ```

  - inheritance
  - encapsulation: 자식클래스는 부모클래스의 모든 메서드를 상속받고 상속받은 메서드중 일부를 수정하고 싶은 경우에만 해당 메서드를 정의하는 것을 말한다.
  - abstraction
  - polymorphism

- react-router

  - `Link`: a태그로 렌더링되며 서버로 해당 Link에 대한 새로운 html을 요청한다.
  - `Route`:
    - 경로를 컴포넌트와 매칭시키기 위한 라우트 컴포넌트이다.
    - 만약 맞는 경로가 아니라면 null을 반환한다.
    - null을 반환해서 화면에는 아무것도 보이지 않는다.
    - eaxt키워드는 path가 정확히 들어왔을때만 컴포넌트를 렌더링한다.
    - 페이지가 늘어날때마다 컴포넌트를 추가하고 Route에 추가한다.
  - `Switch`:
    - Router를 그룹핑해서 사용하기 위해 필요한 요소이다.
    - 현재위치와 일치하는 첫번째 요소만 렌더링해준다.
    - 매칭되는 경로가 아니라면 404페이지를 반환한다.
  - `IndexRoute`
  - `browserHistory`: 일반 웹을 사용하는 것처럼 주소를 바꾸고 뒤로가기와 앞으로가기를 할 수 있다.

    ```jsx
    <Router history={browserHistory}>
    ```

- react

  - `render()`: 실제로 보여지는 DOM을 반환한다.
  - `Fragment`: div태그로 위아래를 감싸는 대신 더 깔끔해보이게 사용할 수 있는 방법이다.
  - children: 컴포넌트 안에 내용물을 집어 넣어줄 수 있는 기능이다.

    ```jsx
    // 부모 컴포넌트
    const Parent = () => {
      return (
        <div id="parent">{this.props.children}</div>
      )
    }

    // 루트 컴포넌트 보통
    <Parent />

    // children을 사용할 경우
    <Parent>
      <span>Hello</span>
    </Parent>
    ```

  - life cycle

    - state, context, defaultProps 저장
    - `componentWillMount()`
    - `render()`
    - `componentDidMount()`: DOM에 접근해서 비동기요청을 보내거나 `setTimeout()`, `setInterval()`을 사용한다.
    - update

      - props: 아래 메서드들은 첫번째 인자로 바뀔 props에 대한 정보를 가지고 있다.
        - 업데이트되기 전에 업데이트가 발생하였음을 감지한다.
        - `componentWillReceiveProps()`가 호출된다.
        - `shouldComponentUpdate()`: 아직 렌더하기 전이기 때문에 `return false`를 하면 render를 취소할 수 있다. 주로 여기서 성능 최적화를 한다. 쓸데없는 업데이트가 일어나면 걸러낼 수도 있다.
        - `componentWillUpdate()`: 여기서는 state를 바꿔서는 안된다. 아직 props업데이트를 하지 않았으므로 state를 바꾸면 `shoudlComponentUpdate()`가 발생한다.
        - 업데이트가 완료되면 `componentDidUpdate()`: 바뀌기 이전의 props정보를 가지고 있다.
      - state: props 업데이트와 과정이 같지만 `componentWillReceiveProps()`메서드는 호출하지 않는다.
        - `shouldComponentUpdate()`
        - `componentWillUpdate()`
        - `render()`
        - `componentDidUpdate()`
      - unmount: 컴포넌트가 제거되는 것을 말한다.
        - `componentWillUnmount()`: 더는 컴포넌트를 사용하지 않을때 사용한다. `componentWillMount()`에서 연결했던 이벤트 리스너를 제거하는 역할을 한다.
      - error

        - `componentDidCatch()`: 리액트 16에서 추가된 기능으로 최상위 컴포넌트에 한번만 넣어주면 에러발생시 어떻게 대처할 것인지를 정의할 수 있다.

          ```jsx
          componentDidCatch(error, info) => {
            console.error(error, info);
          }
          ```

- prop-types: react의 props 자료형 검사방법이다.

- redux

  - state

    - 리액트와는 달리 웹앱 전체의 상태를 관리한다.
    - 홈페이지를 예로 들어 포스트나 유저정보 모든게 state이다.
    - 서버로부터 불러와 state에 저장하고 각각의 컴포넌트는 리덕스에 저장된 state를 읽어와 사용한다.
    - 객체로 표현한다.

    ```js
    // 로그아웃
    {
      fetchingUpdate: false,
      isLoggedIn: true,
      user: {},
    }
    // 로그인 시도중
    {
      fetchingUpdate: true,
      isLoggedIn: true,
      user: {},
    }
    // 로그인
    {
      fetchingUpdate: false,
      isLoggedIn: true,
      user: { 'name': 'name' },
    }
    ```

    - react-redux

      - `connect`:

        - 리액트 컴포넌트를 감싸서 연결시킨다.
        - redux의 state가 `mapStateToProps`를 통해 react의 props로 전달된다.
        - store에서 바뀐 정보가 view로 연결되는 부분이다.

          ```jsx
          import { connect } from 'react-redux';

          class Test extends Component {

          (...)

          }

          function mapStateToProps(state) {
            return { user: state.user } // state.user는 redux의 state
          }                             // user는 props

          export default connect(mapStateToProps)()
          ```

  - action: 액션 이름은 대문자로 표기한다.
  - store
    - reducer:
      - action별로 state를 어떻게 바꿀지 결정하는 부분이다.
      - 반드시 새로운 객체를 반환해야 하기때문에 스프레드 연산자를 사용해서 defaultState를 가져온다.
      - `combineReducers()`: 리듀서를 여러개 사용할 수 있기 때문에 합쳐줄 수 있다.
      - 사용자에 관한 액션은 사용자 리듀서, 포트스에 관한 액션은 포스트 리듀서 등으로 분리하는 것이 관리하기 쉽다.
  - 데이터 흐름: 로그인 요청, 로그인 결과처리 두 단계지만 단방향 데이터의 V -> A -> D -> S(M -> R) -> V의 순서를 따른다.
    - view에서 id, password를 전송한다
    - action을 바탕으로
    - store에서 promiseMiddleware로 ajax를 전송한다.
    - LOGIN_REQUEST가 dispatch된다.
    - reducer에서 state의 fetchingUpdate가 true로 변경된다.
    - view에서 state 변경에 따른점을 처리한다.
    - promiseMiddleware로 보낸 ajax가 도착한다.
    - ajax결과에 따라 LOGIN_SUCCESS 또는 LOGIN_FAILURE action이 추가적으로 dispatch된다.
    - reducer에서 action에 따라 state가 변화한다.
    - state의 변화가 view에 반영된다.
