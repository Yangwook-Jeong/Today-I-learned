# 오늘 배운 것을 정리하는 공간

## 04.09.2019

- storm proxy: 프록시를 씌우는 서비스

## 05.09.2019

- apache spark
  - 하둡을 이용한 정보활용하기 위한 데이터 프로세싱 툴이다.
  - 하둡을 통해 끌어오는 데이터들은 시간 소요가 크기때문에 실시간으로 분석해야 하는 업무에서는 어려운 부분이 있어 개발되었다.
  - 스칼라를 사용해 인터렉티브 쉘을 사용할 수 있다.
  - 분산처리를 하둡보다 빠른 속도로 하는 도구이다.
  - 빅데이터 애플리케이션에 필요한 대부분의 기능을 지원한다.
  - 기능
    - 맵리듀스와 유사한 일괄처리 기능이 있다.
    - 실시간 데이터 처리기능 (spark streaming)
    - sql과 유사한 정형 데이터 처리기능 (spark sql)
    - 그래프 알고리즘 (spark graph x)
    - 머신러닝 알고리즘 (spark mlib)
  - 장점
    - 메모리 효율을 높여서 하둡의 맵리듀스보다 10-100배 빠르게 설계되었다.
    - 맵리듀스처럼 job에 필요한 데이터를 디스크에 매번 가져오는 대신, 데이터를 메모리에 캐시로 저장하는 in-memory 실행 모델로 비약적으로 성능을 개선해싿.
    - 머신러닝, 그래프 알고리즘 등 반복알고리즘과 기타 데이터를 재사용하는 모든 유형 작업에 많은 영향을 준다.
    - 컬렉션 기반의 api를 제공한다.
    - 맵리듀스는 메인, 매퍼, 리듀스 클래스 세가지를 만들어야 하지만, 스파크는 간단한 코드로 해결 가능하다.
    - 스칼라, 자바, 파이썬, r을 지원한다.
    - 프로그램 문제를 테스트하기 위해 쉘을 사용해서 컴파일, 배포를 반복하지 않아도 되며, 전체데이터를 처리하는 작업도 repl에서 해결할 수 있다.
    - 일괄처리 작업이나 데이터 마이닝같은 온라인 분석처리에 유용하다.
  - 단점
    - 단일노드로 충분한 앱에서는 분산 아키텍처로 인해 성능이 오히려 떨어지는 경우도 있다.
  - 컴포넌트
    - 스파크 코어
      - 스파크 잡과 다른 스파크 컴포넌트에 필요한 기본 기능을 제공한다.
      - 분산데이터 컬렉션을 추상화한 객체인 RDD(Resilent Distributed Dataset)로 다양한 연산 및 변환 메서드를 제공한다.
      - 스파크 코어는 다양한 파일시스템에 접근이 가능핟.
      - 공유변수, 누적변수를 사용해 컴퓨팅 노드간 정보를 공유한다.
      - 네트워킹, 보안, 스케쥴링, 데이터 셔플링 등 기능을 제공한다.
    - 스파크 SQL
      - 하이브 sql이 지원하는 sql을 사용해 대규모 분산 정형데이터를 다룰 수 있다.
      - json, parquet, rdb테이블, 하이브테이블 등을 읽고 쓸 수 있다.
      - dataframe과 dataset에 적용된 연산을 일정 시점에 rdd연산으로 변환해 일반 스파크 잡으로 실행한다.
    - 스파크 스트리밍
      - 실시간 스트리밍 데이터를 처리하는 프레임워크이다.
      - hdf, 카프카, 플럼, 트위터 제로mq와 더불어 커스텀 리소스도 사용할 수 있다.
      - 다른 스파크 컴포넌트와 함께 사용할 수 있다.
    - 스파크 MLlib
      - 머신러닝 알고리즘 라이브러리이다.
    - 스파크 그래프X
      <img src="http://www.bogotobogo.com/Hadoop/images/Ecosystem/Hadoop_Ecosystem3.png" width="500">
- hadoop
  - 병렬처리가 가능하고, 부분적으로 장애가 발생한 경우 전체 시스템은 동작할 수 있는 장애내성을 갖는 시스템으로 만들 수 있다.
  - 맵리듀스의 핵심은 최소한의 api만 노출해 대규모 분산 시스템을 다루는 복잡한 작업을 감춘다.
  - 병렬처리를 프로그래밍적 방법으로 지원하는 점이다.
  - 다루는 데이터가 크기때문에 데이터를 가져와서 처리하는 것이 아니라, 데이터가 저장된 곳으로 프로그램을 전송한다.
  - 이 점이 기존 dw, rdbms와 맵리듀스의 가장 큰 차이점이다.
  - 동작원리
    - job을 잘게 분할하고 cluster의 모든 node로 mapping한다.
    - 각 node는 job을 처리한 중간결과를 생성한다.
    - 분할된 중간결과를 reduce해서 최종결과를 낸다.
  - 한계
    - 맵리듀스 job의 결과를 다른 job에서 사용하려면 이 결과를 hdfs에 저장해야 한다. 그래서 이전 job의 결과가 다음 job의 입력이 되는 반복 알고리즘에는 본질적으로 알맞지 않다.
    - 하둡은 low-level 프레임워크이다 보니 데이터를 조작하는 high-level 프레임워크나 도구가 많아 환경이 복잡하다.

## 08.09.2019

- 정규식
  - ^: 부정
  - \$: 어떤 문자로 끝남
- Array.prototype.fn
  - 파일을 따로 export 하지 않아도 같은 디렉토리 안에만 있으면 사용하고자 하는 파일에서 익명으로 require/import 하면 바로 사용가능하다.

## 09.09.2019

- html내 script태그 삽입위치
  - head에 삽입되는 경우
    - 브라우저 렌더링에 방해가 된다.
    - 문서를 초기화하거나 설정하는 가벼운 스크립트들이 자주 사용된다.
    - 추적코드를 넣을때 사용하는 것 같다.
  - body에 삽입되는 경우 - 광고 혹은 채팅봇을 삽입할때 사용하는 것 같다.

## 21.09.2019

- kubernetes

  - 구성요소

    - node

      - k8s의 cluster의 관리대상으로 등록된 docker host로 container가 배치되는 대상이다.
      - node는 master와 일반으로 구성된다
      - cluster 전체를 관리하는 server에는 master가 적어도 하나 이상 있어야 한다.
      - master는 cluster를 상호 조정하는 장치이다.
      - node는 application이 실제로 돌아가는 곳이다.
      - node에는 여러 pod들이 위치할 수 있다.
      - 그 pod에는 container들이 존재한다.
      - node의 resource 사용 현황 및 배치 전략을 근거로 container를 적절하게 배치한다.
      - cluster에 배치된 node 수, 사양 등에 따라 node에 배치할 수 있는 container 수를 정한다.
      - cluster의 처리능력은 node에 의해 결정된다.
      - `kubectl get nodes`

      <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbCRY73%2FbtqycO1fg6b%2F4rxigvhJkcSnMphAZFPGn0%2Fimg.png" width="250"> <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FepYMo3%2FbtqydQEdHv1%2FaD96xNBmCgsiSUXy49Mzq0%2Fimg.png" width="250">

    - namespace

      - cluster 내부에는 여러개의 가상 cluster를 만들 수 있다.
      - 이 namespace는 하나의 공간으로서 사람 또는 상황에 따라서 나눠 사용할 수 있다.
      - 기본적으로는 default로 되어있다.

      <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fbghg6n%2Fbtqyen2EUtJ%2FnkOauao4Y2fHUVeAudK4s1%2Fimg.png" width="250"> <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbUhCaZ%2Fbtqyce6WcDf%2FE2q4USt5PAoXsrksOLjUL1%2Fimg.png" width="250">

    - pod

      - container가 모인 집합체로써 하나 이상의 container로 이루어진다.
      - nginx, was처럼 서로간의 연결고리가 있는 container들은 하나로 묶어 일괄배포한다.
      - pod는 node내에 배칮되고 같은 pod는 여러 node에 배치할 수도 있고, 한 node에 여러개 배치할 수도 있다.
      - 하나 또는 그 이상의 application container 그룹을 나타내는 kubernetes의 추상적 개념으로 container에 대해 서로 자원을 공유한다.

      <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FCCR2x%2FbtqyaqG0jWd%2FyHSnEkhduYEVvYsLOZkQd1%2Fimg.png" width="250"> <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FlJIrl%2FbtqyaqG0klp%2FeVL10pTNUT8BiXSJdI6PMk%2Fimg.png" width="250">

    - replica set: pod를 하나만 사용해 가동할 경우 실제 가용성이 떨어지기 떄문에 replica set를 만들어서 여러 pod를 함께 구성한다.
    - service

      - 이를 이용해 각 pod에 있는 application을 외부에서 접근하게 할 수 있다.
      - 하나의 논리적인 pod set과 그 pod들에 대한 접근할 수 있는 정책을 정의하는 추상적인 개념이다.
      - service는 종속적인 pod들 사이를 느슨하게 결합하도록 도와준다.
      - 모든 k8s object들과 같이 yml로 정의할 수 있다.
      - 각 service과 되는 대상을 labelSelector를 통해 지정할 수 있도록 허용한다.
      - ServiceSpec에서 type을 지정함으로서 다양한 방식들로 노출할 수 있다.

      <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FX5j6I%2Fbtqybfk0lLi%2F2vRSQ7CWlE3AaeajV9xFzk%2Fimg.png" width="250">

    - deployment
      - service, pod, replica set의 집합체로써 application의 기초가 되는 단위이다.
      - 내부에는 service, pod, replica set 등을 한번에 구성하여 적용시킬 수 있다.
      - service는 내부에 여러 pod들을 외부와 연결시켜주는 역할을 담당하는 반면, deployment는 k8s에서 돌아가는 pod들의 상태를 확인하면서 재시작 등을 진행하는 일을 한다.

- javascript

  - 함수 메서드
    - `apply()`
      - `fn.apply([thisObj[,argArray]])`
      - 주어진 this값과 배열로 제공되는 `arguments`로 함수를 호출한다.
      - `call()`과 거의 유사하다. 근본적인 차이점은 `call()`은 함수에 전달된 인수리스트를 받는데 비해, `apply()`는 인수들의 단일 배열을 받는다는 점이다.
    - `call()`
      - `fn.call([thisObj[, arg[, arg2[, ...]]]])`
        - thisObj: 현재 객체로 사용될 객체
        - arg: 메서드에 전달될 인수
      - 다른 객체 대신 메서드를 호출하는데 사용된다. 함수의 this객체를 원래 context에서 thisObj로 지정된 새 객체로 변경할 수 있다.
    - `bind()`
      - 함수가 가리키는 this만 바꾸고 호출은 따로 하지 않는다.
  - 매개변수와 인자
    - parameter: 함수에서 받을 수 있는 변수
      - rest: es6부터는 `arguments`를 사용하지 않고 나머지를 `...rest`와 같이 표현한다.
    - argument: 함수를 실행할때 넣는 값
  - Number
    - `parseInt(숫자, 진법)`: 정수
    - `parseFloat(숫자)`: 실수
  - Math
    - `floor(값)`: 내림
    - `ceil(값)` 올림
    - `round(값)`: 반올림, 소수점을 반올림하려면 `Number.toFixed()`를 써야한다.
  - window
    - `setTimeout(fn, ms)`: 지정한 시간 후에 실행된다.
    - `setInterval(fn, ms)`: 지정한 시간마다 반복된다.
    - `getComputedStyle(el)`: 태그의 스타일을 찾는 메서드이다.
  - BOM
    - `navigator`
      - 브라우저, os에 대한 정보가 `userAgent`에 있다.
      - 분석 사이트에서는 고객에 대한 정보를 분석가능하다.
      - `language`, `cookieEnabled`, `vendor`같은 정보도 확인 가능하다.
    - `screen`: 화면에 대한 정보를 알려준다.
    - `location`
      - 주소에 대한 정보를 알려준다.
      - `reload()`: 새로고침이 가능하다.
      - `replace()`: 현재 주소를 다른 주소로 교체한다.
    - `history`
      - `forward()`, `back()`, `go(num)`로 페이지 이동을 할 수 있다.
      - `pushState(obj, title, address)`, `replaceState(obj, title, address)`가 html5에서 추가되었다. 페이지를 이동하지 않고 단순 주소만 바꿔준다. 객체 부분에 페이지에 대한 정보를 추가 가능하다. spa에서 자주 이용된다. 페이지 깜빡임 없이 주소를 바꾸고, 바뀐 주소에 따른 액션을 취할때 사용한다.
  - document
    - `createElement(tagName)`: 새로운 태그를 만들때 사용한다. 변수를 통해 메모리에 저장만 된다.
    - `createTextNode(text)`: node는 태그와 텍스트를 가리킨다. 변수를 통해 메모리에 저장만 된다.
    - `createDocumentFragment()`: 가짜 document를 만든다. javascript로 document를 조작하는 것은 매우 성능이 떨어진다. 그래서 반복적으로 태그를 만들때는 여기서 추가한 다음 한 번에 document에 추가하는 방식을 사용한다.
  - DOM
    - `children(텍스트 노드 제외)`, `childNodes(텍스트 노드 포함)`으로 자식을 알 수 있다.
    - `firshChild`, `firstElementChild`, `lastChild`, `lastElementChild`로 하나의 자식만 알 수 있다.
    - `parentNode`, `parentElement`로 부모를 알 수 있다.
    - `previousSibling`, `nextSibling`, `previousElementSibling`, `nextElementSibling`으로 형제를 알 수 있다.
    - `appendChild()`, `removeChild()`로 자식을 추가, 제거할 수 있다.
    - `insertBefore()`로 형제에게 자식을 추가할 수 있다.
    - `cloneNode()`로 자신을 복사할 수 있다.
  - FP

    - 인자로 받지 않은 변수를 함수 내부에서 사용하지 않아야 한다.

      ```js
      // before
      const arr = [1, 2, 3, 4, 5];
      const condition = x => x % 2 === 0;
      const ex = array => {
        return array.filter(condition);
      };
      ex(arr); // [2, 4]

      // after
      const ex = (array, cond) => array.filter(cond);
      ex(arr, condition);
      ```

    - 함수형에서는 반복문을 사용하지 않고 재귀적으로 사용하는 것을 추천한다.

  - Map
    - Object와 달리 순서가 기억되고 key가 문자열이 아니어도 된다.
    - `set()`, `get()`, `has()`, `delete()`, `clear()`등의 메서드가 존재한다.
    - `entries()`: Map 안의 key-value 쌍을 리턴한다.
    - Map의 크기를 항상 체크가능하다.
  - WeakMap
    - 키가 객체인 Map이다.
    - 기존 객체를 약한 참조해서 garbage collection을 방해하지 않기 때문이다.
    - 대신 `entries()`, `keys()`, `values()`를 사용할 수 없다.
  - Set
    - 배열과 비슷하다. 배열과 달리 값이 중복될 수 없다.
    - 중간 값을 확인하는 것이 불가능하다.
  - WeakSet
  - Array

    - `from()`: 배열이 아닌 것(string, 유사배열, 반복가능 객체)을 배열로 만들어준다.
    - `of(arg)`: 인자를 요소로 갖는 배열을 만든다.
    - `fill(val, start, end)`: 배열을 요소를 인자로 제공한 값으로 대체한다.

      ```js
      [1, 3, 5, 7, 9].fill(4); // [4, 4, 4, 4, 4]
      [1, 3, 5, 7, 9].fill(4, 1, 3); // [1, 4, 4, 7, 9]
      ```

    - `find(fn)`: 배열 안의 요소를 찾는다.
    - `findIndex(fn)`: 해당 요소 대신 그 요소의 위치를 반환한다.
    - `copyWithin(goal, start, end)`: 목표의 위치에 시작점부터 끝점까지의 배열을 덮어씌운다.

  - String
    - `startsWith(str, start)`: 문자열이 주어진 인자로 시작하는지 체크한다.
    - `endsWith(str, len)`: 문자열이 주어진 인자로 끝나는지 체크한다. 길이가 주어지면 해당 문자열의 길이가 len이라고 가정한 상태에서 체크한다.
    - `repeat(num)`: 문자열을 반복한다.
  - Object

    - `assign(goal, sc1[, sc2[, ...]])`: 객체를 얕은 복사하는 메서드이다.

      ```js
      Object.assign({}, { a: 1 }); // { a: 1 }
      Object.assign({ a: 1, b: 1 }, { a: 2 }, { a: 3 }); // { a: 3, b: 1 }
      ```

    - `is(val1, val2)`: 두 값이 같은지 비교한다.

  - Proxy
    - 대리인이란 의미를 가진 중간 단계를 말한다.
    - 기존 객체를 건들지 않고도 새 기능을 추가하거나 기존 기능을 ㅜㅅ정할 수 있다.
    - target: 목표하는 객체
    - handler: 추가 또는 수정할 기능을 적는 부분이다.
