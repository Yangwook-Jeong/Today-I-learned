# 오늘 배운 것을 정리하는 공간

## 01.01.2019

- sql 다중 행 연산자: 하나 이상의 값을 요구하며 단일행 비교연산자(`<`, `>`, `=`)와 결합해 사용할 수 있다.

  - `IN`: 하나의 컬럼이 여러개의 `=` 조건을 가지는 경우에 사용한다.
  - `ANY`, `SOME`: 비교하는 값들 중 하나라도 만족한다면 행을 반환한다.
  - `ALL`: 비교하는 값들 중 모든 값을 만족한다면 행을 반환한다.
  - `EXISTS`: 데이터 존재여부를 참, 거짓으로 반환한다.

## 01.02.2019

- concurrently: 패키지 파일에 서버를 여러개 띄울 수 있도록 해주는 패키지다. 글로벌 설치해서 사용하도록 한다. `concurrently \"`하고 서버실행 명령어를 입력한다.
- travis: 세팅을 노드로 해두면 `npm test`가 기본적으로 실행된다. db를 사용한다면 db생성하는 명령이 필요하며 `services`에 설정할 수 있다. `before_install`에 등록한 명령으로 테스트 db를 생성한 뒤 의존성모듈성 전부 설치 후 모카 테스트를 순서대로 실행한다. 테스트 후 리액트 빌드 작업을 해야하는데 노드 서버에서는 빌드 파일을 정적 파일로 사용하기 때문이다. 그리고 빈스톡은 깃 헤드파일을 기준으로 체크아웃해서 배포한다. 따라서 빌드한 리액트 코드를 깃에 추가해줘야 코드를 배포할 수 있다. aws 빈스톡으로 보내려면 트라비스의 배포 제공자를 설정하면 된다.
- beanstalk: 도커 컨테이너를 기반으로 앱을 배포하고 관리하는 툴이다. 빈스톡에서 배포를 하면 깃이나 S3에 소스코드가 올라간다. 그리고 공짜다.
- 웹서버: 정적 파일을 node서버에서 처리하는 것보다 nginx나 apache서버에서 처리하는 것이 훨씬 성능이 좋다고 한다.
- hooking: 이미 작성된 코드의 특정 지점을 가로채서 동작방식에 변화를 주는 기술을 말한다. 대상코드 소스를 수정하지 않고 원하는 동작을 해야하기 때문에 하기가 어렵다.

- 개발 방법론:

  - TDD(Test Driven Development):
    - 테스트 간에 의존이 없어야 한다.
    - 시나리오를 먼저 작성하는 것이 중요하다.
    - 스토리를 먼저 정의하고 테스트 스펙을 정의한다.
    - 프로그램의 가장 하위부분에 집중한다. 프로그램의 가장 안쪽에서 사용자에 가까운 바깥쪽으로 만들어 나가는 방식이라서 인사이드 아웃 방식이라고 부른다.
    - 개발자를 위한 방식이다.
  - BDD(Behavior Driven Development):
    - 테스트 케이스를 작성하는데 좀 더 자연어에 가깝게 작성한 것을 말한다.
    - 초심자가 TDD를 더 빨리 익힐 수 있게 하자는 취지에서 탄생했다.
    - 사용자에 가까운 바깥쪽부터 안쪽으로 만들어 나가는 방식이라서 아웃사이드 인 방식이라고 부른다.
    - 최종목표를 미리 명확하게 해서 시스템 모듈이 잘게 분산되는 것을 막는다.
    - 책임관계자와 함께 하기 위한 방식이다.
    - 종류:
    - spec: 자연어로 앱 구현을 묘사하는 테스트 유형이다.
    - story: 보다 상위 수준 행동에 중점을 둔 테스트 유형이다. 구체적인 구현이 아닌 보다 추상적인 묘사를 한다.
  - DDD(Domain Driven Development): 데이터 중심의 접근법에서 벗어나 순수한 도메인의 모델과 로직에 집중하는 것을 말한다.

- mocha: 커스텀 가능한 범위가 넓어 큰 프로젝트에 적합하다.
  - `.describe()`: 큰 카테고리를 정의할 때 사용한다. 예를 들어 성공케이스와 실패케이스.
  - `.it()`: 서브 카테고리를 정의할 때 사용한다.
- jest: 커스텀이 필요없어 작은 프로젝트에 적합하다.

- 테스트 기법:

  - unit test: 개별 유닛(모듈, 함수, 클래스)을 나머지 앱과 분리해 테스트한다. 주로 객체지향 프로그래밍에서는 주로 클래스나 메서드가 테스트 대상이다. test double이 사용되고 테스트 대상의 범위가 좁기떄문에 테스트 케이스가 실패하면 어디서 어떤 문제가 발생했는지 파악하기가 쉽다. 일반적으로 단위테스팅은 GUI 계층에 적용하기 어렵다.
  - functional test: 사용자의 관점에서 앱을 테스트한다. acceptance test와 비슷하지만 필수적으로 자동화 된다. E2E(End to End) test라고도 부른다.
  - integration test: 두 개 이상의 유닛간의 통합을 테스트한다.
  - acceptance test: 소프트웨어가 승인 기준에 만족하는지 검사하는 blackbox test이다. 테스트 케이스는 사용자가 작성한다.
  - 하위 테스트 종류:
    - blackbox test: 유닛의 공용 인터페이스만 사용해서 테스트 되는데 이것은 고장나기 쉽다.
    - whitebox test: 유닛의 내부 구현방식까지 다루는 이 테스트는 더더욱 고장나기 쉽다. 여기에 훨씬 많은 시간과 노력이 들어간다.

- coverage: 100줄의 코드가 있다면 80줄의 코드가 테스트되고 있다면 커버리지가 80%란 개념이다. 테스트가 얼마나 충분한가를 나타내는 지표 중에 하나라고 볼 수 있다. 커버리지를 100% 달성하길 바라는 것은 자원 낭비이다.

  - code coverage: 코드가 실행되는 정도
  - case coverage: 테스트 스위트가 커버하는 케이스의 수

- test double:
  - 테스트 대상 코드를 격리한다.
  - 테스트 속도를 개선한다.
  - 예측 불가능한 실행요소를 제거한다.
  - 특수한 상황을 시뮬레이션한다.
  - 감춰진 정보를 얻어낸다.
  - 종류: 구분하기가 다소 모호한 부분이다.
    - dummy: 가장 기본적인 유형이다. 구현이 포함되지 않았고 다른 곳에 이용되지 않는 경우 주로 사용한다.
    - stub: 원래의 구현을 최대한 단순한 것으로 대체하는 것을 말한다. 마치 실제로 dummy객체가 동작하는 것처럼 보이게 만들어놓은 객체이다. dummy보다 한단계 발전한 형태이다. 테스트 신뢰도 또한 높은편이다.
    - fake: 실제 로직같은 코드를 말하는데 이렇게 만들어진 객체를 fake객체라고 말한다. 모양만으로 stub과 fake를 구분짓기는 어렵다.
    - spy: 테스트에서 특정객체가 사용됐는지 호출여부를 감시해서 기록했다가 요청이 들어오면 해당정보를 전달해주는 객체이다.
    - mocking:
      - 실제 구현 코드를 대신하는 모의 객체를 말한다.
      - test double과 mock객체가 거의 동등한 의미로 사용되는 경우가 많다.
