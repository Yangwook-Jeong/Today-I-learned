# 오늘 배운 것을 정리하는 공간

## 03.12.2018

- 요청헤더:
  1. User-Agent: 이것을 활용해 접속자 통계를 낼 수 있다. IE로 접속한 사람을 찾아낼 수도 있어 이를 이용해, IE는 지원하지 않으니 크롬을 이용해달란 메시지를 띄울 수도 있다.
  2. Host: 헤더는 반드시 1개가 있어야 한다.
  3. Authorization: 인증토큰을 서버로 보낼때 사용하는 헤더이다.
  4. Origin: 요청 보낸 주소와 받는 주소가 다르면 CORS문제가 생긴다.
     - 요청 응답헤더에 `'Access-Control-Allow-Origin': '*'`을 넣어주면 모든 요청을 허용할 수 있다. 하지만 `'*'`는 모든 요청을 허용하기 때문에 이 부분만 바꿔주면 된다.
     - CORB현상: CORS를 허용하더라도 POST, PUT, DELETE 요청에서 `json`으로 보내면 차단되는 현상이다. `json` 대신 `www-form-unlencoded` 형식으로 데이터를 보내면 해결할 수있다.

## 04.12.2018

- jwt는 보통 세션과 함께 쓰이지 않는다. 내부 정보들이 세션과 중복되기 때문이다. 클라이언트에서 요청을 보낼떄 `headers`에 `Authorization`키에 jwt를 넣어서 보내면 서버에서 `req.get('Authorization')`으로 받을 수 있다.
- passport는 세션 기반이라 jwt를 연동하려면 `passport-jwt`를 사용해야 한다. 하지만 아직까지는 여기 소셜로그인을 어떻게 접착해야하는지 잘 모르겠다.

## 05.12.2018

- 프론트에서는 `token`을 `localStorage`에 저장한다.
- passport with jwt: `passport`, `passport-jwt`가 기본적으로 필요하다.

  1.  jwt를 활성화시키려면 passport 옵션에 `{ session: false }`를 넣어준다.
  2.  `.Strategy`와 `.ExtractJwt`를 `passport-jwt`에서 불러와야 한다.
  3.  ExtractJwt에 `.fromAuthHeaderAsBearerToken()` 메소드를 불러온다.
  4.  토큰 저장소로 redis도 괜찮은 옵션이다.

- 쿠키:

  1.  웹서버에서 브라우저로 보내는 **데이터 문자열** 이다.
  2.  프론트와 백간에 데이터를 주고받는 가장 간단한 방법이다.
  3.  서버 -> 브라우저: `Set-Cookie`라는 헤더 형식으로 전달한다.
  4.  브라우저 -> 서버: `Cookies`라는 헤더 형식으로 재전달한다.

- 헤더: API 요청같은 것을 할 때 Authorization 헤더에 토큰값이 없으면 거절당한다.
- http: 애플리케이션 계층의 확장 가능한 프로토콜이다. 상태는 없지만 세션은 있다. 세션이 있다는 말은 쿠키가 있다는 말이다. 쿠키사용은 상태가 있는 세션을 만든다.

     <img src="https://mdn.mozillademos.org/files/13673/HTTP%20&%20layers.png" width="500">

- 테스팅:

  1.  coverage보려면 istanbul을 사용하면 된다.
  2.  테스팅 파일은 `test` 디렉토리 따위를 만들어 따로 보관한다.

- 디버깅:

  1.  `DEBUG=FRAMEWORK_NAME* node APP.js`를 하면 `FRAMEWORK_NAME`과 관련된 모든 로그들을 출력한다.
  2.  `node debug APP.js`는 이제 사용하지 않고 `node inspect APP.js`를 사용해서 빌트인 디버거를 사용할 수 있다.

- prototype:
  1. prototype link:
  2. prototype object: 항상 객체로 생성된다. 프로토타입이 생성되기 전 원래 있던 함수에 생성자 자격이 부여된다. 이 자격이 부여되면 `new`를 통해 객체를 만들어낼 수 있게 된다. 함수를 생성하면 함수만 생성되는 것이 아니라 프로토타입 객체도 함께 생성된다. (`new Person() = Person.prototype`)

<img src="https://cdn-images-1.medium.com/max/1600/1*PZe_YnLftVZwT1dNs1Iu0A.png" width="500">

- `constructor`: 프로토타입 객체와 함께 생성된 함수를 가리킨다.
- `__proto__`: 프로토타입 객체를 가리키고 모든 객체가 빠짐없이 가지고 있는 속성이다.

<img src="https://cdn-images-1.medium.com/max/1600/1*jMTxqTYDZGhykJQoimmb0A.png" width="500">

- prototype chain: 프로토타입 객체 밑에 있는 프로토타입 객체와 연결시켜주는 속성이 `__proto__`속성이다. 하위 프로토타입 객체의 `__proto__`는 연결된 객체가 없기 때문에 값이 `null`이다.

<img src="https://cdn-images-1.medium.com/max/1600/1*mwPfPuTeiQiGoPmcAXB-Kg.png" width="500">

## 06.12.2018

- BaaS(Backend as a Service): 대표적으로 firebase가 있다. 웹이나 모바일앱과 데이터베이스나 유저인증을 연결시켜준다.
- FaaS(Function as a Service): 대표적으로 aws lambda, google cloud functions, azure functions, apache openwhisk가 있다.
- serverless: node.js 프레임워크. 람다를 이용할 수 있다. npm이나 yarn에서 전역으로 설치한후 `sls`나 `serverless`명령어를 사용할 수 있다. 설정은 `serverless.yml`에서 해야 한다. REST api랑은 조금 다른거같다.
- ndb:`npm i -g ndb`를 이용해서 설치한다. 실행은 `ndb`로 실행한다. 빌드가 오래걸릴 경우에 사용하면 좋고, 그게 아니라면 `console.log`를 쓰자.

- 디버깅: 결함의 원인을 찾고, 코드를 수정하는 활동
- 테스팅: 결함을 발견하기 위한 활동

## 07.12.2018

- 테스트 프레임워크:
  1.  mocha:
      - 테스트 실행이 빠르다.
      - 어느 라이브러리와도 함께 사용할 수있다.
      - 보다 더 대중적이다.
      - 간단하고 명료한 api를 가졌다.
  2.  jest:
      - 문서가 빈약하다.
      - jasmine사용을 강요한다.
- chai: 테스트 라이브러리
- supertest: 리퀘스트를 보낼때 사용

## 08.12.2018

- TDD(Test Driven Development):
  1.  red: 실패하는 테스트를 만든다.
  2.  green: 테스트를 통과하도록 코드를 작성한다.
  3.  refactor: 불필요한 코드를 삭제한다.

## 10.12.2018

- 하루프레스: 마크다운의 수퍼셋 격
- 인증:

  - 세션 베이스: 매우 간단하지만 여러개의 서버를 통해 서비스가 돌아간다면 문제가 생길 수 있다.
  - 쿠키-베이스: 처음에 쿠키 세팅을 해야하고 요청과정에서 쿠키를 잃을 위험도 있다.
  - 토큰-베이스: 쿠키-베이스의 변형이고 쿠키같은 방법으로 토큰을 생선하지만 요청은 스스로 해야한다. 일반적으로 `Authorization`헤더나 url에 직접 넣어서 한다.
    - [There is a performance penalty though, in that you need to resolve the token into the actual credentials on every single request made.](https://www.sitepoint.com/spa-social-login-google-facebook/)
    - 토큰을 실제 인증으로 매 요청마다 해야하기 떄문에 성능상 저하가 있긴하다.

- 환경변수 설정: `.env`파일처럼 작성한다.
  - 리눅스/맥: `export`
  - 윈도우즈: `set`
- 패스포트 셋업과정:
  1. `passport.initilaize()`
  2. 세션을 사용한다면 `passport.session()`을, 사용하지 않고 stateless API를 만들고 매 요청마다 인증을 제공할거라면 쓰지않는다.
  3. `passport-jwt`모듈에서 `.ExtractJwt.fromAuthHeader()`메서드를 사용하면 `Authorization`헤더를 찾는다.
  4. 라우터에서 `.authenticate()`메서드를 작성한다. jwt전략을 쓴다면 `['jwt']`를, 세션을 쓰지 않는다면 `{session: false}`를 꼭 쓴다.
  5. 테스팅
  6. 토큰 생성, 재생성 로직 작성
  7. 소셜로그인 로직 작성
  8. 소셜로그인 콜백 라우터에서 토큰을 생성해준다.

## 11.12.2018

- 주니어에게 요구되는 사항:
  - 명령을 받지 않았어도 쓸모있는 행동을 해라. 모르겠으면 물어봐라.
  - 지금 사용않는 간단한 코드부터 없애고 로딩시간을 줄여봐라.
  - 민감해지고 시니어에게 확인을 더 많이 받아라.
  - 버전이 낮은 api, 라이브러리를 업데이트 시켜라.
  - 새로운 라이브러리가 우리와 관련있어 보이면 조사하고 우리가 어떻게 써야할지 아웃라인을 짜라.
  - 시니어에게 내가 무슨 도움이 될 수 있을까 물어봐라.
